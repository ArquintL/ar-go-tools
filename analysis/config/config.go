// Package config provides a simple way to manage configuration files.
// Use Load(filename) to load a configuration from a specific filename.
// Use SetGlobalConfig(filename) to set filename as the global config, and
// then LoadGlobal() to load the global config.
// A config file should be in yaml format. The top-level fields can be any of
// the fields defined in the Config struct type. The other fields  are defined
// by the types of the fields of Config and nested struct types.
// For example, a valid config file is as follows:
// ```
// sinks::
//   - package: fmt
//     method: Printf
//
// sources:
//   - method: Read
//
// ```
// (note the use of lowercase)
package config

import (
	"fmt"
	"os"
	"path"

	"github.com/awslabs/argot/analysis/functional"
	"gopkg.in/yaml.v3"
)

var (
	// The global config file
	configFile string
)

// SetGlobalConfig sets the global config filename
func SetGlobalConfig(filename string) {
	configFile = filename
}

// LoadGlobal loads the config file that has been set by SetGlobalConfig
func LoadGlobal() (*Config, error) {
	return Load(configFile)
}

// Config contains lists of sanitizers, sinks, sources, static commands to identify ...
// To add elements to a config file, add fields to this struct.
// If some field is not defined in the config file, it will be empty/zero in the struct.
type Config struct {
	sourceFile string

	// nocalleereportfile is a file name in ReportsDir when ReportNoCaleeSites is true
	nocalleereportfile string

	// ReportsDir is the directory where all the reports will be stored. If the yaml config file this config struct has
	// been loaded does not specify a ReportsDir but sets any Report* option to true, then ReportsDir will be created
	// in the folder the binary is called.
	ReportsDir string

	// Sanitizers is the list of sanitizers for the taint analysis
	Sanitizers []CodeIdentifier

	// Validators is the list of validators for the dataflow analyses
	Validators []CodeIdentifier

	// Sinks is the list of sinks for the taint analysis
	Sinks []CodeIdentifier

	// Sources is the list of sources for the taint analysis
	Sources []CodeIdentifier

	// StaticCommands is the list of identifiers to be considered as command execution for the static commands analysi
	// (not used)
	StaticCommands []CodeIdentifier

	// PkgPrefix is a filter for the taint analysis to build summaries only for the function whose package match the
	// prefix
	PkgPrefix string

	// DataFlowSpecs is a path to a json file that contains the data flows specs for the interfaces in the taint
	// analysis
	DataflowSpecs string

	// SkipInterprocedural can be set to true to skip the interprocedural (cross-function analysis) step
	SkipInterprocedural bool

	// Coverage can be used to filter which packages will be reported in the coverage. If non-empty, coverage will only
	// be reported for those packages that have Coverage as a substring
	Coverage string

	// ReportSummaries can be set to true, in which case summaries will be reported in a file names summaries-*.out in
	// the reports directory
	ReportSummaries bool

	// ReportPaths specifies whether the taint flows should be reported in separate files. For each taint flow, a new
	// file named taint-*.out will be generated with the trace from source to sink
	ReportPaths bool

	// ReportCoverage specifies whether coverage should be reported. If true, then a file names coverage-*.out will
	// be created in the report directory, containing the coverage data generated by the analysis
	ReportCoverage bool

	// ReportNoCalleeSites specifies whether the tool should report where it does not find any callee.
	ReportNoCalleeSites bool

	// MaxDepth sets a limit for the number of function call depth explored during the analysis
	// Default is 1000 (TODO: work towards not needing this)
	// If provided MaxDepth is <= 0, then it will be reset to default.
	MaxDepth int

	// Verbose control the verbosity of the tool
	Verbose bool
}

// NewDefault returns an empty default config.
func NewDefault() *Config {
	return &Config{
		sourceFile:          "",
		nocalleereportfile:  "",
		ReportsDir:          "",
		Sanitizers:          nil,
		Sinks:               nil,
		Sources:             nil,
		StaticCommands:      nil,
		PkgPrefix:           "",
		DataflowSpecs:       "",
		SkipInterprocedural: false,
		Coverage:            "",
		ReportSummaries:     false,
		ReportPaths:         false,
		ReportCoverage:      false,
		ReportNoCalleeSites: false,
		MaxDepth:            1000,
		Verbose:             false,
	}
}

// Load reads a configuration from a file
func Load(filename string) (*Config, error) {
	config := Config{}
	b, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("could not read config file: %w", err)
	}
	err = yaml.Unmarshal(b, &config)
	if err != nil {
		return nil, fmt.Errorf("could not unmarshal config file: %w", err)
	}

	config.sourceFile = filename

	if config.ReportPaths || config.ReportSummaries || config.ReportCoverage || config.ReportNoCalleeSites {
		if config.ReportsDir == "" {
			tmpdir, err := os.MkdirTemp(path.Dir(filename), "*-report")
			if err != nil {
				return nil, fmt.Errorf("could not create temp dir for reports")
			}
			config.ReportsDir = tmpdir

			if config.ReportNoCalleeSites {
				reportFile, err := os.CreateTemp(config.ReportsDir, "nocalleesites-*.out")
				if err != nil {
					return nil, fmt.Errorf("could not create report file for no callee site")
				}
				config.nocalleereportfile = reportFile.Name()
				reportFile.Close() // the file will be reopened as needed
			}
		} else {
			err := os.Mkdir(config.ReportsDir, 0750)
			if err != nil {
				if !os.IsExist(err) {
					return nil, fmt.Errorf("could not create directory %s", config.ReportsDir)
				}
			}
		}
	}

	// Set the MaxDepth default if it is <= 0
	if config.MaxDepth <= 0 {
		config.MaxDepth = DefaultMaxCallDepth
	}

	functional.Iter(config.Sanitizers, CompileRegexes)
	functional.Iter(config.Sinks, CompileRegexes)
	functional.Iter(config.Sources, CompileRegexes)
	functional.Iter(config.StaticCommands, CompileRegexes)
	functional.Iter(config.Validators, CompileRegexes)
	return &config, nil
}

func (c Config) ReportNoCalleeFile() string {
	return c.nocalleereportfile
}

// RelPath returns filename path relative to the config source file
func (c Config) RelPath(filename string) string {
	return path.Join(path.Dir(c.sourceFile), filename)
}

// Below are functions used to query the configuration on specific facts

func (c Config) IsSource(cid CodeIdentifier) bool {
	b := ExistsCid(c.Sources, cid.equalOnNonEmptyFields)
	return b
}

func (c Config) IsSink(cid CodeIdentifier) bool {
	return ExistsCid(c.Sinks, cid.equalOnNonEmptyFields)
}

func (c Config) IsSanitizer(cid CodeIdentifier) bool {
	return ExistsCid(c.Sanitizers, cid.equalOnNonEmptyFields)
}

func (c Config) IsValidator(cid CodeIdentifier) bool {
	return ExistsCid(c.Validators, cid.equalOnNonEmptyFields)
}

func (c Config) IsStaticCommand(cid CodeIdentifier) bool {
	return ExistsCid(c.StaticCommands, cid.equalOnNonEmptyFields)
}
