diff --git a/.verification/agent/context/context-stub.gobra b/.verification/agent/context/context-stub.gobra
new file mode 100644
index 000000000..c8a5339c5
--- /dev/null
+++ b/.verification/agent/context/context-stub.gobra
@@ -0,0 +1,5 @@
+package context
+
+type T interface {
+    pred Mem()
+}
diff --git a/.verification/agent/contracts/contracts-stub.gobra b/.verification/agent/contracts/contracts-stub.gobra
new file mode 100644
index 000000000..963be0a34
--- /dev/null
+++ b/.verification/agent/contracts/contracts-stub.gobra
@@ -0,0 +1,13 @@
+package contracts
+
+type DocumentState struct {
+    nonEmptyStruct int
+}
+
+type SessionDocumentContent struct {
+    nonEmptyStruct int
+}
+
+type DocumentInfo struct {
+    nonEmptyStruct int
+}
diff --git a/.verification/agent/framework/docparser/docparser-stub.gobra b/.verification/agent/framework/docparser/docparser-stub.gobra
new file mode 100644
index 000000000..ba9b17c66
--- /dev/null
+++ b/.verification/agent/framework/docparser/docparser-stub.gobra
@@ -0,0 +1 @@
+package docparser
diff --git a/.verification/agent/iospecs/abs/abs.gobra b/.verification/agent/iospecs/abs/abs.gobra
new file mode 100644
index 000000000..9b9180162
--- /dev/null
+++ b/.verification/agent/iospecs/abs/abs.gobra
@@ -0,0 +1,21 @@
+package abs
+
+import (
+    "big"
+    "bytes"
+    by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+)
+
+ghost
+decreases
+requires acc(bytes.SliceMem(b), _)
+pure func Abs(b []byte) (res by.Bytes)
+/*
+ghost
+pure func AbsString(s string) (res by.Bytes)
+*/
+/*
+ghost
+requires acc(x.Mem(), _) && acc(y.Mem(), _)
+pure func AbsEllipticPk(x, y *big.Int) (res by.Bytes)
+*/
diff --git a/.verification/agent/iospecs/arb/arb.gobra b/.verification/agent/iospecs/arb/arb.gobra
new file mode 100644
index 000000000..39b733d78
--- /dev/null
+++ b/.verification/agent/iospecs/arb/arb.gobra
@@ -0,0 +1,9 @@
+package arb
+
+import (
+    tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+)
+
+// returns a completey unconstraint (and thus arbitrary) term
+ghost
+func GetArbTerm() tm.Term
diff --git a/.verification/agent/iospecs/bytes/bytes.gobra b/.verification/agent/iospecs/bytes/bytes.gobra
new file mode 100644
index 000000000..26c27ea00
--- /dev/null
+++ b/.verification/agent/iospecs/bytes/bytes.gobra
@@ -0,0 +1,77 @@
+package bytes
+
+import (
+    . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+    . "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+)
+
+type Bytes domain {
+    // constructors
+    func pairB(b1, b2 Bytes) Bytes
+    func tuple3B(b1, b2, b3 Bytes) Bytes
+    func tuple4B(b1, b2, b3, b4 Bytes) Bytes
+    func tuple5B(b1, b2, b3, b4, b5 Bytes) Bytes
+    func pkB(sk Bytes) Bytes
+    func aencB(plaintext Bytes, key Bytes) Bytes
+    func sencB(plaintext Bytes, key Bytes) Bytes
+    func generatorB() Bytes
+    func expB(b1, b2 Bytes) Bytes
+    func msgB(string) Bytes
+
+    // destructors
+    func getFirst(b Bytes) Bytes
+    func getSecond(b Bytes) Bytes
+    func getSkB(pk Bytes) Bytes
+    // func getPlaintextB(ciphertext Bytes) Bytes
+    // func getKeyB(ciphertext Bytes) Bytes
+    func adecB(ciphertext, sk Bytes) Bytes
+    func sdecB(ciphertext, sk Bytes) Bytes
+
+    axiom {
+        forall b1, b2 Bytes :: { pairB(b1, b2) } getFirst(pairB(b1, b2)) == b1 && getSecond(pairB(b1, b2)) == b2
+    }
+
+    axiom {
+        forall b1, b2, b3 Bytes :: { tuple3B(b1, b2, b3) } tuple3B(b1, b2, b3) == pairB(b1, pairB(b2, b3))
+    }
+
+    axiom {
+        forall b1, b2, b3, b4 Bytes :: { tuple4B(b1, b2, b3, b4) } tuple4B(b1, b2, b3, b4) == pairB(b1, pairB(b2, pairB(b3, b4)))
+    }
+
+    axiom {
+        forall b1, b2, b3, b4, b5 Bytes :: { tuple5B(b1, b2, b3, b4, b5) } tuple5B(b1, b2, b3, b4, b5) == pairB(b1, pairB(b2, pairB(b3, pairB(b4, b5))))
+    }
+
+    axiom {
+        forall sk Bytes :: { pkB(sk) } getSkB(pkB(sk)) == sk
+    }
+
+    axiom {
+        forall plaintext, sk Bytes :: { aencB(plaintext, pkB(sk)) } adecB(aencB(plaintext, pkB(sk)), sk) == plaintext
+    }
+
+    axiom {
+        forall plaintext, key Bytes :: { sencB(plaintext, key) } sdecB(sencB(plaintext, key), key) == plaintext
+    }
+}
+
+type Gamma domain {
+    func gamma(Term) Bytes
+
+    func oneTerm(Bytes) Term
+
+    axiom { // totality
+        forall b Bytes :: {oneTerm(b)} gamma(oneTerm(b)) == b
+    }
+
+    axiom { // homomorphism
+        (forall t1, t2 Term :: { gamma(pair(t1, t2)) } gamma(pair(t1, t2)) == pairB(gamma(t1), gamma(t2))) &&
+        (forall plaintext, pk Term :: { gamma(aenc(plaintext, pk)) } gamma(aenc(plaintext, pk)) == aencB(gamma(plaintext), gamma(pk))) &&
+        (forall plaintext, key Term :: { gamma(senc(plaintext, key)) } gamma(senc(plaintext, key)) == sencB(gamma(plaintext), gamma(key))) &&
+        (gamma(pubTerm(const_g_pub())) == generatorB()) &&
+        (forall l, r Term :: { gamma(exp(l,r)) } gamma(exp(l,r)) == expB(gamma(l), gamma(r))) &&
+        (forall s string :: { gamma(pubTerm(pub_msg(s))) } gamma(pubTerm(pub_msg(s))) == msgB(s)) &&
+        true
+    }
+}
diff --git a/.verification/agent/iospecs/claim/claim.gobra b/.verification/agent/iospecs/claim/claim.gobra
new file mode 100644
index 000000000..7b3692e00
--- /dev/null
+++ b/.verification/agent/iospecs/claim/claim.gobra
@@ -0,0 +1,133 @@
+package claim
+
+
+
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+
+
+type Claim domain {
+    func AgentStarted() Claim
+    func getAgentStarted(f Claim) seq[Term]
+    axiom  {
+        getAgentStarted(AgentStarted()) == seq[Term]{}
+    }
+
+    func AgentSignResponse(t1 Term, t2 Term, t3 Term, t4 Term) Claim
+    func getAgentSignResponse(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term :: 
+            { AgentSignResponse(t1, t2, t3, t4) } (
+                getAgentSignResponse(AgentSignResponse(t1, t2, t3, t4)) ==
+                seq[Term]{t1, t2, t3, t4})
+    }
+
+    func AgentSecureSessionRequest(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term) Claim
+    func getAgentSecureSessionRequest(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term :: 
+            { AgentSecureSessionRequest(t1, t2, t3, t4, t5) } (
+                getAgentSecureSessionRequest(AgentSecureSessionRequest(t1, t2, t3, t4, t5)) ==
+                seq[Term]{t1, t2, t3, t4, t5})
+    }
+
+    func AgentSecureSessionResponse(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term) Claim
+    func getAgentSecureSessionResponse(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term :: 
+            { AgentSecureSessionResponse(t1, t2, t3, t4, t5, t6) } (
+                getAgentSecureSessionResponse(AgentSecureSessionResponse(t1, t2, t3, t4, t5, t6)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6})
+    }
+
+    func SecretX(t1 Term) Claim
+    func getSecretX(f Claim) Term
+    axiom  {
+        forall t1 Term :: 
+            { SecretX(t1) } (
+                getSecretX(SecretX(t1)) ==
+                t1)
+    }
+
+    func Agent_Finish(t1 Term) Claim
+    func getAgent_Finish(f Claim) Term
+    axiom  {
+        forall t1 Term :: 
+            { Agent_Finish(t1) } (
+                getAgent_Finish(Agent_Finish(t1)) ==
+                t1)
+    }
+
+    func Secret(t1 Term) Claim
+    func getSecret(f Claim) Term
+    axiom  {
+        forall t1 Term :: 
+            { Secret(t1) } (
+                getSecret(Secret(t1)) ==
+                t1)
+    }
+
+    func Commit(t1 Term, t2 Term, t3 Term) Claim
+    func getCommit(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term :: 
+            { Commit(t1, t2, t3) } (
+                getCommit(Commit(t1, t2, t3)) ==
+                seq[Term]{t1, t2, t3})
+    }
+
+    func Running(t1 Term, t2 Term, t3 Term) Claim
+    func getRunning(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term :: 
+            { Running(t1, t2, t3) } (
+                getRunning(Running(t1, t2, t3)) ==
+                seq[Term]{t1, t2, t3})
+    }
+
+    func HonestReader(t1 Term) Claim
+    func getHonestReader(f Claim) Term
+    axiom  {
+        forall t1 Term :: 
+            { HonestReader(t1) } (
+                getHonestReader(HonestReader(t1)) ==
+                t1)
+    }
+
+    func HonestKmsOwner(t1 Term) Claim
+    func getHonestKmsOwner(f Claim) Term
+    axiom  {
+        forall t1 Term :: 
+            { HonestKmsOwner(t1) } (
+                getHonestKmsOwner(HonestKmsOwner(t1)) ==
+                t1)
+    }
+
+    func AgentHandshakeCompleted(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term) Claim
+    func getAgentHandshakeCompleted(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term :: 
+            { AgentHandshakeCompleted(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) } (
+                getAgentHandshakeCompleted(AgentHandshakeCompleted(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10})
+    }
+
+    func AgentRecvLoop(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term) Claim
+    func getAgentRecvLoop(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term :: 
+            { AgentRecvLoop(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) } (
+                getAgentRecvLoop(AgentRecvLoop(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10})
+    }
+
+    func AgentSendLoop(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term) Claim
+    func getAgentSendLoop(f Claim) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term :: 
+            { AgentSendLoop(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) } (
+                getAgentSendLoop(AgentSendLoop(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10})
+    }
+
+
+}
\ No newline at end of file
diff --git a/.verification/agent/iospecs/fact/fact.gobra b/.verification/agent/iospecs/fact/fact.gobra
new file mode 100644
index 000000000..24a5b8e64
--- /dev/null
+++ b/.verification/agent/iospecs/fact/fact.gobra
@@ -0,0 +1,214 @@
+package fact
+
+
+
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fresh"
+
+
+type Fact domain {
+    // tag 0
+    func Setup_Agent(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term) Fact
+    func getSetup_Agent(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term :: 
+            { Setup_Agent(t1, t2, t3, t4, t5, t6, t7) } (
+                getSetup_Agent(Setup_Agent(t1, t2, t3, t4, t5, t6, t7)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7} &&
+                                                     getTag(Setup_Agent(t1, t2, t3, t4, t5, t6, t7)) == 0)
+    }
+
+    // tag 1
+    func FrFact_Agent(t1 Term, t2 Term) Fact
+    func getFrFact_Agent(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term :: 
+            { FrFact_Agent(t1, t2) } (
+                getFrFact_Agent(FrFact_Agent(t1, t2)) ==
+                seq[Term]{t1, t2} &&
+                                 getTag(FrFact_Agent(t1, t2)) == 1)
+    }
+
+    // tag 2
+    func St_Agent_1(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term) Fact
+    func getSt_Agent_1(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term :: 
+            { St_Agent_1(t1, t2, t3, t4, t5, t6, t7, t8) } (
+                getSt_Agent_1(St_Agent_1(t1, t2, t3, t4, t5, t6, t7, t8)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8} &&
+                                                         getTag(St_Agent_1(t1, t2, t3, t4, t5, t6, t7, t8)) == 2)
+    }
+
+    // tag 3
+    func Out_KMS_Agent(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term) Fact
+    func getOut_KMS_Agent(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term :: 
+            { Out_KMS_Agent(t1, t2, t3, t4, t5) } (
+                getOut_KMS_Agent(Out_KMS_Agent(t1, t2, t3, t4, t5)) ==
+                seq[Term]{t1, t2, t3, t4, t5} &&
+                                             getTag(Out_KMS_Agent(t1, t2, t3, t4, t5)) == 3)
+    }
+
+    // tag 4
+    func In_KMS_Agent(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term) Fact
+    func getIn_KMS_Agent(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term :: 
+            { In_KMS_Agent(t1, t2, t3, t4, t5) } (
+                getIn_KMS_Agent(In_KMS_Agent(t1, t2, t3, t4, t5)) ==
+                seq[Term]{t1, t2, t3, t4, t5} &&
+                                             getTag(In_KMS_Agent(t1, t2, t3, t4, t5)) == 4)
+    }
+
+    // tag 5
+    func St_Agent_2(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term) Fact
+    func getSt_Agent_2(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term :: 
+            { St_Agent_2(t1, t2, t3, t4, t5, t6, t7, t8, t9) } (
+                getSt_Agent_2(St_Agent_2(t1, t2, t3, t4, t5, t6, t7, t8, t9)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9} &&
+                                                             getTag(St_Agent_2(t1, t2, t3, t4, t5, t6, t7, t8, t9)) == 5)
+    }
+
+    // tag 6
+    func St_Agent_3(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term) Fact
+    func getSt_Agent_3(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term :: 
+            { St_Agent_3(t1, t2, t3, t4, t5, t6, t7, t8, t9) } (
+                getSt_Agent_3(St_Agent_3(t1, t2, t3, t4, t5, t6, t7, t8, t9)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9} &&
+                                                             getTag(St_Agent_3(t1, t2, t3, t4, t5, t6, t7, t8, t9)) == 6)
+    }
+
+    // tag 7
+    func OutFact_Agent(t1 Term, t2 Term) Fact
+    func getOutFact_Agent(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term :: 
+            { OutFact_Agent(t1, t2) } (
+                getOutFact_Agent(OutFact_Agent(t1, t2)) ==
+                seq[Term]{t1, t2} &&
+                                 getTag(OutFact_Agent(t1, t2)) == 7)
+    }
+
+    // tag 8
+    func InFact_Agent(t1 Term, t2 Term) Fact
+    func getInFact_Agent(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term :: 
+            { InFact_Agent(t1, t2) } (
+                getInFact_Agent(InFact_Agent(t1, t2)) ==
+                seq[Term]{t1, t2} &&
+                                 getTag(InFact_Agent(t1, t2)) == 8)
+    }
+
+    // tag 9
+    func St_Agent_4(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term) Fact
+    func getSt_Agent_4(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term :: 
+            { St_Agent_4(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) } (
+                getSt_Agent_4(St_Agent_4(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12} &&
+                                                                            getTag(St_Agent_4(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) == 9)
+    }
+
+    // tag 10
+    func St_Agent_5(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term) Fact
+    func getSt_Agent_5(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term :: 
+            { St_Agent_5(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) } (
+                getSt_Agent_5(St_Agent_5(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12} &&
+                                                                            getTag(St_Agent_5(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) == 10)
+    }
+
+    // tag 11
+    func St_Agent_6(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term) Fact
+    func getSt_Agent_6(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term :: 
+            { St_Agent_6(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) } (
+                getSt_Agent_6(St_Agent_6(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12} &&
+                                                                            getTag(St_Agent_6(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) == 11)
+    }
+
+    // tag 12
+    func St_Agent_7(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term) Fact
+    func getSt_Agent_7(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term :: 
+            { St_Agent_7(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) } (
+                getSt_Agent_7(St_Agent_7(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12} &&
+                                                                            getTag(St_Agent_7(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)) == 12)
+    }
+
+    // tag 13
+    func St_Agent_8(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term, t13 Term) Fact
+    func getSt_Agent_8(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term, t13 Term :: 
+            { St_Agent_8(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) } (
+                getSt_Agent_8(St_Agent_8(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13} &&
+                                                                                 getTag(St_Agent_8(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)) == 13)
+    }
+
+    // tag 14
+    func St_Agent_9(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term, t13 Term) Fact
+    func getSt_Agent_9(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term, t13 Term :: 
+            { St_Agent_9(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) } (
+                getSt_Agent_9(St_Agent_9(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13} &&
+                                                                                 getTag(St_Agent_9(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)) == 14)
+    }
+
+    // tag 15
+    func St_Agent_10(t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term, t13 Term) Fact
+    func getSt_Agent_10(f Fact) seq[Term]
+    axiom  {
+        forall t1 Term, t2 Term, t3 Term, t4 Term, t5 Term, t6 Term, t7 Term, t8 Term, t9 Term, t10 Term, t11 Term, t12 Term, t13 Term :: 
+            { St_Agent_10(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) } (
+                getSt_Agent_10(St_Agent_10(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)) ==
+                seq[Term]{t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13} &&
+                                                                                 getTag(St_Agent_10(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)) == 15)
+    }
+
+    // each fact has a unique tag:
+    func getTag(f Fact) int
+
+    func persistent(f Fact) bool
+
+}
+ghost
+// returns a multiset containing just the persistent facts of l all with multiplicity 1
+ensures forall f Fact :: { f # result } (f # result) == (persistent(f) && (f # l) > 0 ? 1 : 0)
+pure func persistentFacts(l mset[Fact]) (result mset[Fact])
+
+ghost
+// returns a multiset containing just the non-persistent facts of l while retaining their multiplicity
+ensures forall f Fact :: { f # result } (f # result) == (persistent(f) ? 0 : (f # l))
+pure func linearFacts(l mset[Fact]) (result mset[Fact])
+
+ghost
+ensures res == (linearFacts(l) subset s && persistentFacts(l) subset s)
+pure func M(l mset[Fact], s mset[Fact]) (res bool) {
+    // non-persistent facts
+    return linearFacts(l) subset s &&
+        // persistent facts
+        persistentFacts(l) subset s
+}
+
+ghost
+ensures result == s setminus linearFacts(l) union r
+pure func U(l mset[Fact], r mset[Fact], s mset[Fact]) (result mset[Fact])
\ No newline at end of file
diff --git a/.verification/agent/iospecs/fresh/fresh.gobra b/.verification/agent/iospecs/fresh/fresh.gobra
new file mode 100644
index 000000000..1fdc00c54
--- /dev/null
+++ b/.verification/agent/iospecs/fresh/fresh.gobra
@@ -0,0 +1,14 @@
+package fresh
+
+
+
+
+
+// fresh encoding ---------------
+type Fresh domain {
+    // TODO!: Add base constructors as uninterpreted functions
+    // Example:
+    func fr_msg(string) Fresh
+    func fr_integer64(uint64) Fresh
+}
+
diff --git a/.verification/agent/iospecs/iospec/Agent.gobra b/.verification/agent/iospecs/iospec/Agent.gobra
new file mode 100644
index 000000000..883176c3f
--- /dev/null
+++ b/.verification/agent/iospecs/iospec/Agent.gobra
@@ -0,0 +1,250 @@
+package iospec
+
+
+
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/claim"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fact"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fresh"
+
+
+pred P_Agent(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    phiR_Agent_0(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_1(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_2(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_3(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_4(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_5(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_6(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_7(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_8(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_9(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_10(tami_p, tami_rid, tami_s) &&
+    phiR_Agent_11(tami_p, tami_rid, tami_s) &&
+    phiRG_Agent_12(tami_p, tami_rid, tami_s) &&
+    phiRG_Agent_13(tami_p, tami_rid, tami_s) &&
+    phiRF_Agent_14(tami_p, tami_rid, tami_s) &&
+    phiRF_Agent_15(tami_p, tami_rid, tami_s) &&
+    phiRF_Agent_16(tami_p, tami_rid, tami_s) &&
+    phiRF_Agent_17(tami_p, tami_rid, tami_s)
+}
+pred phiR_Agent_0(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_SendSignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            Setup_Agent(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk),
+                            FrFact_Agent(RunId, x)} &&
+             tami_ap == mset[Claim] {
+                            AgentStarted()} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_1(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x),
+// TODO adapt Tamarin model to nest message according to this:
+                            Out_KMS_Agent(RunId, AgentId, KMSId, RunId, pair(pubTerm(const_SignRequest_pub()), pair(AgentLtKeyId, pair(exp(pubTerm(const_g_pub()), x), pair(ReaderId, ClientId)))))}) ==>
+            (e_Agent_SendSignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_SendSignRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_1(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_RecvSignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_1(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x),
+                            In_KMS_Agent(RunId, KMSId, AgentId, RunId, pair(pubTerm(const_SignResponse_pub()), SigX))} &&
+             tami_ap == mset[Claim] {
+                            AgentSignResponse(KMSId, AgentId, RunId, pair(pubTerm(const_SignResponse_pub()), SigX))} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_2(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX)}) ==>
+            (e_Agent_RecvSignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_RecvSignResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_2(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_SendSecureSessionRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_2(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX)} &&
+             tami_ap == mset[Claim] {
+                            AgentSecureSessionRequest(AgentId, ClientId, exp(pubTerm(const_g_pub()), x), SigX, AgentLtKeyId)} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_3(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX),
+                            OutFact_Agent(RunId, pair(pubTerm(const_SecureSessionRequest_pub()), pair(exp(pubTerm(const_g_pub()), x), pair(SigX, pair(AgentLtKeyId, ReaderId))))),
+                            OutFact_Agent(RunId, pair(pubTerm(const_Log_pub()), pair(pubTerm(const_SecureSessionRequest_pub()), pair(exp(pubTerm(const_g_pub()), x), pair(SigX, pair(AgentLtKeyId, ReaderId))))))}) ==>
+            (e_Agent_SendSecureSessionRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_SendSecureSessionRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_3(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, z Term, SigY Term, ClientLtKeyId Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_RecvSecureSessionResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, z, SigY, ClientLtKeyId, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_3(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX),
+                            InFact_Agent(RunId, pair(pubTerm(const_SecureSessionResponse_pub()), pair(exp(pubTerm(const_g_pub()), z), pair(SigY, pair(ClientLtKeyId, hash(exp(exp(pubTerm(const_g_pub()), z), x)))))))} &&
+             tami_ap == mset[Claim] {
+                            AgentSecureSessionResponse(ClientId, AgentId, exp(pubTerm(const_g_pub()), z), SigY, ClientLtKeyId, hash(exp(exp(pubTerm(const_g_pub()), z), x)))} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_4(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, exp(pubTerm(const_g_pub()), z), SigY)}) ==>
+            (e_Agent_RecvSecureSessionResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, z, SigY, ClientLtKeyId, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_RecvSecureSessionResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, z, SigY, ClientLtKeyId, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_4(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_SendVerifyRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_4(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY)} &&
+             tami_ap == mset[Claim] {
+                        } &&
+             tami_rp == mset[Fact] {
+                            St_Agent_5(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY),
+                            Out_KMS_Agent(RunId, AgentId, KMSId, RunId, pair(pubTerm(const_VerifyRequest_pub()), pair(ClientLtKeyId, pair(Y, pair(SigY, AgentId)))))}) ==>
+            (e_Agent_SendVerifyRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_SendVerifyRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_5(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_RecvVerifyResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_5(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY),
+                            In_KMS_Agent(RunId, KMSId, AgentId, RunId, pubTerm(const_VerifyResponse_pub()))} &&
+             tami_ap == mset[Claim] {
+                            SecretX(x)} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_6(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY)}) ==>
+            (e_Agent_RecvVerifyResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_RecvVerifyResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_6(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_SendSessionKeySignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_6(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY)} &&
+             tami_ap == mset[Claim] {
+                        } &&
+             tami_rp == mset[Fact] {
+                            St_Agent_7(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY),
+                            Out_KMS_Agent(RunId, AgentId, KMSId, RunId, pair(pubTerm(const_SignRequest_pub()), pair(AgentLtKeyId, pair(aenc(pair(kdf1(exp(Y, x)), kdf2(exp(Y, x))), logPk), ClientId))))}) ==>
+            (e_Agent_SendSessionKeySignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_SendSessionKeySignRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_7(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_RecvSessionKeySignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_7(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY),
+                            In_KMS_Agent(RunId, KMSId, AgentId, RunId, pair(pubTerm(const_SignResponse_pub()), SigSessionKey))} &&
+             tami_ap == mset[Claim] {
+                        } &&
+             tami_rp == mset[Fact] {
+                            St_Agent_8(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey)}) ==>
+            (e_Agent_RecvSessionKeySignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_RecvSessionKeySignResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_8(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_SendEncryptedSessionKey(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_8(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey)} &&
+             tami_ap == mset[Claim] {
+                        } &&
+             tami_rp == mset[Fact] {
+                            St_Agent_9(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+                            OutFact_Agent(RunId, pair(pubTerm(const_EncryptedSessionKey_pub()), pair(aenc(pair(kdf1(exp(Y, x)), kdf2(exp(Y, x))), logPk), pair(SigSessionKey, pair(AgentLtKeyId, ClientId)))))}) ==>
+            (e_Agent_SendEncryptedSessionKey(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_SendEncryptedSessionKey_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_9(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, payload Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_SendHandshakeComplete(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, payload, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_9(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+                            InFact_Agent(RunId, payload)} &&
+             tami_ap == mset[Claim] {
+                            Agent_Finish(AgentId),
+                            Secret(pair(kdf1(exp(Y, x)), kdf2(exp(Y, x)))),
+                            Commit(pubTerm(const_Agent_pub()), pubTerm(const_Client_pub()), pair(AgentId, pair(ClientId, pair(kdf1(exp(Y, x)), kdf2(exp(Y, x)))))),
+                            Running(pubTerm(const_Agent_pub()), pubTerm(const_Client_pub()), pair(AgentId, pair(ClientId, pair(kdf1(exp(Y, x)), kdf2(exp(Y, x)))))),
+                            HonestReader(ReaderId),
+                            HonestKmsOwner(AgentId),
+                            HonestKmsOwner(ClientId),
+                            AgentHandshakeCompleted(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y)} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_10(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+                            OutFact_Agent(RunId, pair(pubTerm(const_HandshakeComplete_pub()), senc(pair(pubTerm(const_HandshakeCompletePayload_pub()), payload), kdf1(exp(Y, x))))),
+                            OutFact_Agent(RunId, pair(pubTerm(const_Log_pub()), pair(pubTerm(const_HandshakeComplete_pub()), senc(pair(pubTerm(const_HandshakeCompletePayload_pub()), payload), kdf1(exp(Y, x))))))}) ==>
+            (e_Agent_SendHandshakeComplete(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, payload, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_SendHandshakeComplete_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, payload, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_10(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, msg Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_ReceiveMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_10(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+                            InFact_Agent(RunId, pair(pubTerm(const_Message_pub()), senc(msg, kdf2(exp(Y, x)))))} &&
+             tami_ap == mset[Claim] {
+                            AgentRecvLoop(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y)} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_10(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey)}) ==>
+            (e_Agent_ReceiveMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_ReceiveMessages_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiR_Agent_11(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, msg Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact] :: 
+        { e_Agent_SendMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp) } (
+            (M(tami_lp, tami_s) &&
+             tami_lp == mset[Fact] {
+                            St_Agent_10(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+                            InFact_Agent(RunId, msg)} &&
+             tami_ap == mset[Claim] {
+                            AgentSendLoop(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y)} &&
+             tami_rp == mset[Fact] {
+                            St_Agent_10(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+                            OutFact_Agent(RunId, pair(pubTerm(const_Message_pub()), senc(msg, kdf1(exp(Y, x))))),
+                            OutFact_Agent(RunId, pair(pubTerm(const_Log_pub()), pair(pubTerm(const_Message_pub()), senc(msg, kdf1(exp(Y, x))))))}) ==>
+            (e_Agent_SendMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp) && 
+             P_Agent(get_e_Agent_SendMessages_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp), tami_rid, U(tami_lp, tami_rp, tami_s))))
+}
+pred phiRG_Agent_12(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall new_x Term, new_x_1 Term, new_x_2 Term, new_x_3 Term :: 
+        { e_Out_KMS(tami_p, tami_rid, new_x, new_x_1, new_x_2, new_x_3) }{ Out_KMS_Agent(tami_rid, new_x, new_x_1, new_x_2, new_x_3) } (
+            ((Out_KMS_Agent(tami_rid, new_x, new_x_1, new_x_2, new_x_3) # tami_s) > 0) ==>
+            (e_Out_KMS(tami_p, tami_rid, new_x, new_x_1, new_x_2, new_x_3) && 
+             P_Agent(get_e_Out_KMS_placeDst(tami_p, tami_rid, new_x, new_x_1, new_x_2, new_x_3), tami_rid, tami_s setminus mset[Fact] {
+                                                                                                                               Out_KMS_Agent(tami_rid, new_x, new_x_1, new_x_2, new_x_3)})))
+}
+pred phiRG_Agent_13(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    forall new_x Term :: 
+        { e_OutFact(tami_p, tami_rid, new_x) }{ OutFact_Agent(tami_rid, new_x) } (
+            ((OutFact_Agent(tami_rid, new_x) # tami_s) > 0) ==>
+            (e_OutFact(tami_p, tami_rid, new_x) && 
+             P_Agent(get_e_OutFact_placeDst(tami_p, tami_rid, new_x), tami_rid, tami_s setminus mset[Fact] {
+                                                                                                    OutFact_Agent(tami_rid, new_x)})))
+}
+pred phiRF_Agent_14(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    e_FrFact(tami_p, tami_rid) && 
+    P_Agent(get_e_FrFact_placeDst(tami_p, tami_rid), tami_rid, tami_s union mset[Fact] {
+                                                                                FrFact_Agent(tami_rid, get_e_FrFact_r1(tami_p, tami_rid))})
+}
+pred phiRF_Agent_15(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    e_In_KMS(tami_p, tami_rid) && 
+    P_Agent(get_e_In_KMS_placeDst(tami_p, tami_rid), tami_rid, tami_s union mset[Fact] {
+                                                                                In_KMS_Agent(tami_rid, get_e_In_KMS_r1(tami_p, tami_rid), get_e_In_KMS_r2(tami_p, tami_rid), get_e_In_KMS_r3(tami_p, tami_rid), get_e_In_KMS_r4(tami_p, tami_rid))})
+}
+pred phiRF_Agent_16(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    e_InFact(tami_p, tami_rid) && 
+    P_Agent(get_e_InFact_placeDst(tami_p, tami_rid), tami_rid, tami_s union mset[Fact] {
+                                                                                InFact_Agent(tami_rid, get_e_InFact_r1(tami_p, tami_rid))})
+}
+pred phiRF_Agent_17(tami_p Place, tami_rid Term, ghost tami_s mset[Fact]) {
+    e_Setup_Agent(tami_p, tami_rid) && 
+    P_Agent(get_e_Setup_Agent_placeDst(tami_p, tami_rid), tami_rid, tami_s union mset[Fact] {
+                                                                                     Setup_Agent(tami_rid, get_e_Setup_Agent_r1(tami_p, tami_rid), get_e_Setup_Agent_r2(tami_p, tami_rid), get_e_Setup_Agent_r3(tami_p, tami_rid), get_e_Setup_Agent_r4(tami_p, tami_rid), get_e_Setup_Agent_r5(tami_p, tami_rid), get_e_Setup_Agent_r6(tami_p, tami_rid))})
+}
\ No newline at end of file
diff --git a/.verification/agent/iospecs/iospec/permissions_Agent_internal.gobra b/.verification/agent/iospecs/iospec/permissions_Agent_internal.gobra
new file mode 100644
index 000000000..4d1956193
--- /dev/null
+++ b/.verification/agent/iospecs/iospec/permissions_Agent_internal.gobra
@@ -0,0 +1,167 @@
+package iospec
+
+
+
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/claim"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fact"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fresh"
+
+
+// permission e_Agent_SendSignRequest
+pred e_Agent_SendSignRequest(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_SendSignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_SendSignRequest_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_SendSignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_SendSignRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_SendSignRequest(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_RecvSignResponse
+pred e_Agent_RecvSignResponse(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_RecvSignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_RecvSignResponse_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_RecvSignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_RecvSignResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_RecvSignResponse(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_SendSecureSessionRequest
+pred e_Agent_SendSecureSessionRequest(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_SendSecureSessionRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_SendSecureSessionRequest_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_SendSecureSessionRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_SendSecureSessionRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_SendSecureSessionRequest(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_RecvSecureSessionResponse
+pred e_Agent_RecvSecureSessionResponse(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost z Term, ghost SigY Term, ghost ClientLtKeyId Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_RecvSecureSessionResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, z, SigY, ClientLtKeyId, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_RecvSecureSessionResponse_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, z Term, SigY Term, ClientLtKeyId Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_RecvSecureSessionResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, z, SigY, ClientLtKeyId, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_RecvSecureSessionResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, z, SigY, ClientLtKeyId, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_RecvSecureSessionResponse(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, z Term, SigY Term, ClientLtKeyId Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_SendVerifyRequest
+pred e_Agent_SendVerifyRequest(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_SendVerifyRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_SendVerifyRequest_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_SendVerifyRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_SendVerifyRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_SendVerifyRequest(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_RecvVerifyResponse
+pred e_Agent_RecvVerifyResponse(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_RecvVerifyResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_RecvVerifyResponse_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_RecvVerifyResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_RecvVerifyResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_RecvVerifyResponse(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_SendSessionKeySignRequest
+pred e_Agent_SendSessionKeySignRequest(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_SendSessionKeySignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_SendSessionKeySignRequest_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_SendSessionKeySignRequest(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_SendSessionKeySignRequest_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_SendSessionKeySignRequest(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_RecvSessionKeySignResponse
+pred e_Agent_RecvSessionKeySignResponse(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost SigSessionKey Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_RecvSessionKeySignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_RecvSessionKeySignResponse_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_RecvSessionKeySignResponse(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_RecvSessionKeySignResponse_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_RecvSessionKeySignResponse(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_SendEncryptedSessionKey
+pred e_Agent_SendEncryptedSessionKey(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost SigSessionKey Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_SendEncryptedSessionKey(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_SendEncryptedSessionKey_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_SendEncryptedSessionKey(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_SendEncryptedSessionKey_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_SendEncryptedSessionKey(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_SendHandshakeComplete
+pred e_Agent_SendHandshakeComplete(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost SigSessionKey Term, ghost payload Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_SendHandshakeComplete(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, payload, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_SendHandshakeComplete_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, payload Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_SendHandshakeComplete(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, payload, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_SendHandshakeComplete_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, payload, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_SendHandshakeComplete(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, payload Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_ReceiveMessages
+pred e_Agent_ReceiveMessages(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost SigSessionKey Term, ghost msg Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_ReceiveMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_ReceiveMessages_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, msg Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_ReceiveMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_ReceiveMessages_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_ReceiveMessages(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, msg Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
+
+// permission e_Agent_SendMessages
+pred e_Agent_SendMessages(ghost tami_p Place, ghost RunId Term, ghost AgentId Term, ghost KMSId Term, ghost ClientId Term, ghost ReaderId Term, ghost AgentLtKeyId Term, ghost logPk Term, ghost x Term, ghost SigX Term, ghost ClientLtKeyId Term, ghost Y Term, ghost SigY Term, ghost SigSessionKey Term, ghost msg Term, ghost tami_lp mset[Fact], ghost tami_ap mset[Claim], ghost tami_rp mset[Fact])
+
+ghost
+requires e_Agent_SendMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp)
+pure func get_e_Agent_SendMessages_placeDst(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, msg Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (placeDst Place)
+
+ghost
+requires token(tami_p) && e_Agent_SendMessages(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp)
+ensures token(tami_pp) && tami_pp == old(get_e_Agent_SendMessages_placeDst(tami_p, RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, msg, tami_lp, tami_ap, tami_rp))
+func internBIO_e_Agent_SendMessages(tami_p Place, RunId Term, AgentId Term, KMSId Term, ClientId Term, ReaderId Term, AgentLtKeyId Term, logPk Term, x Term, SigX Term, ClientLtKeyId Term, Y Term, SigY Term, SigSessionKey Term, msg Term, tami_lp mset[Fact], tami_ap mset[Claim], tami_rp mset[Fact]) (tami_pp Place)
+
diff --git a/.verification/agent/iospecs/iospec/permissions_in.gobra b/.verification/agent/iospecs/iospec/permissions_in.gobra
new file mode 100644
index 000000000..58ad53324
--- /dev/null
+++ b/.verification/agent/iospecs/iospec/permissions_in.gobra
@@ -0,0 +1,91 @@
+package iospec
+
+
+
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/claim"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fact"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fresh"
+
+
+// permission e_FrFact
+pred e_FrFact(ghost tami_p Place, ghost tami_rid Term)
+
+ghost
+requires e_FrFact(tami_p, tami_rid)
+pure func get_e_FrFact_r1(tami_p Place, tami_rid Term) (r1 Term)
+
+ghost
+requires e_FrFact(tami_p, tami_rid)
+pure func get_e_FrFact_placeDst(tami_p Place, tami_rid Term) (placeDst Place)
+
+
+// permission e_In_KMS
+pred e_In_KMS(ghost tami_p Place, ghost tami_rid Term)
+
+ghost
+requires e_In_KMS(tami_p, tami_rid)
+pure func get_e_In_KMS_r1(tami_p Place, tami_rid Term) (r1 Term)
+
+ghost
+requires e_In_KMS(tami_p, tami_rid)
+pure func get_e_In_KMS_r2(tami_p Place, tami_rid Term) (r2 Term)
+
+ghost
+requires e_In_KMS(tami_p, tami_rid)
+pure func get_e_In_KMS_r3(tami_p Place, tami_rid Term) (r3 Term)
+
+ghost
+requires e_In_KMS(tami_p, tami_rid)
+pure func get_e_In_KMS_r4(tami_p Place, tami_rid Term) (r4 Term)
+
+ghost
+requires e_In_KMS(tami_p, tami_rid)
+pure func get_e_In_KMS_placeDst(tami_p Place, tami_rid Term) (placeDst Place)
+
+
+// permission e_InFact
+pred e_InFact(ghost tami_p Place, ghost tami_rid Term)
+
+ghost
+requires e_InFact(tami_p, tami_rid)
+pure func get_e_InFact_r1(tami_p Place, tami_rid Term) (r1 Term)
+
+ghost
+requires e_InFact(tami_p, tami_rid)
+pure func get_e_InFact_placeDst(tami_p Place, tami_rid Term) (placeDst Place)
+
+
+// permission e_Setup_Agent
+pred e_Setup_Agent(ghost tami_p Place, ghost tami_rid Term)
+
+ghost
+requires e_Setup_Agent(tami_p, tami_rid)
+pure func get_e_Setup_Agent_r1(tami_p Place, tami_rid Term) (r1 Term)
+
+ghost
+requires e_Setup_Agent(tami_p, tami_rid)
+pure func get_e_Setup_Agent_r2(tami_p Place, tami_rid Term) (r2 Term)
+
+ghost
+requires e_Setup_Agent(tami_p, tami_rid)
+pure func get_e_Setup_Agent_r3(tami_p Place, tami_rid Term) (r3 Term)
+
+ghost
+requires e_Setup_Agent(tami_p, tami_rid)
+pure func get_e_Setup_Agent_r4(tami_p Place, tami_rid Term) (r4 Term)
+
+ghost
+requires e_Setup_Agent(tami_p, tami_rid)
+pure func get_e_Setup_Agent_r5(tami_p Place, tami_rid Term) (r5 Term)
+
+ghost
+requires e_Setup_Agent(tami_p, tami_rid)
+pure func get_e_Setup_Agent_r6(tami_p Place, tami_rid Term) (r6 Term)
+
+ghost
+requires e_Setup_Agent(tami_p, tami_rid)
+pure func get_e_Setup_Agent_placeDst(tami_p Place, tami_rid Term) (placeDst Place)
+
diff --git a/.verification/agent/iospecs/iospec/permissions_out.gobra b/.verification/agent/iospecs/iospec/permissions_out.gobra
new file mode 100644
index 000000000..a0cdce468
--- /dev/null
+++ b/.verification/agent/iospecs/iospec/permissions_out.gobra
@@ -0,0 +1,27 @@
+package iospec
+
+
+
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/claim"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fact"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fresh"
+
+
+// permission e_Out_KMS
+pred e_Out_KMS(ghost tami_p Place, ghost tami_rid Term, ghost new_x Term, ghost new_x_1 Term, ghost new_x_2 Term, ghost new_x_3 Term)
+
+ghost
+requires e_Out_KMS(tami_p, tami_rid, new_x, new_x_1, new_x_2, new_x_3)
+pure func get_e_Out_KMS_placeDst(tami_p Place, tami_rid Term, new_x Term, new_x_1 Term, new_x_2 Term, new_x_3 Term) (placeDst Place)
+
+
+// permission e_OutFact
+pred e_OutFact(ghost tami_p Place, ghost tami_rid Term, ghost new_x Term)
+
+ghost
+requires e_OutFact(tami_p, tami_rid, new_x)
+pure func get_e_OutFact_placeDst(tami_p Place, tami_rid Term, new_x Term) (placeDst Place)
+
diff --git a/.verification/agent/iospecs/place/place.gobra b/.verification/agent/iospecs/place/place.gobra
new file mode 100644
index 000000000..42c733b58
--- /dev/null
+++ b/.verification/agent/iospecs/place/place.gobra
@@ -0,0 +1,12 @@
+package place
+
+
+
+
+
+// place encoding ---------------
+type Place domain {
+    func place(p int) Place
+}
+pred token(t Place)
+
diff --git a/.verification/agent/iospecs/pub/pub.gobra b/.verification/agent/iospecs/pub/pub.gobra
new file mode 100644
index 000000000..24b240701
--- /dev/null
+++ b/.verification/agent/iospecs/pub/pub.gobra
@@ -0,0 +1,42 @@
+package pub
+
+
+
+
+
+// pub encoding ---------------
+type Pub domain {
+    func const_SignRequest_pub() Pub
+
+    func const_g_pub() Pub
+
+    func const_SignResponse_pub() Pub
+
+    func const_SecureSessionRequest_pub() Pub
+
+    func const_Log_pub() Pub
+
+    func const_SecureSessionResponse_pub() Pub
+
+    func const_VerifyRequest_pub() Pub
+
+    func const_VerifyResponse_pub() Pub
+
+    func const_EncryptedSessionKey_pub() Pub
+
+    func const_Agent_pub() Pub
+
+    func const_Client_pub() Pub
+
+    func const_HandshakeComplete_pub() Pub
+
+    func const_HandshakeCompletePayload_pub() Pub
+
+    func const_Message_pub() Pub
+
+    // TODO!: Add base constructors as uninterpreted functions
+    // Example:
+    func pub_msg(string) Pub
+    func pub_integer64(uint64) Pub
+}
+
diff --git a/.verification/agent/iospecs/term/term.gobra b/.verification/agent/iospecs/term/term.gobra
new file mode 100644
index 000000000..9737d5693
--- /dev/null
+++ b/.verification/agent/iospecs/term/term.gobra
@@ -0,0 +1,156 @@
+package term
+
+
+
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+import . "github.com/aws/amazon-ssm-agent/agent/iospecs/fresh"
+
+
+type Term domain {
+    func freshTerm(f Fresh) Term
+    func getFreshTerm(t Term) Fresh
+    axiom  {
+        forall f Fresh :: 
+            { freshTerm(f) } (
+                getFreshTerm(freshTerm(f)) == f)
+    }
+    func pubTerm(p Pub) Term
+    func getPubTerm(t Term) Pub
+    axiom  {
+        forall p Pub :: 
+            { pubTerm(p) } (
+                getPubTerm(pubTerm(p)) == p)
+    }
+
+    func adec(t1 Term, t2 Term) Term
+    func aenc(t1 Term, t2 Term) Term
+    func exp(t1 Term, t2 Term) Term
+    func fst(t1 Term) Term
+    func hash(t1 Term) Term
+    func inv(t1 Term) Term
+    func kdf1(t1 Term) Term
+    func kdf2(t1 Term) Term
+    func one() Term
+    func pair(t1 Term, t2 Term) Term
+    func pk(t1 Term) Term
+    func sdec(t1 Term, t2 Term) Term
+    func senc(t1 Term, t2 Term) Term
+    func sign(t1 Term, t2 Term) Term
+    func snd(t1 Term) Term
+    func ok() Term
+    func verify(t1 Term, t2 Term, t3 Term) Term
+    func Mult(x Term, y Term) Term
+    // associativity
+    axiom  {
+        forall x_1, x_2, x_3 Term :: 
+            { Mult(x_1, Mult(x_2, x_3)) } (
+                Mult(x_1, Mult(x_2, x_3)) == Mult(Mult(x_1, x_2), x_3))
+    }
+    // commutativity
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { Mult(x_1, x_2) } (
+                Mult(x_1, x_2) == Mult(x_2, x_1))
+    }
+    
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { adec(aenc(x_1, pk(x_2)), x_2) } (
+                adec(aenc(x_1, pk(x_2)), x_2) == x_1)
+    }
+
+    axiom  {
+        forall x_1 Term :: 
+            { exp(x_1, one()) } (
+                exp(x_1, one()) == x_1)
+    }
+
+    axiom  {
+        forall x_1, x_2, x_3 Term :: 
+            { exp(exp(x_1, x_2), x_3) } (
+                exp(exp(x_1, x_2), x_3) == exp(x_1, Mult(x_2, x_3)))
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { fst(pair(x_1, x_2)) } (
+                fst(pair(x_1, x_2)) == x_1)
+    }
+
+    axiom  {
+        forall x_1 Term :: 
+            { inv(inv(x_1)) } (
+                inv(inv(x_1)) == x_1)
+    }
+
+    axiom  {
+        inv(one()) == one()
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { inv(Mult(x_2, inv(x_1))) } (
+                inv(Mult(x_2, inv(x_1))) == Mult(x_1, inv(x_2)))
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { sdec(senc(x_1, x_2), x_2) } (
+                sdec(senc(x_1, x_2), x_2) == x_1)
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { snd(pair(x_1, x_2)) } (
+                snd(pair(x_1, x_2)) == x_2)
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { verify(sign(x_1, x_2), x_1, pk(x_2)) } (
+                verify(sign(x_1, x_2), x_1, pk(x_2)) == ok())
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { Mult(x_1, Mult(x_2, inv(x_1))) } (
+                Mult(x_1, Mult(x_2, inv(x_1))) == x_2)
+    }
+
+    axiom  {
+        forall x_1 Term :: 
+            { Mult(x_1, inv(x_1)) } (
+                Mult(x_1, inv(x_1)) == one())
+    }
+
+    axiom  {
+        forall x_1 Term :: 
+            { Mult(x_1, one()) } (
+                Mult(x_1, one()) == x_1)
+    }
+
+    axiom  {
+        forall x_1, x_2, x_3 Term :: 
+            { Mult(x_2, Mult(x_3, inv(Mult(x_1, x_2)))) } (
+                Mult(x_2, Mult(x_3, inv(Mult(x_1, x_2)))) == Mult(x_3, inv(x_1)))
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { Mult(x_2, inv(Mult(x_1, x_2))) } (
+                Mult(x_2, inv(Mult(x_1, x_2))) == inv(x_1))
+    }
+
+    axiom  {
+        forall x_1, x_2, x_3 Term :: 
+            { Mult(x_3, Mult(inv(x_1), inv(x_2))) } (
+                Mult(x_3, Mult(inv(x_1), inv(x_2))) == Mult(x_3, inv(Mult(x_1, x_2))))
+    }
+
+    axiom  {
+        forall x_1, x_2 Term :: 
+            { Mult(inv(x_1), inv(x_2)) } (
+                Mult(inv(x_1), inv(x_2)) == inv(Mult(x_1, x_2)))
+    }
+}
\ No newline at end of file
diff --git a/.verification/agent/jsonutil/jsonutil-stub.gobra b/.verification/agent/jsonutil/jsonutil-stub.gobra
new file mode 100644
index 000000000..5aa90fd38
--- /dev/null
+++ b/.verification/agent/jsonutil/jsonutil-stub.gobra
@@ -0,0 +1 @@
+package jsonutil
diff --git a/.verification/agent/log/log-stub.gobra b/.verification/agent/log/log-stub.gobra
new file mode 100644
index 000000000..8cb2c07c6
--- /dev/null
+++ b/.verification/agent/log/log-stub.gobra
@@ -0,0 +1,5 @@
+package log
+
+type T interface {
+    pred Mem()
+}
diff --git a/.verification/agent/messageservice/contracts/contracts-stub.gobra b/.verification/agent/messageservice/contracts/contracts-stub.gobra
new file mode 100644
index 000000000..947d8ef40
--- /dev/null
+++ b/.verification/agent/messageservice/contracts/contracts-stub.gobra
@@ -0,0 +1,5 @@
+package contracts
+
+type InstanceMessage struct {
+    nonEmptyStruct int
+}
diff --git a/.verification/agent/messageservice/utils/utils-stub.gobra b/.verification/agent/messageservice/utils/utils-stub.gobra
new file mode 100644
index 000000000..d4b585bf7
--- /dev/null
+++ b/.verification/agent/messageservice/utils/utils-stub.gobra
@@ -0,0 +1 @@
+package utils
diff --git a/.verification/agent/session/crypto/crypto-stub.gobra b/.verification/agent/session/crypto/crypto-stub.gobra
new file mode 100644
index 000000000..f6b45f1f3
--- /dev/null
+++ b/.verification/agent/session/crypto/crypto-stub.gobra
@@ -0,0 +1,117 @@
+package crypto
+
+import (
+    "bytes"
+    "fmt"
+    ctx "github.com/aws/amazon-ssm-agent/agent/context"
+    logger "github.com/aws/amazon-ssm-agent/agent/log"
+    "github.com/aws/aws-sdk-go/service/kms"
+    "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+    by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+	ft "github.com/aws/amazon-ssm-agent/agent/iospecs/fact"
+	io "github.com/aws/amazon-ssm-agent/agent/iospecs/iospec"
+	pl "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+    . "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+	. "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+)
+/*
+type IBlockCipher interface {
+
+    pred Mem()
+
+    requires noPerm < p
+    preserves acc(Mem(), p) && acc(bytes.SliceMem(plainText), p)
+    ensures err == nil ==> bytes.SliceMem(cipherText)
+    ensures err != nil ==> err.ErrorMem()
+    EncryptWithAESGCM(plainText []byte, ghost p perm) (cipherText []byte, err error)
+    
+    requires noPerm < p
+    preserves acc(Mem(), p) && acc(bytes.SliceMem(cipherText), p)
+    ensures err == nil ==> bytes.SliceMem(plainText)
+    ensures err != nil ==> err.ErrorMem()
+    DecryptWithAESGCM(cipherText []byte, ghost p perm) (plainText []byte, err error)
+}
+*/
+type KMSService struct {
+    nonEmptyStruct int
+}
+
+pred (service *KMSService) Mem()
+
+requires acc(context.Mem(), _)
+ensures err == nil ==> service.Mem()
+ensures err != nil ==> err.ErrorMem()
+func NewKMSService(context ctx.T) (service *KMSService, err error)
+
+preserves kmsService.Mem()
+ensures err == nil ==> meta.Mem()
+ensures err != nil ==> err.ErrorMem()
+func (kmsService *KMSService) CreateKeyAssymetric() (meta *kms.KeyMetadata, err error)
+
+requires noPerm < p
+requires kmsService.Mem() && acc(bytes.SliceMem(message), p)
+requires m == pair(pubTerm(const_SignRequest_pub()), pair(pubTerm(pub_msg(keyID)), messageT))
+requires pl.token(t) && io.e_Out_KMS(t, rid, agentId, kmsId, rid, m) && by.gamma(messageT) == abs.Abs(message)
+requires let t1 := io.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m) in (
+    io.e_In_KMS(t1, rid))
+ensures  kmsService.Mem() && acc(bytes.SliceMem(message), p)
+ensures  err == nil ==> bytes.SliceMem(signature) && by.gamma(signatureT) == abs.Abs(signature)
+ensures  err != nil ==> err.ErrorMem()
+ensures  err == nil ==> let t1 := old(io.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m)) in (
+    pl.token(old(io.get_e_In_KMS_placeDst(t1, rid))) &&
+    kmsId == old(io.get_e_In_KMS_r1(t1, rid)) &&
+    agentId == old(io.get_e_In_KMS_r2(t1, rid)) &&
+    rid == old(io.get_e_In_KMS_r3(t1, rid)) &&
+    pair(pubTerm(const_SignResponse_pub()), signatureT) == old(io.get_e_In_KMS_r4(t1, rid)))
+func (kmsService *KMSService) Sign(keyID string, message []byte, ghost p perm, ghost t pl.Place, ghost rid Term, ghost agentId Term, ghost kmsId Term, ghost messageT Term, ghost m Term) (signature []byte, err error, ghost signatureT Term) {
+    // this body acts as a proof that the provided specification is correct and allows
+    // executing a send and a receive operations via a secure channel, which is a TLS
+    // connection to KMS in this case here.
+    ghost var t1 pl.Place
+    err, t1 = kmsService.send(keyID, message, p, t, rid, agentId, kmsId, messageT, m)
+    if err != nil {
+        return
+    }
+    assert t1 == old(io.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m))
+    ghost var t2 pl.Place
+    ghost var recvKmsId, recvAgentId, recvRid Term
+    signature, err, t2, recvKmsId, recvAgentId, recvRid, signatureT = kmsService.receive(t1, rid)
+    // we assume that `receive` only accept messages from the same TLS connection as used by `send`
+    // and that thus the following equalities hold:
+    assume recvKmsId == kmsId && recvAgentId == agentId && recvRid == rid
+    return
+}
+
+requires noPerm < p
+preserves kmsService.Mem() && acc(bytes.SliceMem(message), p) && acc(bytes.SliceMem(signature), p)
+ensures err != nil ==> err.ErrorMem()
+func (kmsService *KMSService) Verify(kmsKeyId string, message []byte, signature []byte, ghost p perm) (success bool, err error)
+
+requires noPerm < p
+requires m == pair(pubTerm(const_SignRequest_pub()), pair(pubTerm(pub_msg(keyID)), inputDataT))
+requires kmsService.Mem() && acc(bytes.SliceMem(inputData), p)
+requires pl.token(t) && io.e_Out_KMS(t, rid, agentId, kmsId, rid, m) && by.gamma(inputDataT) == abs.Abs(inputData)
+ensures  kmsService.Mem() && acc(bytes.SliceMem(inputData), p) 
+ensures  err != nil ==> err.ErrorMem()
+ensures  err == nil ==> pl.token(t1) && t1 == old(io.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m))
+/*ensures  err != nil ==> t1 == t && pl.token(t) && io.e_Out_KMS(t, rid, agentId, kmsId, rid, m) &&
+    io.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m) == old(io.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m))*/
+func (kmsService *KMSService) send(keyID string, inputData []byte, ghost p perm, ghost t pl.Place, ghost rid Term, ghost agentId Term, ghost kmsId Term, ghost inputDataT Term, ghost m Term) (err error, ghost t1 pl.Place)
+
+requires  pl.token(t) && io.e_In_KMS(t, rid)
+preserves kmsService.Mem()
+ensures   err != nil ==> err.ErrorMem()
+ensures   err == nil ==> bytes.SliceMem(data) && by.gamma(dataT) == abs.Abs(data)
+ensures   err == nil ==> pl.token(t1) &&
+    t1 == old(io.get_e_In_KMS_placeDst(t, rid)) &&
+    kmsId == old(io.get_e_In_KMS_r1(t, rid)) &&
+    agentId == old(io.get_e_In_KMS_r2(t, rid)) &&
+    runId == old(io.get_e_In_KMS_r3(t, rid)) &&
+    pair(pubTerm(const_SignResponse_pub()), dataT) == old(io.get_e_In_KMS_r4(t, rid))
+/*ensures   err != nil ==> t1 == t && pl.token(t) && io.e_In_KMS(t, rid) &&
+    io.get_e_In_KMS_placeDst(t, rid) == old(io.get_e_In_KMS_placeDst(t, rid)) &&
+    io.get_e_In_KMS_r1(t, rid) == old(io.get_e_In_KMS_r1(t, rid)) &&
+    io.get_e_In_KMS_r2(t, rid) == old(io.get_e_In_KMS_r2(t, rid)) &&
+    io.get_e_In_KMS_r3(t, rid) == old(io.get_e_In_KMS_r3(t, rid)) &&
+    io.get_e_In_KMS_r4(t, rid) == old(io.get_e_In_KMS_r4(t, rid))*/
+func (kmsService *KMSService) receive(ghost t pl.Place, ghost rid Term) (data []byte, err error, ghost t1 pl.Place, ghost kmsId Term, ghost agentId Term, ghost runId Term, ghost dataT Term)
diff --git a/.verification/agent/session/datastream/datastream-stub.gobra b/.verification/agent/session/datastream/datastream-stub.gobra
new file mode 100644
index 000000000..e66417f54
--- /dev/null
+++ b/.verification/agent/session/datastream/datastream-stub.gobra
@@ -0,0 +1,120 @@
+package datastream
+
+import (
+	"bytes"
+    ctx "github.com/aws/amazon-ssm-agent/agent/context"
+    logger "github.com/aws/amazon-ssm-agent/agent/log"
+	mgsContracts "github.com/aws/amazon-ssm-agent/agent/session/contracts"
+	"github.com/aws/amazon-ssm-agent/agent/session/crypto"
+    "github.com/aws/amazon-ssm-agent/agent/task"
+	"github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+	by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+	ft "github.com/aws/amazon-ssm-agent/agent/iospecs/fact"
+	io "github.com/aws/amazon-ssm-agent/agent/iospecs/iospec"
+	pl "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+	. "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+	tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+)
+
+type DataStream struct {
+    context    ctx.T
+	nonEmptyStruct int
+}
+
+pred (datastream *DataStream) Mem() {
+	acc(datastream) &&
+	acc(datastream.context.Mem(), _)
+}
+
+type Calls interface {
+	pred Inv()
+}
+
+pred StreamDataHandlerSpecWand(t pl.Place, rid tm.Term, msg *mgsContracts.AgentMessage) {
+	(pl.token(t) && io.e_InFact(t, rid)) --* (msg.Mem() && by.gamma(old[#lhs](io.get_e_InFact_r1(t, rid))) == msg.Abs() && pl.token(old[#lhs](io.get_e_InFact_placeDst(t, rid))))
+}
+
+pred QuantifiedStreamDataHandlerSpecWand(msg *mgsContracts.AgentMessage) {
+	forall t pl.Place, rid tm.Term :: { StreamDataHandlerSpecWand(t, rid, msg) } StreamDataHandlerSpecWand(t, rid, msg)
+}
+
+ghost
+requires cs != nil && log != nil
+requires QuantifiedStreamDataHandlerSpecWand(msg)
+preserves cs.Inv() && acc(log.Mem(), _)
+ensures msg.Mem()
+ensures err != nil ==> err.ErrorMem()
+func StreamDataHandlerSpec(ghost cs Calls, log logger.T, msg *mgsContracts.AgentMessage) (err error)
+
+requires acc(context.Mem(), _) && cancelFlag.Mem()
+// the following precondition allows `NewDataStream` or a started go routine to invoke `streamDataHandler`:
+requires cs != nil && cs.Inv() && streamDataHandler implements StreamDataHandlerSpec{cs}
+ensures  err == nil ==> res.Mem() && res.GetChannelId() == channelId
+ensures  err != nil ==> err.ErrorMem()
+func NewDataStream(context ctx.T,
+	channelId string,
+	clientId string,
+	streamDataHandler func(log logger.T, msg *mgsContracts.AgentMessage) error,
+	cancelFlag task.CancelFlag,
+	ghost cs Calls) (res *DataStream, err error)
+
+// since `Send` internally acquires a mutex before sending, a `p` fraction of `datastream.Mem()` is sufficient
+requires log != nil && noPerm < p && acc(bytes.SliceMem(inputData), p)
+requires m == tm.pair(mgsContracts.payloadTypeTerm(payloadType), inputDataT)
+requires pl.token(t) && io.e_OutFact(t, rid, m) && by.gamma(inputDataT) == abs.Abs(inputData)
+preserves acc(datastream.Mem(), p) && acc(log.Mem(), _)
+ensures err != nil ==> err.ErrorMem()
+ensures err == nil ==> pl.token(t1) && t1 == old(io.get_e_OutFact_placeDst(t, rid, m))
+ensures err != nil ==> t1 == t && pl.token(t) && io.e_OutFact(t, rid, m) && io.get_e_OutFact_placeDst(t, rid, m) == old(io.get_e_OutFact_placeDst(t, rid, m))
+func (datastream *DataStream) Send(log logger.T, payloadType mgsContracts.PayloadType, inputData []byte, ghost p perm, ghost t pl.Place, ghost rid tm.Term, ghost inputDataT tm.Term, ghost m tm.Term) (err error, ghost t1 pl.Place)
+
+// a fractional permission is sufficient as a lock is internally acquired
+requires noPerm < p
+preserves acc(datastream.Mem(), p)
+func (datastream *DataStream) GetStreamDataSequenceNumber(ghost p perm) int64
+
+requires acc(datastream.Mem(), _)
+pure
+func (datastream *DataStream) GetChannelId() string
+
+requires acc(datastream.Mem(), _)
+pure
+func (datastream *DataStream) GetInstanceId() string
+
+requires acc(datastream.Mem(), _)
+pure
+func (datastream *DataStream) GetClientId() string
+
+requires acc(datastream.Mem(), _)
+pure
+func (datastream *DataStream) GetRegion() string
+
+requires acc(datastream.Mem(), _)
+pure
+func (datastream *DataStream) IsActive() bool
+
+// the cancel flag internally acquires a lock thus making read-only
+// permissions sufficient
+requires noPerm < p
+preserves acc(datastream.Mem(), p)
+func (datastream *DataStream) CancelSession(ghost p perm)
+
+preserves datastream.Mem()
+ensures err != nil ==> err.ErrorMem()
+ensures datastream.GetChannelId() == old(datastream.GetChannelId())
+func (datastream *DataStream) Close(log logger.T) (err error)
+
+preserves datastream.Mem()
+ensures datastream.GetChannelId() == old(datastream.GetChannelId())
+func (datastream *DataStream) PrepareToCloseChannel(log logger.T)
+
+requires noPerm < p
+preserves acc(datastream.Mem(), p)
+ensures err == nil ==> service.Mem()
+ensures err != nil ==> err.ErrorMem()
+func (datastream *DataStream) GetKMSService(ghost p perm) (service *crypto.KMSService, err error) {
+	unfold acc(datastream.Mem(), p)
+	service, err = crypto.NewKMSService(datastream.context)
+	fold acc(datastream.Mem(), p)
+	return
+}
diff --git a/.verification/agent/task/task-stub.gobra b/.verification/agent/task/task-stub.gobra
new file mode 100644
index 000000000..d4f2b8c63
--- /dev/null
+++ b/.verification/agent/task/task-stub.gobra
@@ -0,0 +1,5 @@
+package task
+
+type CancelFlag interface{
+    pred Mem()
+}
diff --git a/.verification/agent/times/times-stub.gobra b/.verification/agent/times/times-stub.gobra
new file mode 100644
index 000000000..ead6b999f
--- /dev/null
+++ b/.verification/agent/times/times-stub.gobra
@@ -0,0 +1 @@
+package times
diff --git a/.verification/big/big-stub.gobra b/.verification/big/big-stub.gobra
new file mode 100644
index 000000000..1e0ade014
--- /dev/null
+++ b/.verification/big/big-stub.gobra
@@ -0,0 +1,21 @@
+package big
+
+import "bytes"
+
+type Word uint
+
+type nat []Word
+
+type Int struct {
+    neg bool // sign
+    abs nat  // absolute value of the integer
+}
+
+pred (i *Int) Mem() {
+    acc(i) && acc(i.abs)
+}
+
+requires noPerm < p
+preserves acc(i.Mem(), p)
+ensures bytes.SliceMem(res)
+func (i *Int) Bytes(ghost p perm) (res []byte)
diff --git a/.verification/bufio/bufio-stub.gobra b/.verification/bufio/bufio-stub.gobra
new file mode 100644
index 000000000..ab5bd3e03
--- /dev/null
+++ b/.verification/bufio/bufio-stub.gobra
@@ -0,0 +1 @@
+package bufio
diff --git a/.verification/bytes/bytes-stub.gobra b/.verification/bytes/bytes-stub.gobra
new file mode 100644
index 000000000..005511ea4
--- /dev/null
+++ b/.verification/bytes/bytes-stub.gobra
@@ -0,0 +1,15 @@
+package bytes
+
+pred SliceMem(bytes []byte) {
+	acc(bytes)
+}
+
+decreases
+requires acc(SliceMem(a), _)
+requires acc(SliceMem(b), _)
+pure func Equal(a, b []byte) bool {
+	// Neither cmd/compile nor gccgo allocates for these string conversions.
+	return unfolding acc(SliceMem(a), _) in
+		unfolding acc(SliceMem(b), _) in
+		string(a) == string(b)
+}
diff --git a/.verification/container/list/list-stub.gobra b/.verification/container/list/list-stub.gobra
new file mode 100644
index 000000000..2cdd824f0
--- /dev/null
+++ b/.verification/container/list/list-stub.gobra
@@ -0,0 +1 @@
+package list
diff --git a/.verification/crypto/aes/aes-stub.gobra b/.verification/crypto/aes/aes-stub.gobra
new file mode 100644
index 000000000..c0985b506
--- /dev/null
+++ b/.verification/crypto/aes/aes-stub.gobra
@@ -0,0 +1 @@
+package aes
diff --git a/.verification/crypto/cipher/cipher-stub.gobra b/.verification/crypto/cipher/cipher-stub.gobra
new file mode 100644
index 000000000..cbc89e70b
--- /dev/null
+++ b/.verification/crypto/cipher/cipher-stub.gobra
@@ -0,0 +1,5 @@
+package cipher
+
+type AEAD interface {
+    pred Mem()
+}
diff --git a/.verification/crypto/elliptic/elliptic-stub.gobra b/.verification/crypto/elliptic/elliptic-stub.gobra
new file mode 100644
index 000000000..3f6a13e0c
--- /dev/null
+++ b/.verification/crypto/elliptic/elliptic-stub.gobra
@@ -0,0 +1,51 @@
+package elliptic
+
+import (
+    "big"
+    "bytes"
+    "io"
+    "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+    by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+    "github.com/aws/amazon-ssm-agent/agent/iospecs/iospec"
+    pl "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+    tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+)
+
+type Curve interface {
+    pred Mem()
+
+    requires noPerm < p
+    preserves acc(Mem(), p) && acc(x.Mem(), p) && acc(y.Mem(), p)
+    IsOnCurve(x, y *big.Int, ghost p perm) bool
+    
+    requires noPerm < p
+    preserves acc(Mem(), p) && acc(x1.Mem(), p) && acc(y1.Mem(), p) && acc(bytes.SliceMem(k), p)
+    ensures x.Mem() && y.Mem()
+    ScalarMult(x1, y1 *big.Int, k []byte, ghost p perm) (x, y *big.Int)
+}
+
+ensures curve != nil && curve.Mem()
+func P384() (curve Curve)
+
+preserves curve.Mem() && rand.Mem()
+requires pl.token(t0) && iospec.e_FrFact(t0, rid)
+ensures  err == nil ==> bytes.SliceMem(priv) && x.Mem() && y.Mem()
+ensures  err == nil ==> pl.token(t1) && t1 == old(iospec.get_e_FrFact_placeDst(t0, rid))
+ensures  err == nil ==> abs.Abs(priv) == by.gamma(old(iospec.get_e_FrFact_r1(t0, rid)))
+// ensures  err == nil ==> abs.AbsEllipticPk(x, y) == by.expB(by.generatorB(), abs.Abs(priv))
+ensures  err != nil ==> err.ErrorMem()
+ensures  err != nil ==> t1 == t0 && pl.token(t0) && iospec.e_FrFact(t0, rid) &&
+    iospec.get_e_FrFact_placeDst(t0, rid) == old(iospec.get_e_FrFact_placeDst(t0, rid)) &&
+    iospec.get_e_FrFact_r1(t0, rid) == old(iospec.get_e_FrFact_r1(t0, rid))
+func GenerateKey(curve Curve, rand io.Reader, ghost t0 pl.Place, ghost rid tm.Term) (priv []byte, x *big.Int, y *big.Int, err error, ghost t1 pl.Place)
+
+requires noPerm < p
+preserves curve.Mem() && acc(x.Mem(), p) && acc(y.Mem(), p)
+ensures bytes.SliceMem(res)
+// ensures abs.Abs(res) == abs.AbsEllipticPk(x, y)
+func MarshalCompressed(curve Curve, x *big.Int, y *big.Int, ghost p perm) (res []byte)
+
+requires noPerm < p
+preserves curve.Mem() && bytes.SliceMem(data)
+ensures x.Mem() && y.Mem()
+func UnmarshalCompressed(curve Curve, data []byte, ghost p perm) (x *big.Int, y *big.Int)
diff --git a/.verification/crypto/rand/rand-stub.gobra b/.verification/crypto/rand/rand-stub.gobra
new file mode 100644
index 000000000..6155e6104
--- /dev/null
+++ b/.verification/crypto/rand/rand-stub.gobra
@@ -0,0 +1,12 @@
+package rand
+
+import "io"
+
+var Reader io.Reader
+
+// since `Reader` is a global and shared instance of
+// a cryptographic random number generator, we assume
+// that the `Mem` predicate is a duplicable resource.
+ghost
+ensures Reader.Mem()
+func GetReaderMem()
diff --git a/.verification/crypto/rsa/rsa-stub.gobra b/.verification/crypto/rsa/rsa-stub.gobra
new file mode 100644
index 000000000..0a97f3700
--- /dev/null
+++ b/.verification/crypto/rsa/rsa-stub.gobra
@@ -0,0 +1,48 @@
+package rsa
+
+import (
+    "big"
+    "bytes"
+    "io"
+    by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+)
+
+type PublicKey struct {
+    N *big.Int // modulus
+    E int      // public exponent
+}
+
+pred (pk *PublicKey) Mem() {
+    acc(pk) &&
+    (pk.N != nil ==> pk.N.Mem())
+}
+
+pure func (pk *PublicKey) Abs() by.Bytes
+
+
+type PrivateKey struct {
+	PublicKey            // public part.
+	D         *big.Int   // private exponent
+	Primes    []*big.Int // prime factors of N, has >= 2 elements.
+
+	additionalStructFields int // hidden
+}
+
+pred (sk *PrivateKey) Mem() {
+    acc(&sk.D) && acc(&sk.Primes) && acc(&sk.additionalStructFields) && 
+    sk.PublicKey.Mem() &&
+    (sk.D != nil ==> sk.D.Mem()) &&
+    (forall i int :: { sk.Primes[i] } 0 <= i && i < len(sk.Primes) ==> acc(&sk.Primes[i]) && sk.Primes[i].Mem())
+}
+
+requires noPerm < p
+preserves acc(random.Mem(), p)
+ensures err == nil ==> sk.Mem()
+ensures err != nil ==> err.ErrorMem()
+func GenerateKey(random io.Reader, bits int, ghost p perm) (sk *PrivateKey, err error)
+
+requires noPerm < p
+preserves acc(random.Mem(), p) && acc(pub.Mem(), p) && acc(bytes.SliceMem(msg), p)
+ensures err == nil ==> bytes.SliceMem(ciphertext)
+ensures err != nil ==> err.ErrorMem()
+func EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte, ghost p perm) (ciphertext []byte, err error)
diff --git a/.verification/crypto/sha256/sha256-stub.gobra b/.verification/crypto/sha256/sha256-stub.gobra
new file mode 100644
index 000000000..c39f32f17
--- /dev/null
+++ b/.verification/crypto/sha256/sha256-stub.gobra
@@ -0,0 +1 @@
+package sha256
diff --git a/.verification/crypto/sha512/sha512-stub.gobra b/.verification/crypto/sha512/sha512-stub.gobra
new file mode 100644
index 000000000..fb5274b01
--- /dev/null
+++ b/.verification/crypto/sha512/sha512-stub.gobra
@@ -0,0 +1 @@
+package sha512
diff --git a/.verification/encoding/base64/base64-stub.gobra b/.verification/encoding/base64/base64-stub.gobra
new file mode 100644
index 000000000..fe972f5f1
--- /dev/null
+++ b/.verification/encoding/base64/base64-stub.gobra
@@ -0,0 +1,28 @@
+package base64
+
+import (
+    "bytes"
+    "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+    by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+)
+
+// we omit permissions to `encoding` because we assume
+// that the following variables behave like constants
+// that do not get modified by calls to `EncodeToString` and
+// `DecodeString`.
+
+var StdEncoding *Encoding
+var RawStdEncoding *Encoding
+
+type Encoding struct {
+    nonEmptyStruct int
+}
+
+requires noPerm < p
+preserves acc(bytes.SliceMem(src), p)
+// ensures  abs.Abs(src) == by.msgB(res) 
+func (encoding *Encoding) EncodeToString(src []byte, ghost p perm) (res string)
+
+ensures err == nil ==> bytes.SliceMem(res)
+ensures err != nil ==> err.ErrorMem()
+func (encoding *Encoding) DecodeString(s string) (res []byte, err error)
diff --git a/.verification/encoding/json/json-stub.gobra b/.verification/encoding/json/json-stub.gobra
new file mode 100644
index 000000000..5c2d46ad9
--- /dev/null
+++ b/.verification/encoding/json/json-stub.gobra
@@ -0,0 +1,21 @@
+package json
+
+import "bytes"
+
+type Number string
+type RawMessage []byte
+
+type AnyWithMem interface {
+    pred Mem()
+}
+
+requires noPerm < p
+preserves acc(v.Mem(), p)
+ensures err == nil ==> bytes.SliceMem(res)
+ensures err != nil ==> err.ErrorMem()
+func Marshal(v AnyWithMem, ghost p perm) (res []byte, err error)
+
+requires noPerm < p
+preserves acc(bytes.SliceMem(data), p) && v.Mem()
+ensures err != nil ==> err.ErrorMem()
+func Unmarshal(data []byte, v AnyWithMem, ghost p perm) (err error)
diff --git a/.verification/errors/errors-stub.gobra b/.verification/errors/errors-stub.gobra
new file mode 100644
index 000000000..36d0440ee
--- /dev/null
+++ b/.verification/errors/errors-stub.gobra
@@ -0,0 +1,4 @@
+package errors
+
+ensures err != nil && err.ErrorMem()
+func New(text string) (err error)
diff --git a/.verification/fmt/fmt-stubs.gobra b/.verification/fmt/fmt-stubs.gobra
new file mode 100644
index 000000000..c1815b1f0
--- /dev/null
+++ b/.verification/fmt/fmt-stubs.gobra
@@ -0,0 +1 @@
+package fmt
diff --git a/.verification/github.com/aws/aws-sdk-go/aws/aws-stub.gobra b/.verification/github.com/aws/aws-sdk-go/aws/aws-stub.gobra
new file mode 100644
index 000000000..a1f9c0e3b
--- /dev/null
+++ b/.verification/github.com/aws/aws-sdk-go/aws/aws-stub.gobra
@@ -0,0 +1 @@
+package aws
diff --git a/.verification/github.com/aws/aws-sdk-go/aws/request/request-stub.gobra b/.verification/github.com/aws/aws-sdk-go/aws/request/request-stub.gobra
new file mode 100644
index 000000000..725b8fc21
--- /dev/null
+++ b/.verification/github.com/aws/aws-sdk-go/aws/request/request-stub.gobra
@@ -0,0 +1 @@
+package request
diff --git a/.verification/github.com/aws/aws-sdk-go/aws/session/session-stub.gobra b/.verification/github.com/aws/aws-sdk-go/aws/session/session-stub.gobra
new file mode 100644
index 000000000..ab876163d
--- /dev/null
+++ b/.verification/github.com/aws/aws-sdk-go/aws/session/session-stub.gobra
@@ -0,0 +1 @@
+package session
diff --git a/.verification/github.com/aws/aws-sdk-go/service/kms/kms-stub.gobra b/.verification/github.com/aws/aws-sdk-go/service/kms/kms-stub.gobra
new file mode 100644
index 000000000..6dd5f9fa0
--- /dev/null
+++ b/.verification/github.com/aws/aws-sdk-go/service/kms/kms-stub.gobra
@@ -0,0 +1,10 @@
+package kms
+
+type KeyMetadata struct {
+    Arn *string
+    additionalFields int
+}
+
+pred (meta *KeyMetadata) Mem() {
+    acc(meta) && acc(meta.Arn)
+}
diff --git a/.verification/github.com/aws/aws-sdk-go/service/kms/kmsiface/kmsiface-stub.gobra b/.verification/github.com/aws/aws-sdk-go/service/kms/kmsiface/kmsiface-stub.gobra
new file mode 100644
index 000000000..33f6ed416
--- /dev/null
+++ b/.verification/github.com/aws/aws-sdk-go/service/kms/kmsiface/kmsiface-stub.gobra
@@ -0,0 +1 @@
+package kmsiface
diff --git a/.verification/github.com/cihub/seelog/seelog-stub.gobra b/.verification/github.com/cihub/seelog/seelog-stub.gobra
new file mode 100644
index 000000000..6c05ce563
--- /dev/null
+++ b/.verification/github.com/cihub/seelog/seelog-stub.gobra
@@ -0,0 +1 @@
+package seelog
diff --git a/.verification/github.com/coreos/go-semver/semver/semver-stub.gobra b/.verification/github.com/coreos/go-semver/semver/semver-stub.gobra
new file mode 100644
index 000000000..e988fc064
--- /dev/null
+++ b/.verification/github.com/coreos/go-semver/semver/semver-stub.gobra
@@ -0,0 +1 @@
+package semver
diff --git a/.verification/github.com/gorilla/websocket/websocket-stub.gobra b/.verification/github.com/gorilla/websocket/websocket-stub.gobra
new file mode 100644
index 000000000..708bc8cb5
--- /dev/null
+++ b/.verification/github.com/gorilla/websocket/websocket-stub.gobra
@@ -0,0 +1 @@
+package websocket
diff --git a/.verification/github.com/twinj/uuid/uuid-stub.gobra b/.verification/github.com/twinj/uuid/uuid-stub.gobra
new file mode 100644
index 000000000..17ae9ba0c
--- /dev/null
+++ b/.verification/github.com/twinj/uuid/uuid-stub.gobra
@@ -0,0 +1,5 @@
+package uuid
+
+type UUID interface{
+    pred Mem()
+}
diff --git a/.verification/golang.org/x/crypto/hkdf/hkdf-stub.gobra b/.verification/golang.org/x/crypto/hkdf/hkdf-stub.gobra
new file mode 100644
index 000000000..4edf1f33f
--- /dev/null
+++ b/.verification/golang.org/x/crypto/hkdf/hkdf-stub.gobra
@@ -0,0 +1 @@
+package hkdf
diff --git a/.verification/io/io-stub.gobra b/.verification/io/io-stub.gobra
new file mode 100644
index 000000000..884d6c23f
--- /dev/null
+++ b/.verification/io/io-stub.gobra
@@ -0,0 +1,11 @@
+package io
+
+import "bytes"
+
+type Reader interface {
+	pred Mem()
+	
+	preserves Mem() && bytes.SliceMem(p)
+	ensures err != nil ==> err.ErrorMem()
+	Read(p []byte) (n int, err error)
+}
diff --git a/.verification/io/ioutil/ioutil-stub.gobra b/.verification/io/ioutil/ioutil-stub.gobra
new file mode 100644
index 000000000..3cdec6725
--- /dev/null
+++ b/.verification/io/ioutil/ioutil-stub.gobra
@@ -0,0 +1 @@
+package ioutil
diff --git a/.verification/log/log-stub.gobra b/.verification/log/log-stub.gobra
new file mode 100644
index 000000000..7330d5405
--- /dev/null
+++ b/.verification/log/log-stub.gobra
@@ -0,0 +1 @@
+package log
diff --git a/.verification/math/math-stub.gobra b/.verification/math/math-stub.gobra
new file mode 100644
index 000000000..c91c24e96
--- /dev/null
+++ b/.verification/math/math-stub.gobra
@@ -0,0 +1 @@
+package math
diff --git a/.verification/math/rand/rand-stub.gobra b/.verification/math/rand/rand-stub.gobra
new file mode 100644
index 000000000..fe1e48f21
--- /dev/null
+++ b/.verification/math/rand/rand-stub.gobra
@@ -0,0 +1 @@
+package rand
diff --git a/.verification/os/os-stub.gobra b/.verification/os/os-stub.gobra
new file mode 100644
index 000000000..cf1f67e04
--- /dev/null
+++ b/.verification/os/os-stub.gobra
@@ -0,0 +1 @@
+package os
diff --git a/.verification/path/filepath/filepath-stub.gobra b/.verification/path/filepath/filepath-stub.gobra
new file mode 100644
index 000000000..eb122e6c5
--- /dev/null
+++ b/.verification/path/filepath/filepath-stub.gobra
@@ -0,0 +1 @@
+package filepath
diff --git a/.verification/regexp/regexp-stub.gobra b/.verification/regexp/regexp-stub.gobra
new file mode 100644
index 000000000..1c25b145f
--- /dev/null
+++ b/.verification/regexp/regexp-stub.gobra
@@ -0,0 +1 @@
+package regexp
diff --git a/.verification/runtime/debug/debug-stub.gobra b/.verification/runtime/debug/debug-stub.gobra
new file mode 100644
index 000000000..8dc17c684
--- /dev/null
+++ b/.verification/runtime/debug/debug-stub.gobra
@@ -0,0 +1 @@
+package debug
diff --git a/.verification/runtime/runtime-stub.gobra b/.verification/runtime/runtime-stub.gobra
new file mode 100644
index 000000000..7ccdf5f69
--- /dev/null
+++ b/.verification/runtime/runtime-stub.gobra
@@ -0,0 +1 @@
+package runtime
diff --git a/.verification/syscall/syscall-stub.gobra b/.verification/syscall/syscall-stub.gobra
new file mode 100644
index 000000000..29fa81d70
--- /dev/null
+++ b/.verification/syscall/syscall-stub.gobra
@@ -0,0 +1 @@
+package syscall
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 000000000..52e83f036
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,23 @@
+{
+    "gobraSettings.moduleName": "github.com/aws/amazon-ssm-agent",
+    "gobraSettings.includeDirs": [
+        ".verification",
+        "."
+    ],
+    "gobraSettings.buildVersion": "Local",
+    "gobraDependencies.gobraToolsPaths": {
+        "gobraToolsBasePath": {
+            "mac": "$HOME/Library/Application Support/Code/User/globalStorage/viper-admin.gobra-ide/Nightly/GobraTools"
+        },
+        "serverJar": {
+            "mac": "/Users/arquintl/gobra-ide/server/target/scala-2.13/server.jar"
+        },
+        "z3Executable": {
+            // "mac": "/usr/local/bin/z3"
+            "mac": "$gobraTools$/z3/bin/z3"
+        }
+    },
+    "gobraSettings.loglevel": "DEBUG",
+    "gobraSettings.autoVerify": false,
+    "gobraSettings.verifyPackage": false,
+}
diff --git a/agent/contracts/model.go b/agent/contracts/model.go
index d83d5b9e7..e735cd1f6 100644
--- a/agent/contracts/model.go
+++ b/agent/contracts/model.go
@@ -84,7 +84,7 @@ func (rs ResultStatus) IsReboot() bool {
 }
 
 // MergeResultStatus takes two ResultStatuses (presumably from sub-tasks) and decides what the overall task status should be
-func MergeResultStatus(current ResultStatus, new ResultStatus) (merged ResultStatus) {
+func MergeResultStatus(current ResultStatus, newStatus ResultStatus) (merged ResultStatus) {
 	orderedResultStatus := [...]ResultStatus{
 		ResultStatusSkipped,
 		ResultStatusSuccess,
@@ -96,10 +96,10 @@ func MergeResultStatus(current ResultStatus, new ResultStatus) (merged ResultSta
 		ResultStatusCancelled,
 		ResultStatusTimedOut,
 	}
-	if current == "" {
-		return new
+	if current == ResultStatus("") {
+		return newStatus
 	}
-	if new == "" {
+	if newStatus == ResultStatus("") {
 		return current
 	}
 
@@ -107,13 +107,13 @@ func MergeResultStatus(current ResultStatus, new ResultStatus) (merged ResultSta
 	// We assume both exist in the array and therefore the first one found is at the lower index (so return the other one)
 	for _, ResultStatus := range orderedResultStatus {
 		if ResultStatus == current {
-			return new
+			return newStatus
 		}
-		if ResultStatus == new {
+		if ResultStatus == newStatus {
 			return current
 		}
 	}
-	return new // Default to new ResultStatus if neither is found in the array
+	return newStatus // Default to new ResultStatus if neither is found in the array
 }
 
 const (
diff --git a/agent/log/ssmlog/config_watcher.go b/agent/log/ssmlog/config_watcher.go
index 3e0172069..1210cd6b1 100644
--- a/agent/log/ssmlog/config_watcher.go
+++ b/agent/log/ssmlog/config_watcher.go
@@ -86,7 +86,7 @@ func (fileWatcher *FileWatcher) fileEventHandler() {
 	// Waiting on signals from OS
 	for event := range fileWatcher.watcher.Events {
 		// Event signalled by OS on file
-		fileWatcher.log.Debugf("Event on file %v : %v", event.Name, event)
+		// fileWatcher.log.Debugf("Event on file %v : %v", event.Name, event)
 		if event.Name == fileWatcher.configFilePath {
 			// Event on the file being watched
 			if event.Op&fsnotify.Write == fsnotify.Write || event.Op&fsnotify.Create == fsnotify.Create || event.Op&fsnotify.Rename == fsnotify.Rename {
diff --git a/agent/messageservice/interactor/mgsinteractor/mgsinteractor.go b/agent/messageservice/interactor/mgsinteractor/mgsinteractor.go
index 70ff6a684..1f3501851 100644
--- a/agent/messageservice/interactor/mgsinteractor/mgsinteractor.go
+++ b/agent/messageservice/interactor/mgsinteractor/mgsinteractor.go
@@ -365,7 +365,7 @@ func (mgs *MGSInteractor) processSessionRelatedMessages(agentMessage mgsContract
 
 func (mgs *MGSInteractor) processJobReplyAck(log log.T, agentMessage mgsContracts.AgentMessage) {
 	replyAcknowledge := &mgsContracts.AgentJobReplyAckContent{}
-	if err := replyAcknowledge.Deserialize(log, agentMessage); err != nil {
+	if err := replyAcknowledge.Deserialize(log, &agentMessage); err != nil {
 		log.Errorf("Cannot parse AgentReply message to taskAck message: %s, err: %v.", agentMessage.MessageId, err)
 	}
 	log.Infof("received ack id %v for message id %v", replyAcknowledge.AcknowledgedMessageId, agentMessage.MessageId)
@@ -486,7 +486,7 @@ func (mgs *MGSInteractor) processTaskAcknowledgeMessage(agentMessage mgsContract
 	log.Debugf("Processing Task Acknowledge message %s", agentMessage.MessageId.String())
 
 	taskAcknowledge := &mgsContracts.AcknowledgeTaskContent{}
-	if err := taskAcknowledge.Deserialize(log, agentMessage); err != nil {
+	if err := taskAcknowledge.Deserialize(log, &agentMessage); err != nil {
 		log.Errorf("Cannot parse AgentTask message to TaskAcknowledgeMessage message: %s, err: %v.", agentMessage.MessageId.String(), err)
 		return
 	}
diff --git a/agent/s3util/s3util_dep.go b/agent/s3util/s3util_dep.go
index 978f9916c..a9b916ba5 100644
--- a/agent/s3util/s3util_dep.go
+++ b/agent/s3util/s3util_dep.go
@@ -116,7 +116,7 @@ func (trans headBucketTransport) RoundTrip(request *http.Request) (resp *http.Re
 	resp, err = trans.delegate.RoundTrip(request)
 	if err == nil && resp != nil && goHttpClientWillFollowRedirect(resp.StatusCode) {
 		if resp.Header != nil && resp.Header.Get("Location") == "" && resp.Header.Get(bucketRegionHeader) != "" {
-			logger.Debugf("redirect response missing Location header, overriding status code")
+			trans.logger.Debugf("redirect response missing Location header, overriding status code")
 			resp.StatusCode = 200
 		}
 	}
diff --git a/agent/session/contracts/agentmessage.go b/agent/session/contracts/agentmessage.go
index 9156273f0..4d6fb580e 100644
--- a/agent/session/contracts/agentmessage.go
+++ b/agent/session/contracts/agentmessage.go
@@ -25,7 +25,7 @@ import (
 	"strings"
 	"time"
 
-	"github.com/aws/amazon-ssm-agent/agent/context"
+	ctx "github.com/aws/amazon-ssm-agent/agent/context"
 	"github.com/aws/amazon-ssm-agent/agent/contracts"
 	"github.com/aws/amazon-ssm-agent/agent/framework/docparser"
 	"github.com/aws/amazon-ssm-agent/agent/jsonutil"
@@ -34,13 +34,16 @@ import (
 	"github.com/aws/amazon-ssm-agent/agent/messageservice/utils"
 	"github.com/aws/amazon-ssm-agent/agent/times"
 	"github.com/twinj/uuid"
+	//@ abs "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+	//@ by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+	//@ tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
 )
 
 type IAgentMessage interface {
 	Deserialize(log logger.T, input []byte) (err error)
 	Serialize(log logger.T) (result []byte, err error)
 	Validate() error
-	ParseAgentMessage(context context.T, messagesOrchestrationRootDir string, instanceId string) (*contracts.DocumentState, error)
+	ParseAgentMessage(context ctx.T, messagesOrchestrationRootDir string, instanceId string) (*contracts.DocumentState, error)
 }
 
 // AgentMessage represents a message for agent to send/receive. AgentMessage Message in MGS is equivalent to MDS' InstanceMessage.
@@ -59,6 +62,23 @@ type AgentMessage struct {
 	Payload        []byte
 }
 
+/*@
+pred (msg *AgentMessage) Mem() {
+	acc(msg) &&
+	msg.MessageId.Mem() &&
+	bytes.SliceMem(msg.PayloadDigest) &&
+	bytes.SliceMem(msg.Payload)
+}
+
+ghost
+requires acc(msg.Mem(), _)
+pure
+func (msg *AgentMessage) Abs() by.Bytes {
+	return unfolding acc(msg.Mem(), _) in
+		by.pairB(by.gamma(payloadTypeTerm(PayloadType(msg.PayloadType))), abs.Abs(msg.Payload))
+}
+@*/
+
 // HL - HeaderLength is a 4 byte integer that represents the header length.
 // MessageType is a 32 byte UTF-8 string containing the message type.
 // SchemaVersion is a 4 byte integer containing the message schema version number.
@@ -272,7 +292,7 @@ func (agentMessage *AgentMessage) Validate() error {
 	return nil
 }
 
-func (agentMessage *AgentMessage) ParseAgentMessage(context context.T, messagesOrchestrationRootDir string, instanceId string) (*contracts.DocumentState, error) {
+func (agentMessage *AgentMessage) ParseAgentMessage(context ctx.T, messagesOrchestrationRootDir string, instanceId string) (*contracts.DocumentState, error) {
 	log := context.Log()
 
 	log.Infof("Parsing AgentMessage %s, Payload: %s", agentMessage.MessageId, string(agentMessage.Payload))
@@ -301,7 +321,7 @@ func (agentMessage *AgentMessage) ParseAgentMessage(context context.T, messagesO
 }
 
 // parseAgentTaskMessage parses session message to documentState object for processor.
-func parseAgentTaskMessage(context context.T,
+func parseAgentTaskMessage(context ctx.T,
 	messagesOrchestrationRootDir string,
 	instanceId string,
 	agentMessage *AgentMessage) (*contracts.DocumentState, error) {
@@ -354,12 +374,12 @@ func parseAgentTaskMessage(context context.T,
 }
 
 // parseTerminateSessionMessage parses a channel closed AgentMessage to DocumentState object for processor
-func parseTerminateSessionMessage(context context.T, agentMessage *AgentMessage, instanceId string) (*contracts.DocumentState, error) {
+func parseTerminateSessionMessage(context ctx.T, agentMessage *AgentMessage, instanceId string) (*contracts.DocumentState, error) {
 	log := context.Log()
 	log.Debugf("Processing TerminateSession message %s", agentMessage.MessageId.String())
 
 	channelClosed := &ChannelClosed{}
-	if err := channelClosed.Deserialize(log, *agentMessage); err != nil {
+	if err := channelClosed.Deserialize(log, agentMessage); err != nil {
 		log.Errorf("Cannot parse AgentTask message to ChannelClosed message: %s, err: %v.", agentMessage.MessageId, err)
 		return nil, err
 	}
@@ -393,7 +413,7 @@ func parseTerminateSessionMessage(context context.T, agentMessage *AgentMessage,
 }
 
 // parseAgentJobMessage parses run command SendCommand or CancelCommand to documentState object for processor.
-func parseAgentJobMessage(context context.T, commandOrchestrationRootDir string, instanceId string, agentMessage *AgentMessage) (*contracts.DocumentState, error) {
+func parseAgentJobMessage(context ctx.T, commandOrchestrationRootDir string, instanceId string, agentMessage *AgentMessage) (*contracts.DocumentState, error) {
 	log := context.Log()
 
 	if agentMessage.MessageType != AgentJobMessage {
@@ -430,7 +450,7 @@ func parseAgentJobMessage(context context.T, commandOrchestrationRootDir string,
 	return docState, nil
 }
 
-func parseAgentJobCancelCommandMessage(context context.T, agentJobPayload AgentJobPayload, instanceId string, agentMessage AgentMessage) (*contracts.DocumentState, error) {
+func parseAgentJobCancelCommandMessage(context ctx.T, agentJobPayload AgentJobPayload, instanceId string, agentMessage AgentMessage) (*contracts.DocumentState, error) {
 	log := context.Log()
 	log.Debug("Processing agent job cancel command message - ", agentJobPayload.JobId)
 	log.Debug("Payload: ", jsonutil.Indent(agentJobPayload.Payload))
@@ -438,7 +458,7 @@ func parseAgentJobCancelCommandMessage(context context.T, agentJobPayload AgentJ
 	return utils.ParseCancelCommandMessage(context, message, contracts.MessageGatewayService)
 }
 
-func parseAgentJobSendCommandMessage(context context.T, agentJobPayload AgentJobPayload, commandOrchestrationRootDir string, instanceId string, agentMessage AgentMessage) (*contracts.DocumentState, error) {
+func parseAgentJobSendCommandMessage(context ctx.T, agentJobPayload AgentJobPayload, commandOrchestrationRootDir string, instanceId string, agentMessage AgentMessage) (*contracts.DocumentState, error) {
 	log := context.Log()
 	log.Debug("Processing agent job send command message jobId: ", agentJobPayload.JobId)
 	log.Debug("Payload: ", jsonutil.Indent(agentJobPayload.Payload))
diff --git a/agent/session/contracts/model.go b/agent/session/contracts/model.go
index d6d5ecb24..e7ecab6cb 100644
--- a/agent/session/contracts/model.go
+++ b/agent/session/contracts/model.go
@@ -22,6 +22,11 @@ import (
 
 	"github.com/aws/amazon-ssm-agent/agent/contracts"
 	logger "github.com/aws/amazon-ssm-agent/agent/log"
+	//@ "bytes"
+	//@ "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+	//@ by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+	//@ tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+	//@ "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
 )
 
 const (
@@ -72,7 +77,7 @@ type ShellConfig struct {
 }
 
 type IMessage interface {
-	Deserialize(log logger.T, agentMessage AgentMessage) (err error)
+	Deserialize(log logger.T, agentMessage *AgentMessage) (err error)
 	Serialize(log logger.T) (result []byte, err error)
 }
 
@@ -164,8 +169,14 @@ type AgentSessionStateContent struct {
 	SessionId     string `json:"SessionId"`
 }
 
+/*@
+pred (agentSessionStateContent *AgentSessionStateContent) Mem() {
+	acc(agentSessionStateContent)
+}
+@*/
+
 // Deserialize parses AcknowledgeContent message from payload of AgentMessage.
-func (dataStreamAcknowledge *AcknowledgeContent) Deserialize(log logger.T, agentMessage AgentMessage) (err error) {
+func (dataStreamAcknowledge *AcknowledgeContent) Deserialize(log logger.T, agentMessage *AgentMessage) (err error) {
 	if agentMessage.MessageType != AcknowledgeMessage {
 		err = fmt.Errorf("AgentMessage is not of type AcknowledgeMessage. Found message type: %s", agentMessage.MessageType)
 		return
@@ -203,7 +214,7 @@ type ChannelClosed struct {
 }
 
 // Deserialize parses channelClosed message from payload of AgentMessage.
-func (channelClose *ChannelClosed) Deserialize(log logger.T, agentMessage AgentMessage) (err error) {
+func (channelClose *ChannelClosed) Deserialize(log logger.T, agentMessage *AgentMessage) (err error) {
 	if agentMessage.MessageType != ChannelClosedMessage {
 		err = fmt.Errorf("AgentMessage is not of type ChannelClosed. Found message type: %s", agentMessage.MessageType)
 		return
@@ -248,7 +259,7 @@ type AgentJobReplyAckContent struct {
 }
 
 // Deserialize parses taskAcknowledge message from payload of AgentMessage.
-func (replyAck *AgentJobReplyAckContent) Deserialize(log logger.T, agentMessage AgentMessage) (err error) {
+func (replyAck *AgentJobReplyAckContent) Deserialize(log logger.T, agentMessage *AgentMessage) (err error) {
 	if agentMessage.MessageType != AgentJobReplyAck {
 		err = fmt.Errorf("AgentMessage is not of type AgentJobReplyAck. Found message type: %s", agentMessage.MessageType)
 		return
@@ -278,7 +289,7 @@ type AcknowledgeTaskContent struct {
 }
 
 // Deserialize parses taskAcknowledge message from payload of AgentMessage.
-func (taskAcknowledge *AcknowledgeTaskContent) Deserialize(log logger.T, agentMessage AgentMessage) (err error) {
+func (taskAcknowledge *AcknowledgeTaskContent) Deserialize(log logger.T, agentMessage *AgentMessage) (err error) {
 	if agentMessage.MessageType != TaskAcknowledgeMessage {
 		err = fmt.Errorf("AgentMessage is not of type TaskAcknowledgeMessage. Found message type: %s", agentMessage.MessageType)
 		return
@@ -325,6 +336,17 @@ const (
 	ExitCode             PayloadType = 12
 )
 
+/*@
+ghost
+pure func payloadTypeTerm(payloadType PayloadType) tm.Term {
+	return payloadType == HandshakeRequest ? tm.pubTerm(pub.const_SecureSessionRequest_pub()) :
+		payloadType == HandshakeResponse ? tm.pubTerm(pub.const_SecureSessionResponse_pub()) :
+		payloadType == HandshakeComplete ? tm.pubTerm(pub.const_HandshakeComplete_pub()) :
+		// payloadType == ? tm.pubTerm(pub.const_Log_pub()) :
+		tm.pubTerm(pub.const_Message_pub())
+}
+@*/
+
 type PayloadTypeFlag uint32
 
 const (
@@ -353,6 +375,8 @@ const (
 	KMSEncryption ActionType = "KMSEncryption"
 	// Can be used to perform session type specific actions.
 	SessionType ActionType = "SessionType"
+	// SecureSession is used to initiate a "zero trust" secure session.
+	SecureSession ActionType = "SecureSession"
 )
 
 type ActionStatus int
@@ -379,18 +403,154 @@ type SessionTypeRequest struct {
 	Properties  interface{} `json:"Properties"`
 }
 
+// SignAgentSharePayload is the payload sent by the agent to KMS for signing
+type SignAgentSharePayload struct {
+	// AgentShare is the public portion of the agent's secret share.
+	AgentShare string `json:"AgentShare"`
+	// ID of the client to which the agent intends to talk
+	ClientId string `json:"ClientId"`
+	// ID of the log reader
+	LogReaderId string `json:"LogReaderId"`
+}
+
+/*@
+pred (signAgentSharePayload *SignAgentSharePayload) Mem() {
+	acc(signAgentSharePayload)
+}
+@*/
+
+// SecureSessionRequest is sent by the agent to the client to initiate a secure session.
+type SecureSessionRequest struct {
+	// Version is the version of the protocol we are using.
+	Version int `json:"Version"`
+	// ShareAlgorithm is the share method for the handshake.
+	// If the agent doesn't support this, it will send a "share algorithm not supported" error in response.
+	ShareAlgorithm string `json:"ShareAlgorithm"`
+	// AgentShare is the public portion of the agent's secret share.
+	AgentShare string `json:"AgentShare"`
+	// Signature is the signature for the AgentShare. This field is only required when signing a request via KMS.
+	Signature string `json:"Signature"`
+	// AgentLTKeyARN is Agent's long-term key ARN used to verify the signature.
+	AgentLTKeyARN string `json:"AgentLTKeyARN"`
+	// ID of the log reader
+	LogReaderId string `json:"LogReaderId"`
+}
+
+/*@
+pred (secureSessionRequest *SecureSessionRequest) Mem() {
+	acc(secureSessionRequest)
+}
+@*/
+
+// SignClientSharePayload is the payload sent by the client to KMS for signing
+type SignClientSharePayload struct {
+	// ClientShare is the public portion of the client's secret share.
+	ClientShare string `json:"AgentShare"`
+	// ID of the agent to which the agent intends to talk
+	AgentId string `json:"AgentId"`
+}
+
+/*@
+pred (signClientSharePayload *SignClientSharePayload) Mem() {
+	acc(signClientSharePayload)
+}
+@*/
+
+// SecureSessionResponse is received by the agent from the client to set up a secure session.
+type SecureSessionResponse struct {
+	// ClientShare is the public portion of the client's secret share.
+	ClientShare string `json:"ClientShare"`
+	// SessionID is the session ID. The client can compute this independently to ensure that a secret has been successfully shared.
+	SessionID      string `json:"SessionID"`
+	Signature      string `json:"Signature"`
+	ClientLTKeyARN string `json:"ClientLTKeyARN"`
+	LogLTKeyARN    string `json:"LogLTKeyARN"`
+	// EncryptedLogKey        string `json:"EncryptedLogKey"`
+	// EncryptedClientReadKey string `json:"EncryptedClientReadKey"`
+}
+
+/*@
+pred (secureSessionResponse *SecureSessionResponse) Mem() {
+	acc(secureSessionResponse)
+}
+
+ghost
+pure func (secureSessionResponse *SecureSessionResponse) Abs() by.Bytes
+@*/
+
 // Handshake payload sent by the agent to the session manager plugin
 type HandshakeRequestPayload struct {
 	AgentVersion           string                  `json:"AgentVersion"`
 	RequestedClientActions []RequestedClientAction `json:"RequestedClientActions"`
 }
 
+/*@
+pred (handshakeRequestPayload *HandshakeRequestPayload) Mem() {
+	acc(handshakeRequestPayload) &&
+	(forall i int :: { handshakeRequestPayload.RequestedClientActions[i] } 0 <= i && i < len(handshakeRequestPayload.RequestedClientActions) ==> handshakeRequestPayload.RequestedClientActions[i].Mem())
+}
+
+// ghost
+// requires acc(handshakeRequestPayload.Mem(), _)
+// pure func (handshakeRequestPayload *HandshakeRequestPayload) ContainsSecureSessionAction(secActionB by.Bytes) bool {
+// 	return unfolding acc(handshakeRequestPayload.Mem(), _) in (
+// 		(exists i int :: { handshakeRequestPayload.RequestedClientActions[i].Type() == SessionType } 0 <= i && i < len(handshakeRequestPayload.RequestedClientActions) ==> handshakeRequestPayload.RequestedClientActions[i].Type() == SessionType) &&
+// 		(exists i int :: { handshakeRequestPayload.RequestedClientActions[i].Type() == SecureSession } 0 <= i && i < len(handshakeRequestPayload.RequestedClientActions) ==> handshakeRequestPayload.RequestedClientActions[i].Type() == SecureSession && handshakeRequestPayload.RequestedClientActions[i].Abs() == secActionB))
+// }
+
+// this pure function aids verification as no existential quantifiers are used
+// it's less generic but sufficient as the agent adheres to the specified order of
+// actions.
+ghost
+requires acc(handshakeRequestPayload.Mem(), _)
+pure func (handshakeRequestPayload *HandshakeRequestPayload) ContainsSecureSessionAction(secActionB by.Bytes) bool {
+	return unfolding acc(handshakeRequestPayload.Mem(), _) in (
+		2 <= len(handshakeRequestPayload.RequestedClientActions) &&
+		handshakeRequestPayload.RequestedClientActions[0].Type() == SessionType &&
+		handshakeRequestPayload.RequestedClientActions[1].Type() == SecureSession &&
+		handshakeRequestPayload.RequestedClientActions[1].Abs() == secActionB)
+}
+
+// returns the abstract byte representation of this handshake request IF it is marshaled as JSON
+ghost
+requires acc(handshakeRequestPayload.Mem(), _)
+requires handshakeRequestPayload.ContainsSecureSessionAction(secActionB)
+pure func (handshakeRequestPayload *HandshakeRequestPayload) Abs(secActionB by.Bytes) by.Bytes {
+	// return by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionRequest_pub())), secActionB)
+	return secActionB
+}
+@*/
+
 // An action requested by the agent to the plugin
 type RequestedClientAction struct {
 	ActionType       ActionType  `json:"ActionType"`
 	ActionParameters interface{} `json:"ActionParameters"`
 }
 
+/*@
+pred (action *RequestedClientAction) Mem() {
+	acc(action) &&
+	(action.ActionType == SecureSession ==> typeOf(action.ActionParameters) == SecureSessionRequest)
+}
+
+ghost
+requires acc(action.Mem(), _)
+pure func (action *RequestedClientAction) Type() ActionType {
+	return unfolding acc(action.Mem(), _) in action.ActionType
+}
+
+ghost
+requires acc(action.Mem(), _)
+requires unfolding acc(action.Mem(), _) in action.ActionType == SecureSession
+pure func (action *RequestedClientAction) Abs() by.Bytes {
+	return unfolding acc(action.Mem(), _) in by.tuple4B(
+		by.msgB(action.ActionParameters.(SecureSessionRequest).AgentShare),
+		by.msgB(action.ActionParameters.(SecureSessionRequest).Signature),
+		by.msgB(action.ActionParameters.(SecureSessionRequest).AgentLTKeyARN),
+		by.msgB(action.ActionParameters.(SecureSessionRequest).LogReaderId))
+}
+@*/
+
 // The result of processing the action by the plugin
 type ProcessedClientAction struct {
 	ActionType   ActionType      `json:"ActionType"`
@@ -399,6 +559,58 @@ type ProcessedClientAction struct {
 	Error        string          `json:"Error"`
 }
 
+/*@
+type ProcessedClientActionAdt adt {
+	Action {
+		ActionType ActionType
+		ActionStatus ActionStatus
+	}
+}
+
+pred (processedClientAction *ProcessedClientAction) Mem() {
+	acc(processedClientAction) &&
+	acc(bytes.SliceMem(processedClientAction.ActionResult))
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Type() ActionType {
+	return unfolding acc(processedClientAction.Mem(), _) in processedClientAction.ActionType
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Status() ActionStatus {
+	return unfolding acc(processedClientAction.Mem(), _) in processedClientAction.ActionStatus
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) IsSuccessfulSecureSession() bool {
+	return processedClientAction.Type() == SecureSession &&
+		processedClientAction.Status() == Success
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Abs() by.Bytes {
+	return unfolding acc(processedClientAction.Mem(), _) in
+		abs.Abs(processedClientAction.ActionResult)
+}
+// pair(exp(pubTerm(const_g_pub()), z), pair(SigY, pair(ClientLtKeyId, hash(exp(exp(pubTerm(const_g_pub()), z), x)))))))
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Adt() ProcessedClientActionAdt {
+	return Action{processedClientAction.Type(), processedClientAction.Status()}
+}
+@*/
+
 // Handshake Response sent by the plugin in response to the handshake request
 type HandshakeResponsePayload struct {
 	ClientVersion          string                  `json:"ClientVersion"`
@@ -406,6 +618,121 @@ type HandshakeResponsePayload struct {
 	Errors                 []string                `json:"Errors"`
 }
 
+/*@
+pred (handshakeResponsePayload *HandshakeResponsePayload) Mem() {
+	acc(handshakeResponsePayload) &&
+	(forall i int :: { handshakeResponsePayload.ProcessedClientActions[i] } 0 <= i && i < len(handshakeResponsePayload.ProcessedClientActions) ==> handshakeResponsePayload.ProcessedClientActions[i].Mem()) &&
+	acc(handshakeResponsePayload.Errors)
+}
+
+ghost
+requires acc(handshakeResponsePayload.Mem(), _)
+pure func (handshakeResponsePayload *HandshakeResponsePayload) Abs() by.Bytes {
+	return handshakeResponsePayload.ContainsSecureSession() ?
+		// see comment in `containsSecureSession` regarding this simplification
+		// (unfolding acc(handshakeResponsePayload.Mem(), _) in by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), handshakeResponsePayload.ProcessedClientActions[getSecureSessionIndex(handshakeResponsePayload.ProcessedClientActions, 0)].Abs())) :
+		(unfolding acc(handshakeResponsePayload.Mem(), _) in by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), handshakeResponsePayload.ProcessedClientActions[0].Abs())) :
+		handshakeResponsePayload.UnknownAbs()
+}
+
+// used to represent an unknown byte-level representation for a given handshake response payload
+ghost
+decreases
+requires acc(handshakeResponsePayload.Mem(), _)
+pure func (handshakeResponsePayload *HandshakeResponsePayload) UnknownAbs() by.Bytes
+
+ghost
+decreases
+requires acc(handshakeResponsePayload.Mem(), _)
+pure func (handshakeResponsePayload *HandshakeResponsePayload) ContainsSecureSession() bool {
+	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+		containsSecureSession(handshakeResponsePayload.ProcessedClientActions, 0)
+}
+
+ghost
+decreases
+requires acc(handshakeResponsePayload.Mem(), _)
+requires handshakeResponsePayload.ContainsSecureSession()
+pure func (handshakeResponsePayload *HandshakeResponsePayload) GetSecureSessionIndex() int {
+	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+		getSecureSessionIndex(handshakeResponsePayload.ProcessedClientActions, 0)
+}
+
+ghost
+requires 0 <= startIdx && startIdx <= len(actions)
+requires forall i int :: { actions[i] } startIdx <= i && i < len(actions) ==> acc(actions[i].Mem(), _)
+decreases len(actions) - startIdx
+pure func containsSecureSession(actions []ProcessedClientAction, startIdx int) bool {
+	// return startIdx == len(actions) ? false :
+	// 	(actions[startIdx].IsSuccessfulSecureSession() ?
+	// 		true : containsSecureSession(actions, startIdx + 1))
+
+	// to overcome non-termination, we simplify it as the client sends a single action
+	return len(actions) == 1 &&
+		startIdx == 0 &&
+		actions[0].IsSuccessfulSecureSession()
+}
+
+ghost
+requires 0 <= startIdx && startIdx <= len(actions)
+requires forall i int :: { actions[i] } startIdx <= i && i < len(actions) ==> acc(actions[i].Mem(), _)
+requires containsSecureSession(actions, startIdx)
+ensures  startIdx <= res && res < len(actions)
+ensures  actions[res].IsSuccessfulSecureSession()
+decreases len(actions) - startIdx
+pure func getSecureSessionIndex(actions []ProcessedClientAction, startIdx int) (res int) {
+	return actions[startIdx].IsSuccessfulSecureSession() ?
+			startIdx : getSecureSessionIndex(actions, startIdx + 1)
+}
+
+ghost
+requires acc(handshakeResponsePayload.Mem(), _)
+requires 0 <= startIdx && startIdx <= unfolding acc(handshakeResponsePayload.Mem(), _) in len(handshakeResponsePayload.ProcessedClientActions)
+decreases unfolding acc(handshakeResponsePayload.Mem(), _) in len(handshakeResponsePayload.ProcessedClientActions) - startIdx
+pure func (handshakeResponsePayload *HandshakeResponsePayload) Adt(startIdx int) (res seq[ProcessedClientActionAdt]) {
+	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+		len(handshakeResponsePayload.ProcessedClientActions) - startIdx == 0 ? seq[ProcessedClientActionAdt]{} :
+			seq[ProcessedClientActionAdt]{ handshakeResponsePayload.ProcessedClientActions[startIdx].Adt() } ++ handshakeResponsePayload.Adt(startIdx + 1)
+}
+@*/
+
+type SessionKeys struct {
+	AgentReadKey  string `json:"AgentReadKey"`
+	AgentWriteKey string `json:"AgentWriteKey"`
+}
+
+/*@
+pred (sessionKeys *SessionKeys) Mem() {
+	acc(sessionKeys)
+}
+@*/
+
+type SignSessionKeysPayload struct {
+	EncryptedSessionKeys string `json:"EncryptedSessionKeys"`
+	ClientId             string `json:"ClientId"`
+}
+
+/*@
+pred (signSessionKeysPayload *SignSessionKeysPayload) Mem() {
+	acc(signSessionKeysPayload)
+}
+@*/
+
+type EncryptedSessionKeysPayload struct {
+	// AgentLTKeyARN is Agent's long-term key ARN used to verify the signature.
+	AgentLTKeyARN        string `json:"AgentLTKeyARN"`
+	ClientId             string `json:"ClientId"`
+	EncryptedSessionKeys string `json:"EncryptedSessionKeys"`
+	Signature            string `json:"Signature"`
+}
+
+/*@
+pred (encryptedSessionKeysPayload *EncryptedSessionKeysPayload) Mem() {
+	acc(encryptedSessionKeysPayload)
+}
+*EncryptedSessionKeysPayload implements json.AnyWithMem
+@*/
+
 // This is sent by the agent as a challenge to the client. The challenge field
 // is some data that was encrypted by the agent. The client must be able to decrypt
 // this and in turn encrypt it with its own key.
@@ -427,5 +754,11 @@ type HandshakeCompletePayload struct {
 	CustomerMessage         string        `json:"CustomerMessage"`
 }
 
+/*@
+pred (handshakeCompletePayload *HandshakeCompletePayload) Mem() {
+	acc(handshakeCompletePayload)
+}
+@*/
+
 // ErrHandlerNotReady message indicates that the session plugin's incoming message handler is not ready
 var ErrHandlerNotReady = errors.New("message handler is not ready, rejecting incoming packet")
diff --git a/agent/session/crypto/kmsservice.go b/agent/session/crypto/kmsservice.go
index 8c41807dd..34a912bee 100644
--- a/agent/session/crypto/kmsservice.go
+++ b/agent/session/crypto/kmsservice.go
@@ -67,6 +67,17 @@ func NewKMSService(context context.T) (kmsService *KMSService, err error) {
 
 	return kmsService, nil
 }
+func (kmsService *KMSService) Encrypt(keyId string, plaintext []byte, encryptionContext map[string]*string) (ciphertextBlob []byte, err error) {
+	output, err := kmsService.client.Encrypt(&kms.EncryptInput{
+		KeyId:               aws.String(keyId),
+		EncryptionAlgorithm: aws.String("RSAES_OAEP_SHA_256"),
+		Plaintext:           plaintext,
+		EncryptionContext:   encryptionContext})
+	if err != nil {
+		return nil, err
+	}
+	return output.CiphertextBlob, nil
+}
 
 // Decrypt will get the plaintext key from KMS service
 func (kmsService *KMSService) Decrypt(cipherTextBlob []byte, encryptionContext map[string]*string) (plainText []byte, err error) {
@@ -78,3 +89,42 @@ func (kmsService *KMSService) Decrypt(cipherTextBlob []byte, encryptionContext m
 	}
 	return output.Plaintext, nil
 }
+
+func (kmsService *KMSService) Sign(keyID string, message []byte) ([]byte, error) {
+	res, err := kmsService.client.Sign(&kms.SignInput{
+		KeyId:            aws.String(keyID),
+		Message:          message,
+		SigningAlgorithm: aws.String("RSASSA_PSS_SHA_384"),
+	})
+	if err != nil {
+		return nil, fmt.Errorf("failed to sign message: %v", err)
+	}
+
+	return res.Signature, nil
+}
+
+func (kmsService *KMSService) Verify(kmsKeyId string, message []byte, signature []byte) (bool, error) {
+	out, err := kmsService.client.Verify(&kms.VerifyInput{
+		KeyId:            aws.String(kmsKeyId),
+		Message:          message,
+		Signature:        signature,
+		SigningAlgorithm: aws.String("RSASSA_PSS_SHA_384"),
+	})
+	if err != nil {
+		return false, err
+	}
+
+	return *out.SignatureValid, nil
+}
+
+func (kmsService *KMSService) CreateKeyAssymetric() (*kms.KeyMetadata, error) {
+	out, err := kmsService.client.CreateKey(&kms.CreateKeyInput{
+		KeySpec:  aws.String("ECC_NIST_P384"),
+		KeyUsage: aws.String("SIGN_VERIFY"),
+	})
+	if err != nil {
+		return nil, err
+	}
+
+	return out.KeyMetadata, nil
+}
diff --git a/agent/session/datachannel/cryptolib/cryptolib.go b/agent/session/datachannel/cryptolib/cryptolib.go
new file mode 100644
index 000000000..ab96ff5bb
--- /dev/null
+++ b/agent/session/datachannel/cryptolib/cryptolib.go
@@ -0,0 +1,217 @@
+package cryptolib
+
+import (
+	"crypto/aes"
+	"crypto/cipher"
+	cryptoRand "crypto/rand"
+	"fmt"
+	"io"
+
+	logger "github.com/aws/amazon-ssm-agent/agent/log"
+	//@ "bytes"
+	//@ abs "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+	//@ by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+	//@ tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+)
+
+type BlockCipherT struct {
+	ready            bool
+	cipherTextKey    []byte
+	encryptionKey    []byte
+	decryptionKey    []byte
+	encryptionCipher cipher.AEAD
+	decryptionCipher cipher.AEAD
+}
+
+/*@
+pred (bc *BlockCipherT) Mem() {
+	acc(bc) &&
+	bc.EncKeyTMem() &&
+	bc.DecKeyTMem() &&
+	(bc.ready ==>
+		bytes.SliceMem(bc.cipherTextKey) &&
+		bytes.SliceMem(bc.encryptionKey) &&
+		by.gamma(bc.getEncKeyT()) == abs.Abs(bc.encryptionKey) &&
+		bytes.SliceMem(bc.decryptionKey) &&
+		by.gamma(bc.getDecKeyT()) == abs.Abs(bc.decryptionKey) &&
+		bc.encryptionCipher.Mem() &&
+		bc.decryptionCipher.Mem())
+}
+
+pred (bc *BlockCipherT) EncKeyTMem()
+
+ghost
+requires acc(bc.EncKeyTMem(), _)
+pure func (bc *BlockCipherT) getEncKeyT() tm.Term
+
+ghost
+requires acc(bc.Mem(), _)
+ensures  bc.IsReady() ==> by.gamma(res) == bc.GetEncKeyB()
+pure func (bc *BlockCipherT) GetEncKeyT() (res tm.Term) {
+	return unfolding acc(bc.Mem(), _) in bc.getEncKeyT()
+}
+
+ghost
+requires acc(bc.Mem(), _) && bc.IsReady()
+pure func (bc *BlockCipherT) GetEncKeyB() by.Bytes {
+	return unfolding acc(bc.Mem(), _) in abs.Abs(bc.encryptionKey)
+}
+
+ghost
+preserves bc.EncKeyTMem()
+ensures bc.getEncKeyT() == encKeyT
+func (bc *BlockCipherT) setEncKeyT(encKeyT tm.Term)
+
+pred (bc *BlockCipherT) DecKeyTMem()
+
+ghost
+requires acc(bc.DecKeyTMem(), _)
+pure func (bc *BlockCipherT) getDecKeyT() tm.Term
+
+ghost
+requires acc(bc.Mem(), _)
+pure func (bc *BlockCipherT) GetDecKeyT() tm.Term {
+	return unfolding acc(bc.Mem(), _) in bc.getDecKeyT()
+}
+
+ghost
+preserves bc.DecKeyTMem()
+ensures bc.getDecKeyT() == decKeyT
+func (bc *BlockCipherT) setDecKeyT(decKeyT tm.Term)
+@*/
+
+// @ requires acc(bc.Mem(), _)
+// @ pure
+func (bc *BlockCipherT) IsReady() bool {
+	return /*@ unfolding acc(bc.Mem(), _) in @*/ bc.ready
+}
+
+// @ trusted
+// @ requires noPerm < p
+// @ requires bc.Mem() && acc(log.Mem(), _) && acc(bytes.SliceMem(readKey), p) && acc(bytes.SliceMem(writeKey), p)
+// @ requires by.gamma(readKeyT) == abs.Abs(readKey) && by.gamma(writeKeyT) == abs.Abs(writeKey)
+// @ ensures  bc.Mem() && acc(log.Mem(), _) && acc(bytes.SliceMem(readKey), p) && acc(bytes.SliceMem(writeKey), p)
+// @ ensures  err == nil ==> bc.IsReady() && bc.GetEncKeyT() == writeKeyT && bc.GetDecKeyT() == readKeyT
+// @ ensures  err != nil ==> err.ErrorMem()
+func (bc *BlockCipherT) UpdateEncryptionKeys(log logger.T, readKey, writeKey []byte /*@, ghost p perm, ghost readKeyT tm.Term, ghost writeKeyT tm.Term @*/) (err error) {
+	if len(readKey) != 32 || len(writeKey) != 32 {
+		return fmt.Errorf("read or write key have invalid length")
+	}
+	newEncryptionKey := make([]byte, 2*32)
+	copy(newEncryptionKey[:32], readKey)
+	copy(newEncryptionKey[32:], writeKey)
+	return bc.UpdateEncryptionKey(log, newEncryptionKey, "", "" /*@, p @*/)
+}
+
+// @ trusted
+// @ requires noPerm < p
+// @ requires acc(bytes.SliceMem(cipherTextBlob), p)
+// @ preserves bc.Mem() && acc(log.Mem(), _)
+// @ ensures err != nil ==> err.ErrorMem()
+func (bc *BlockCipherT) UpdateEncryptionKey(log logger.T, cipherTextBlob []byte, _, _ string /*@, ghost p perm @*/) (err error) {
+	const keyLen = 32 // key length in bytes
+	bc.cipherTextKey = cipherTextBlob
+	bc.decryptionKey = cipherTextBlob[:keyLen]
+	bc.encryptionKey = cipherTextBlob[keyLen:]
+	log.Debugf("ENCRYPTION KEY: %x", bc.encryptionKey)
+	log.Debugf("DECRYPTION KEY: %x", bc.decryptionKey)
+	enc, err := getAEAD(bc.encryptionKey)
+	bc.encryptionCipher = enc
+	if err != nil {
+		return fmt.Errorf("failed to get encryption cipher: %v", err)
+	}
+	dec, err := getAEAD(bc.decryptionKey)
+	bc.decryptionCipher = dec
+	if err != nil {
+		return fmt.Errorf("failed to get decryption cipher: %v", err)
+	}
+
+	return nil
+}
+
+const nonceSize = 12
+
+// EncryptWithGCM encrypts plain text using AES block cipher GCM mode
+// @ trusted
+// @ requires noPerm < p
+// @ requires acc(blockCipher.Mem(), p) && blockCipher.IsReady()
+// @ preserves acc(bytes.SliceMem(plainText), p)
+// @ ensures  acc(blockCipher.Mem(), p) && blockCipher.IsReady()
+// @ ensures  err == nil ==> bytes.SliceMem(cipherText)
+// @ ensures  err != nil ==> err.ErrorMem()
+// @ ensures  err == nil ==> abs.Abs(cipherText) == by.sencB(abs.Abs(plainText), blockCipher.GetEncKeyB())
+func (blockCipher *BlockCipherT) EncryptWithAESGCM(plainText []byte /*@, ghost p perm @*/) (cipherText []byte, err error) {
+	var aesgcm = blockCipher.encryptionCipher
+
+	cipherText = make([]byte, nonceSize+len(plainText))
+	nonce := make([]byte, nonceSize)
+	if _, err := io.ReadFull(cryptoRand.Reader, nonce); err != nil {
+		return nil, fmt.Errorf("failed to generate nonce for encryption: %v", err)
+	}
+
+	// Encrypt plain text using given key and newly generated nonce
+	cipherTextWithoutNonce := aesgcm.Seal(nil, nonce, plainText, nil)
+
+	// Append nonce to the beginning of the cipher text to be used while decrypting
+	cipherText = append(cipherText[:nonceSize], nonce...)
+	cipherText = append(cipherText[nonceSize:], cipherTextWithoutNonce...)
+	return cipherText, nil
+}
+
+// DecryptWithGCM decrypts cipher text using AES block cipher GCM mode
+// @ trusted
+// @ requires noPerm < p
+// @ requires acc(blockCipher.Mem(), p) && blockCipher.IsReady()
+// @ preserves acc(bytes.SliceMem(cipherText), p)
+// @ ensures  acc(blockCipher.Mem(), p)
+// @ ensures err == nil ==> bytes.SliceMem(plainText)
+// @ ensures err != nil ==> err.ErrorMem()
+func (blockCipher *BlockCipherT) DecryptWithAESGCM(cipherText []byte /*@, ghost p perm @*/) (plainText []byte, err error) {
+	var aesgcm = blockCipher.decryptionCipher
+
+	// Pull the nonce out of the cipherText
+	nonce := cipherText[:nonceSize]
+	cipherTextWithoutNonce := cipherText[nonceSize:]
+
+	// Decrypt just the actual cipherText using nonce extracted above
+	if plainText, err = aesgcm.Open(nil, nonce, cipherTextWithoutNonce, nil); err != nil {
+		return nil, fmt.Errorf("failed to decrypt encrypted text: %v", err)
+	}
+	return plainText, nil
+}
+
+// GetCipherTextKey returns cipherTextKey from BlockCipher
+// @ requires false
+func (blockCipher *BlockCipherT) GetCipherTextKey() []byte {
+	return blockCipher.cipherTextKey
+}
+
+// GetKMSKeyId returns kmsKeyId from BlockCipher
+func (blockCipher *BlockCipherT) GetKMSKeyId() string {
+	return ""
+}
+
+// getAEAD gets AEAD which is a GCM cipher mode providing authenticated encryption with associated data
+// @ trusted
+// @ requires noPerm < p
+// @ preserves acc(bytes.SliceMem(plainTextKey), p)
+// @ ensures err == nil ==> aesgcm.Mem()
+func getAEAD(plainTextKey []byte /*@, ghost p perm @*/) (aesgcm cipher.AEAD, err error) {
+	var block cipher.Block
+	if block, err = aes.NewCipher(plainTextKey); err != nil {
+		return nil, fmt.Errorf("error creating NewCipher, %v", err)
+	}
+
+	if aesgcm, err = cipher.NewGCM(block); err != nil {
+		return nil, fmt.Errorf("error creating NewGCM, %v", err)
+	}
+
+	return aesgcm, nil
+}
+
+// TODO what does this do?
+// var _ crypto.IBlockCipher = (*BlockCipherT)(nil)
+
+// var newBlockCipher = func(context contextPkg.T, kmsKeyId string) (blockCipher crypto.IBlockCipher, err error) {
+// 	return crypto.NewBlockCipher(context, kmsKeyId)
+// }
diff --git a/agent/session/datachannel/datachannel.go b/agent/session/datachannel/datachannel.go
index fa9971e3d..bc2677dac 100644
--- a/agent/session/datachannel/datachannel.go
+++ b/agent/session/datachannel/datachannel.go
@@ -14,33 +14,43 @@
 // Package datachannel implements data channel which is used to interactively run commands.
 package datachannel
 
+// work arounds to make verification possible
+// - magic wands for receiving messages via callbacks instead of by calling a particular receive method
+// - ghost fields to simplify keeping track of abstract terms
+// - ghost lock to enable concurrently sending and receiving messages by assuming atomicity of these operations
+
 import (
 	"bytes"
-	"container/list"
+	"crypto/elliptic"
 	cryptoRand "crypto/rand"
+	"crypto/rsa"
+	"crypto/sha512"
+	"encoding/base64"
 	"encoding/json"
 	"errors"
 	"fmt"
-	"math"
-	"math/rand"
-	"runtime/debug"
-	"sync"
 	"time"
 
-	"github.com/aws/amazon-ssm-agent/agent/context"
-	"github.com/aws/amazon-ssm-agent/agent/log"
-	"github.com/aws/amazon-ssm-agent/agent/session/communicator"
-	mgsConfig "github.com/aws/amazon-ssm-agent/agent/session/config"
+	contextPkg "github.com/aws/amazon-ssm-agent/agent/context"
+	logger "github.com/aws/amazon-ssm-agent/agent/log"
 	mgsContracts "github.com/aws/amazon-ssm-agent/agent/session/contracts"
 	"github.com/aws/amazon-ssm-agent/agent/session/crypto"
-	"github.com/aws/amazon-ssm-agent/agent/session/retry"
-	"github.com/aws/amazon-ssm-agent/agent/session/service"
+	"github.com/aws/amazon-ssm-agent/agent/session/datachannel/cryptolib"
+	"github.com/aws/amazon-ssm-agent/agent/session/datastream"
 	"github.com/aws/amazon-ssm-agent/agent/task"
 	"github.com/aws/amazon-ssm-agent/agent/version"
 	"github.com/aws/amazon-ssm-agent/agent/versionutil"
-	"github.com/aws/aws-sdk-go/aws"
-	"github.com/gorilla/websocket"
-	"github.com/twinj/uuid"
+	"github.com/aws/aws-sdk-go/service/kms"
+	"golang.org/x/crypto/hkdf"
+	//@ abs "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+	//@ arb "github.com/aws/amazon-ssm-agent/agent/iospecs/arb"
+	//@ by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+	//@ cl "github.com/aws/amazon-ssm-agent/agent/iospecs/claim"
+	//@ ft "github.com/aws/amazon-ssm-agent/agent/iospecs/fact"
+	//@ "github.com/aws/amazon-ssm-agent/agent/iospecs/iospec"
+	//@ pl "github.com/aws/amazon-ssm-agent/agent/iospecs/place"
+	//@ pub "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+	//@ tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
 )
 
 const (
@@ -48,110 +58,162 @@ const (
 	sequenceNumber = 0
 	messageFlags   = 3
 	// Timeout period before a handshake operation expires on the agent.
-	handshakeTimeout                        = 15 * time.Second
+	handshakeTimeout                        = 1500 * time.Second
 	clientVersionWithoutOutputSeparation    = "1.2.295"
 	firstVersionWithOutputSeparationFeature = "1.2.312.0"
+	channelStatusTimeout                    = 150 * time.Millisecond
 )
 
+/*@
+// since Gobra is struggling with generating a refinement proof of the interface
+// if quantified permissions appear in specification, we wrap these permissions in
+// the following two predicates:
+pred SendStreamDataMessageWand(t pl.Place, rid tm.Term, inputData []byte, inputDataT tm.Term, p perm) {
+	noPerm < p && p <= writePerm &&
+	(pl.token(t) && iospec.e_InFact(t, rid)) --* (acc(bytes.SliceMem(inputData), p) && by.gamma(inputDataT) == abs.Abs(inputData) && inputDataT == old[#lhs](iospec.get_e_InFact_r1(t, rid)) && pl.token(old[#lhs](iospec.get_e_InFact_placeDst(t, rid))))
+}
+
+pred QuantifiedSendStreamDataMessageWand(inputData []byte, inputDataT tm.Term, p perm) {
+	forall t pl.Place, rid tm.Term :: { SendStreamDataMessageWand(t, rid, inputData, inputDataT, p) } SendStreamDataMessageWand(t, rid, inputData, inputDataT, p)
+}
+@*/
+
 type IDataChannel interface {
-	Initialize(context context.T, mgsService service.Service, sessionId string, clientId string, instanceId string, role string, cancelFlag task.CancelFlag, inputStreamMessageHandler InputStreamMessageHandler)
-	SetWebSocket(context context.T, mgsService service.Service, sessionId string, clientId string, onMessageHandler func(input []byte)) error
-	Open(log log.T) error
-	Close(log log.T) error
-	Reconnect(log log.T) error
-	SendMessage(log log.T, input []byte, inputType int) error
-	SendStreamDataMessage(log log.T, dataType mgsContracts.PayloadType, inputData []byte) error
-	ResendStreamDataMessageScheduler(log log.T) error
-	ProcessAcknowledgedMessage(log log.T, acknowledgeMessageContent mgsContracts.AcknowledgeContent)
-	SendAcknowledgeMessage(log log.T, agentMessage mgsContracts.AgentMessage) error
-	SendAgentSessionStateMessage(log log.T, sessionStatus mgsContracts.SessionStatus) error
-	AddDataToOutgoingMessageBuffer(streamMessage StreamingMessage)
-	RemoveDataFromOutgoingMessageBuffer(streamMessageElement *list.Element)
-	AddDataToIncomingMessageBuffer(streamMessage StreamingMessage)
-	RemoveDataFromIncomingMessageBuffer(sequenceNumber int64)
-	SkipHandshake(log log.T)
-	PerformHandshake(log log.T, kmsKeyId string, encryptionEnabled bool, sessionTypeRequest mgsContracts.SessionTypeRequest) (err error)
-	GetClientVersion() string
-	GetInstanceId() string
-	GetRegion() string
-	IsActive() bool
-	PrepareToCloseChannel(log log.T)
-	GetSeparateOutputPayload() bool
-	SetSeparateOutputPayload(separateOutputPayload bool)
-}
-
-// DataChannel used for session communication between the message gateway service and the agent.
-type DataChannel struct {
-	wsChannel  communicator.IWebSocketChannel
-	context    context.T
-	Service    service.Service
-	ChannelId  string
-	ClientId   string
-	InstanceId string
-	Role       string
-	Pause      bool
-	//records sequence number of last acknowledged message received over data channel
-	ExpectedSequenceNumber int64
-	//records sequence number of last stream data message sent over data channel
-	StreamDataSequenceNumber int64
-	//ensure only one goroutine sending message with current StreamDataSequenceNumber in data channel
-	//check carefully for deadlock when not reusing of SendStreamDataMessage
-	StreamDataSequenceNumberMutex *sync.Mutex
-	//buffer to store outgoing stream messages until acknowledged
-	//using linked list for this buffer as access to oldest message is required and it support faster deletion from any position of list
-	OutgoingMessageBuffer ListMessageBuffer
-	//buffer to store incoming stream messages if received out of sequence
-	//using map for this buffer as incoming messages can be out of order and retrieval would be faster by sequenceId
-	IncomingMessageBuffer MapMessageBuffer
-	//round trip time of latest acknowledged message
-	RoundTripTime float64
-	//round trip time variation of latest acknowledged message
-	RoundTripTimeVariation float64
-	//timeout used for resending unacknowledged message
-	RetransmissionTimeout time.Duration
-	//cancelFlag is used for passing cancel signal to plugin in when channel_closed message is received over data channel
-	cancelFlag task.CancelFlag
+
+	//@ pred Mem()
+
+	//@ requires log != nil
+	// @ requires QuantifiedSendStreamDataMessageWand(inputData, inputDataT, p)
+	// @ preserves Mem()
+	// @ preserves acc(log.Mem(), _)
+	SendStreamDataMessage(log logger.T, dataType mgsContracts.PayloadType, inputData []byte /*@, ghost p perm, ghost inputDataT tm.Term @*/) error
+
+	// @ requires log != nil
+	// @ preserves Mem() && acc(log.Mem(), _)
+	SendAgentSessionStateMessage(log logger.T, sessionStatus mgsContracts.SessionStatus) error
+
+	// @ requires log != nil
+	// @ preserves Mem() && acc(log.Mem(), _)
+	SkipHandshake(log logger.T) error
+
+	// @ requires log != nil
+	// @ requires encryptionEnabled == assumeEncryptionEnabledForVerification()
+	// @ preserves Mem() && acc(log.Mem(), _)
+	PerformHandshake(log logger.T, kmsKeyId string, encryptionEnabled bool, sessionTypeRequest mgsContracts.SessionTypeRequest) (err error)
+
+	// @ requires noPerm < p
+	// @ preserves acc(Mem(), p)
+	GetClientVersion( /*@ ghost p perm @*/ ) (string, error)
+
+	// @ requires noPerm < p
+	// @ preserves acc(Mem(), p)
+	GetInstanceId( /*@ ghost p perm @*/ ) (string, error)
+
+	// @ requires noPerm < p
+	// @ preserves acc(Mem(), p)
+	GetRegion( /*@ ghost p perm @*/ ) (string, error)
+
+	// @ requires noPerm < p
+	// @ preserves acc(Mem(), p)
+	IsActive( /*@ ghost p perm @*/ ) (bool, error)
+
+	// @ requires noPerm < p
+	// @ preserves acc(Mem(), p)
+	GetSeparateOutputPayload( /*@ ghost p perm @*/ ) (bool, error)
+
+	// @ preserves Mem()
+	SetSeparateOutputPayload(separateOutputPayload bool) error
+
+	// @ requires log != nil
+	// @ preserves Mem() && acc(log.Mem(), _)
+	PrepareToCloseChannel(log logger.T) error
+
+	// @ requires log != nil
+	// @ preserves Mem() && acc(log.Mem(), _)
+	Close(log logger.T) error
+}
+
+// instruct Gobra to prove that DataChannel is a behavioral subtype of IDataChannel:
+/* TODO remove impl proof but leave implements clause
+(* dataChannel) implements IDataChannel {
+	(dc *dataChannel) SendStreamDataMessage(log logger.T, dataType mgsContracts.PayloadType, inputData []byte, ghost p perm, ghost inputDataT tm.Term) error {
+		// assert (forall t pl.Place, rid tm.Term :: (pl.token(t) && iospec.e_InFact(t, rid)) --* (acc(bytes.SliceMem(inputData), p) && by.gamma(inputDataT) == abs.Abs(inputData) && pl.token(old[#lhs](iospec.get_e_InFact_placeDst(t, rid)))))
+		unfold SendStreamDataMessageWand(t, rid, inputData, inputDataT, p)
+		return dc.SendStreamDataMessage(log, dataType, inputData, p, inputDataT)
+	}
+}
+*/
+
+type DataChannelState int
+
+const (
+	Erroneous                   DataChannelState = 0
+	Uninitialized               DataChannelState = 1
+	Initialized                 DataChannelState = 2
+	HandshakeSkipped            DataChannelState = 3
+	BlockCipherInitialized      DataChannelState = 4
+	AgentSecretCreatedAndSigned DataChannelState = 5
+	HandshakeRequestSent        DataChannelState = 6
+	BlockCipherReady            DataChannelState = 7
+	HandshakeCompleted          DataChannelState = 8
+)
+
+// dataChannel used for session communication between the message gateway service and the agent.
+type dataChannel struct {
+	//dataChannelState keeps track of the data channel's state such that calls violating the implicit state machine transitions can be rejected
+	dataChannelState DataChannelState
+	//dataStream handles low-level communication incl. retransmitting and acknowledging messages
+	dataStream *datastream.DataStream
 	//inputStreamMessageHandler is responsible for handling plugin specific input_stream_data message
-	inputStreamMessageHandler func(log log.T, streamDataMessage mgsContracts.AgentMessage) error
-	//handshake captures handshake state and error
-	handshake Handshake
+	inputStreamMessageHandler InputStreamMessageHandler
+	//hs captures handshake state and error
+	hs handshake
 	//blockCipher stores encrytion keys and provides interface for encryption/decryption functions
-	blockCipher crypto.IBlockCipher
+	blockCipher *cryptolib.BlockCipherT
 	// Indicates whether encryption was enabled
 	encryptionEnabled     bool
 	separateOutputPayload bool
+	state                 agentHandshakeState
+	// agentLTKeyARN is the ARN for the KMS long-term-key used to sign and verify the handshake
+	agentLTKeyARN string
+	logReaderId   string
+	logLTPk       *rsa.PublicKey
+	/*@ msgHandlerCtx StreamDataHandlerContext @*/ // TODO: mark this as ghost as soon as Gobra supports ghost fields
 }
 
-type ListMessageBuffer struct {
-	Messages *list.List
-	Capacity int
-	Mutex    *sync.Mutex
+// AgentHandshakeState represents the state of the handshake.
+type agentHandshakeState struct {
+	// kmsService is the KMS service used to sign and verify the handshake keyshare
+	kmsService    *crypto.KMSService
+	agentSecret   []byte
+	sharedSecret  []byte
+	sessionID     []byte
+	agentWriteKey []byte
+	agentReadKey  []byte
 }
 
-type MapMessageBuffer struct {
-	Messages map[int64]StreamingMessage
-	Capacity int
-	Mutex    *sync.Mutex
-}
+type InputStreamMessageHandler = func(log logger.T, streamDataMessage *mgsContracts.AgentMessage) error
 
-type StreamingMessage struct {
-	Content        []byte
-	SequenceNumber int64
-	LastSentTime   time.Time
+type MessageReceptionStatus int
+type MessageReceptionPayload struct {
+	status MessageReceptionStatus
+	data   interface{}
 }
 
-type InputStreamMessageHandler func(log log.T, streamDataMessage mgsContracts.AgentMessage) error
+const (
+	ReceiveHandshakeResponeEncryptionEnabled  MessageReceptionStatus = 1
+	ReceiveHandshakeResponeEncryptionDisabled MessageReceptionStatus = 2
+	ReceiveOtherResponse                      MessageReceptionStatus = 3
+)
 
-type Handshake struct {
+type handshake struct {
 	// Version of the client
 	clientVersion string
+	// Channel used to signal that a message is to be expected
+	startReceivingChan chan MessageReceptionPayload
 	// Channel used to signal when handshake response is received
 	responseChan chan bool
-	// Random byte string used to verify encryption
-	encryptionChallenge []byte
-	// This indicates encryption was validated using encryption challenge exchange
-	encryptionConfirmedChan chan bool
-	error                   error
+	error        error
 	// Indicates handshake is complete (Handshake Complete message sent to client)
 	complete bool
 	// Indiciates if handshake has been skipped
@@ -160,1024 +222,2343 @@ type Handshake struct {
 	handshakeEndTime   time.Time
 }
 
-// NewDataChannel constructs datachannel objects.
-func NewDataChannel(context context.T,
-	channelId string,
-	clientId string,
-	inputStreamMessageHandler InputStreamMessageHandler,
-	cancelFlag task.CancelFlag) (*DataChannel, error) {
-
-	log := context.Log()
-	identity := context.Identity()
-	appConfig := context.AppConfig()
+// @ requires acc(dc.Mem(), _)
+// @ pure
+func (dc *dataChannel) getState() DataChannelState {
+	return /*@ unfolding acc(dc.Mem(), _) in @*/ dc.dataChannelState
+}
 
-	messageGatewayServiceConfig := appConfig.Mgs
-	if messageGatewayServiceConfig.Region == "" {
-		fetchedRegion, err := identity.Region()
-		if err != nil {
-			return nil, fmt.Errorf("failed to get region with error: %s", err)
-		}
-		messageGatewayServiceConfig.Region = fetchedRegion
-	}
+/*@
+type StreamDataHandlerContext interface {
+	pred Inv()
+}
 
-	if messageGatewayServiceConfig.Endpoint == "" {
-		fetchedEndpoint, err := getMgsEndpoint(context, messageGatewayServiceConfig.Region)
-		if err != nil {
-			return nil, fmt.Errorf("failed to get MessageGatewayService endpoint with error: %s", err)
-		}
-		messageGatewayServiceConfig.Endpoint = fetchedEndpoint
-	}
+ghost
+requires ctx != nil && log != nil
+preserves ctx.Inv() && acc(log.Mem(), _)
+ensures err != nil ==> err.ErrorMem()
+func StreamDataHandlerSpec(ghost ctx StreamDataHandlerContext, log logger.T, agentMessage *mgsContracts.AgentMessage) (err error)
+
+pred (dc *dataChannel) RecvRoutineMem() {
+	dc != nil &&
+	acc(&dc.inputStreamMessageHandler) &&
+	acc(&dc.msgHandlerCtx) &&
+	dc.msgHandlerCtx != nil && dc.msgHandlerCtx.Inv() &&
+	dc.inputStreamMessageHandler implements StreamDataHandlerSpec{dc.msgHandlerCtx} &&
+	acc(&dc.hs.startReceivingChan, _) &&
+	acc(dc.hs.startReceivingChan.RecvChannel(), _) &&
+	dc.hs.startReceivingChan.RecvGivenPerm() == PredTrue!<!> &&
+	dc.hs.startReceivingChan.RecvGotPerm() == StartReceivingChanInv!<dc, _!> &&
+	acc(&dc.hs.responseChan, _) &&
+	acc(dc.hs.responseChan.SendChannel(), _) &&
+	dc.hs.responseChan.SendGivenPerm() == ResponseChanInv!<dc, _!> &&
+	dc.hs.responseChan.SendGotPerm() == PredTrue!<!>
+}
 
-	connectionTimeout := time.Duration(messageGatewayServiceConfig.StopTimeoutMillis) * time.Millisecond
-	mgsService := service.NewService(context, messageGatewayServiceConfig, connectionTimeout)
+// permissions in `RecvRoutineMem` are already subtracted:
+pred (dc *dataChannel) Mem() {
+	dc != nil &&
+	acc(&dc.dataChannelState) &&
+	acc(&dc.hs.startReceivingChan, _) &&
+	acc(&dc.hs.responseChan, _) &&
+	(dc.dataChannelState != Erroneous ==>
+		acc(&dc.dataStream) &&
+		acc(&dc.hs.clientVersion) &&
+		acc(&dc.hs.error) &&
+		acc(&dc.hs.complete) &&
+		acc(&dc.hs.skipped) &&
+		acc(&dc.hs.handshakeStartTime) &&
+		acc(&dc.hs.handshakeEndTime) &&
+		acc(&dc.blockCipher) &&
+		acc(&dc.encryptionEnabled) &&
+		acc(&dc.separateOutputPayload) &&
+		acc(&dc.state) &&
+		acc(&dc.agentLTKeyARN) &&
+		acc(&dc.logReaderId) &&
+		acc(&dc.logLTPk)) &&
+	(dc.dataChannelState >= Initialized ==>
+		dc.dataStream.Mem() &&
+		dc.state.kmsService.Mem() &&
+		dc.logLTPk.Mem() &&
+		dc.IoSpecMem() &&
+		pl.token(dc.getToken()) &&
+		iospec.P_Agent(dc.getToken(), dc.getRid(), dc.getAbsState()) &&
+		tm.pubTerm(pub.pub_msg(dc.dataStream.GetClientId())) == dc.getClientIdT() &&
+		tm.pubTerm(pub.pub_msg(dc.logReaderId)) == dc.getReaderIdT()) &&
+	acc(dc.hs.startReceivingChan.SendChannel(), _) &&
+	dc.hs.startReceivingChan.SendGivenPerm() == StartReceivingChanInv!<dc, _!> &&
+	dc.hs.startReceivingChan.SendGotPerm() == PredTrue!<!> &&
+	acc(dc.hs.responseChan.RecvChannel(), _) &&
+	dc.hs.responseChan.RecvGivenPerm() == PredTrue!<!> &&
+	dc.hs.responseChan.RecvGotPerm() == ResponseChanInv!<dc, _!> &&
+	(dc.dataChannelState == Initialized ==>
+		!dc.hs.skipped) &&
+	(dc.dataChannelState == HandshakeSkipped ==>
+		dc.hs.skipped) &&
+	(dc.dataChannelState >= BlockCipherInitialized ==>
+		!dc.hs.skipped &&
+		dc.encryptionEnabled == assumeEncryptionEnabledForVerification() &&
+		dc.blockCipher != nil && dc.blockCipher.Mem()) &&
+	(dc.dataChannelState >= AgentSecretCreatedAndSigned && dc.dataChannelState < HandshakeCompleted ==>
+		bytes.SliceMem(dc.state.agentSecret)) &&
+	(dc.dataChannelState >= BlockCipherReady ==>
+		(dc.encryptionEnabled ==> dc.blockCipher.IsReady())) &&
+	(dc.dataChannelState >= HandshakeCompleted ==>
+		exists AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey tm.Term :: ft.St_Agent_10(dc.getRid(), AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) in dc.getAbsState() && tm.kdf1(tm.exp(Y, x)) == dc.blockCipher.GetEncKeyT()) &&
+	// relate state to abstract state:
+	(dc.dataChannelState == Initialized || dc.dataChannelState == BlockCipherInitialized ==>
+		ft.Setup_Agent(dc.getRid(), dc.getAgentIdT(), dc.getKMSIdT(), dc.getClientIdT(), dc.getReaderIdT(), tm.pubTerm(pub.pub_msg(dc.agentLTKeyARN)), dc.getLogLTPkT()) in dc.getAbsState()) &&
+	(dc.dataChannelState == AgentSecretCreatedAndSigned ==>
+		ft.St_Agent_2(dc.getRid(), dc.getAgentIdT(), dc.getKMSIdT(), dc.getClientIdT(), dc.getReaderIdT(), tm.pubTerm(pub.pub_msg(dc.agentLTKeyARN)), dc.getLogLTPkT(), dc.getAgentShareT(), dc.getAgentShareSignatureT()) in dc.getAbsState()) &&
+	(dc.dataChannelState == HandshakeRequestSent ==>
+		ft.St_Agent_3(dc.getRid(), dc.getAgentIdT(), dc.getKMSIdT(), dc.getClientIdT(), dc.getReaderIdT(), tm.pubTerm(pub.pub_msg(dc.agentLTKeyARN)), dc.getLogLTPkT(), dc.getAgentShareT(), dc.getAgentShareSignatureT()) in dc.getAbsState())
+}
 
-	instanceID, err := identity.InstanceID()
+pred (dc *dataChannel) MemTransfer(encryptionEnabled bool) {
+	dc != nil &&
+	acc(&dc.dataStream) &&
+	acc(&dc.hs.clientVersion) &&
+	acc(&dc.hs.startReceivingChan, _) &&
+	acc(&dc.hs.responseChan, _) &&
+	acc(&dc.hs.error) &&
+	acc(&dc.hs.complete) &&
+	acc(&dc.hs.skipped) &&
+	acc(&dc.hs.handshakeStartTime) &&
+	acc(&dc.hs.handshakeEndTime) &&
+	acc(&dc.blockCipher) &&
+	acc(&dc.encryptionEnabled) &&
+	acc(&dc.separateOutputPayload) &&
+	acc(&dc.state) &&
+	acc(&dc.agentLTKeyARN) &&
+	acc(&dc.logReaderId) &&
+	acc(&dc.logLTPk) &&
+	dc.dataStream.Mem() &&
+	acc(dc.hs.startReceivingChan.SendChannel(), _) &&
+	dc.hs.startReceivingChan.SendGivenPerm() == StartReceivingChanInv!<dc, _!> &&
+	dc.hs.startReceivingChan.SendGotPerm() == PredTrue!<!> &&
+	!dc.hs.skipped &&
+	dc.encryptionEnabled == assumeEncryptionEnabledForVerification() &&
+	dc.blockCipher != nil && dc.blockCipher.Mem() &&
+	dc.IoSpecMem() &&
+	pl.token(dc.getToken()) &&
+	iospec.P_Agent(dc.getToken(), dc.getRid(), dc.getAbsState()) &&
+	(encryptionEnabled ==>
+		dc.logLTPk.Mem() &&
+		dc.state.kmsService.Mem() &&
+		bytes.SliceMem(dc.state.agentSecret))
+}
 
-	if instanceID == "" {
-		return nil, fmt.Errorf("no instanceID provided, %s", err)
-	}
+pred (dc *dataChannel) Inv() {
+	dc.RecvRoutineMem()
+}
 
-	dataChannel := &DataChannel{}
-	dataChannel.Initialize(
-		context,
-		mgsService,
-		channelId,
-		clientId,
-		instanceID,
-		mgsConfig.RolePublishSubscribe,
-		cancelFlag,
-		inputStreamMessageHandler)
+pred StartReceivingChanInv(dc *dataChannel, payload MessageReceptionPayload) {
+	(payload.status == ReceiveHandshakeResponeEncryptionEnabled ||
+		payload.status == ReceiveHandshakeResponeEncryptionDisabled ||
+		payload.status == ReceiveOtherResponse) &&
+	(payload.status == ReceiveHandshakeResponeEncryptionEnabled ==> dc.MemTransfer(true)) &&
+	(payload.status == ReceiveHandshakeResponeEncryptionDisabled ==> dc.MemTransfer(false) && !assumeEncryptionEnabledForVerification()) &&
+	(payload.status == ReceiveOtherResponse ==> acc(dc.Mem(), 1/2) &&
+		dc.getState() == AgentSecretCreatedAndSigned &&
+		unfolding acc(dc.Mem(), 1/2) in dc.hs.complete)
+}
 
-	streamMessageHandler := func(input []byte) {
-		if err := dataChannel.dataChannelIncomingMessageHandler(log, input); err != nil {
-			log.Errorf("Invalid message %s\n", err)
-		}
-	}
-	if err := dataChannel.SetWebSocket(context, mgsService, channelId, clientId, streamMessageHandler); err != nil {
-		return nil, fmt.Errorf("failed to create websocket for datachannel with error: %s", err)
-	}
-	if err := dataChannel.Open(log); err != nil {
-		return nil, fmt.Errorf("failed to open datachannel with error: %s", err)
-	}
-	dataChannel.ResendStreamDataMessageScheduler(log)
-	return dataChannel, nil
+pred ResponseChanInv(dc *dataChannel, encryptionEnabled bool) {
+	dc.MemTransfer(encryptionEnabled)
 }
 
-// Initialize populates datachannel object.
-func (dataChannel *DataChannel) Initialize(context context.T,
-	mgsService service.Service,
-	sessionId string,
-	clientId string,
-	instanceId string,
-	role string,
-	cancelFlag task.CancelFlag,
-	inputStreamMessageHandler InputStreamMessageHandler) {
-
-	dataChannel.context = context
-	dataChannel.Service = mgsService
-	dataChannel.ChannelId = sessionId
-	dataChannel.ClientId = clientId
-	dataChannel.InstanceId = instanceId
-	dataChannel.Role = role
-	dataChannel.Pause = false
-	dataChannel.ExpectedSequenceNumber = 0
-	dataChannel.StreamDataSequenceNumber = 0
-	dataChannel.StreamDataSequenceNumberMutex = &sync.Mutex{}
-	dataChannel.OutgoingMessageBuffer = ListMessageBuffer{
-		list.New(),
-		mgsConfig.OutgoingMessageBufferCapacity,
-		&sync.Mutex{},
-	}
-	dataChannel.IncomingMessageBuffer = MapMessageBuffer{
-		make(map[int64]StreamingMessage),
-		mgsConfig.IncomingMessageBufferCapacity,
-		&sync.Mutex{},
-	}
-	dataChannel.RoundTripTime = float64(mgsConfig.DefaultRoundTripTime)
-	dataChannel.RoundTripTimeVariation = mgsConfig.DefaultRoundTripTimeVariation
-	dataChannel.RetransmissionTimeout = mgsConfig.DefaultTransmissionTimeout
-	dataChannel.wsChannel = &communicator.WebSocketChannel{}
-	dataChannel.cancelFlag = cancelFlag
-	dataChannel.inputStreamMessageHandler = inputStreamMessageHandler
-	dataChannel.handshake = Handshake{
-		responseChan:            make(chan bool),
-		encryptionConfirmedChan: make(chan bool),
-		error:                   nil,
-		complete:                false,
-		skipped:                 false,
-		handshakeEndTime:        time.Now(),
-		handshakeStartTime:      time.Now(),
-	}
-}
-
-// SetWebSocket populates webchannel object.
-func (dataChannel *DataChannel) SetWebSocket(context context.T,
-	mgsService service.Service,
-	sessionId string,
-	clientId string,
-	onMessageHandler func(input []byte)) error {
+// conceptually, this predicate contains write permissions to
+// ghost heap locations storing the parameters for the IO spec
+pred (dc *dataChannel) IoSpecMem() {
+	dc.TokenMem() &&
+	dc.RidMem() &&
+	dc.AbsStateMem() &&
+	dc.AgentIdTMem() &&
+	dc.KMSIdTMem() &&
+	dc.ClientIdTMem() &&
+	dc.ReaderIdTMem() &&
+	dc.LogLTPkTMem() &&
+	dc.AgentShareTMem() &&
+	dc.AgentShareSignatureTMem() &&
+	dc.InFactTMem()
+}
 
-	log := context.Log()
-	uuid.SwitchFormat(uuid.CleanHyphen)
-	requestId := uuid.NewV4().String()
+pred (dc *dataChannel) TokenMem()
 
-	log.Infof("Setting up datachannel for session: %s, requestId: %s, clientId: %s", sessionId, requestId, clientId)
-	tokenValue, err := getDataChannelToken(log, mgsService, sessionId, requestId, clientId)
-	if err != nil {
-		log.Errorf("Failed to get datachannel token, error: %s", err)
-		return err
-	}
+ghost
+requires acc(dc.TokenMem(), _)
+pure func (dc *dataChannel) getTokenInternal() pl.Place
 
-	onErrorHandler := func(err error) {
-		uuid.SwitchFormat(uuid.CleanHyphen)
-		requestId := uuid.NewV4().String()
-		callable := func() (channel interface{}, err error) {
-			tokenValue, err := getDataChannelToken(log, mgsService, sessionId, requestId, clientId)
-			if err != nil {
-				return dataChannel, err
-			}
-			dataChannel.wsChannel.SetChannelToken(tokenValue)
-			if err = dataChannel.Reconnect(log); err != nil {
-				return dataChannel, err
-			}
-			return dataChannel, nil
-		}
-		retryer := retry.ExponentialRetryer{
-			CallableFunc:        callable,
-			GeometricRatio:      mgsConfig.RetryGeometricRatio,
-			InitialDelayInMilli: rand.Intn(mgsConfig.DataChannelRetryInitialDelayMillis) + mgsConfig.DataChannelRetryInitialDelayMillis,
-			MaxDelayInMilli:     mgsConfig.DataChannelRetryMaxIntervalMillis,
-			MaxAttempts:         mgsConfig.DataChannelNumMaxAttempts,
-			NonRetryableErrors:  getNonRetryableDataChannelErrors(),
-		}
-		if _, err := retryer.Call(); err != nil {
-			log.Error(err)
-		}
-	}
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getToken() pl.Place {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getTokenInternal()
+}
 
-	if err := dataChannel.wsChannel.Initialize(context,
-		sessionId,
-		mgsConfig.DataChannel,
-		mgsConfig.RolePublishSubscribe,
-		tokenValue,
-		mgsService.GetRegion(),
-		mgsService.GetV4Signer(),
-		onMessageHandler,
-		onErrorHandler); err != nil {
-		log.Errorf("failed to initialize websocket channel for datachannel, error: %s", err)
-		return err
-	}
-	return nil
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetToken() pl.Place {
+	return unfolding acc(dc.Mem(), _) in dc.getToken()
 }
 
-// Open opens the websocket connection and sends the token for service to acknowledge the connection.
-func (dataChannel *DataChannel) Open(log log.T) error {
-	// Opens websocket connection
-	if err := dataChannel.wsChannel.Open(log, nil); err != nil {
-		return fmt.Errorf("failed to connect data channel with error: %s", err)
-	}
+ghost
+preserves dc.TokenMem()
+ensures dc.getTokenInternal() == token
+// ensures getRid(sessionId) == old(getRid(sessionId))
+// ensures getAbsState(sessionId) == old(getAbsState(sessionId))
+func (dc *dataChannel) setToken(token pl.Place)
 
-	// finalize handshake
-	uuid.SwitchFormat(uuid.CleanHyphen)
-	uid := uuid.NewV4().String()
+pred (dc *dataChannel) RidMem()
 
-	openDataChannelInput := service.OpenDataChannelInput{
-		MessageSchemaVersion: aws.String(mgsConfig.MessageSchemaVersion),
-		RequestId:            aws.String(uid),
-		TokenValue:           aws.String(dataChannel.wsChannel.GetChannelToken()),
-		ClientInstanceId:     aws.String(dataChannel.InstanceId),
-		ClientId:             aws.String(dataChannel.ClientId),
-	}
-	jsonValue, err := json.Marshal(openDataChannelInput)
-	if err != nil {
-		return fmt.Errorf("error serializing openDataChannelInput: %s", err)
-	}
+ghost
+requires acc(dc.RidMem(), _)
+pure func (dc *dataChannel) getRidInternal() tm.Term
 
-	return dataChannel.SendMessage(log, jsonValue, websocket.TextMessage)
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getRid() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getRidInternal()
 }
 
-// SendMessage sends a message to the service through datachannel.
-func (dataChannel *DataChannel) SendMessage(log log.T, input []byte, inputType int) error {
-	return dataChannel.wsChannel.SendMessage(log, input, inputType)
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetRid() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getRid()
 }
 
-// Reconnect reconnects datachannel to service endpoint.
-func (dataChannel *DataChannel) Reconnect(log log.T) error {
-	log.Debugf("Reconnecting datachannel: %s", dataChannel.ChannelId)
+ghost
+preserves dc.RidMem()
+ensures dc.getRidInternal() == rid
+// ensures getAbsState(sessionId) == old(getAbsState(sessionId))
+// ensures getToken(sessionId) == old(getToken(sessionId))
+func (dc *dataChannel) setRid(rid tm.Term)
 
-	if err := dataChannel.wsChannel.Close(log); err != nil {
-		log.Debugf("Closing datachannel failed with error: %s", err)
-	}
+pred (dc *dataChannel) AbsStateMem()
 
-	if err := dataChannel.Open(log); err != nil {
-		return fmt.Errorf("failed to reconnect datachannel with error: %s", err)
-	}
+ghost
+requires acc(dc.AbsStateMem(), _)
+pure func (dc *dataChannel) getAbsStateInternal() mset[ft.Fact]
 
-	dataChannel.Pause = false
-	log.Debugf("Successfully reconnected to datachannel %s", dataChannel.ChannelId)
-	return nil
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getAbsState() mset[ft.Fact] {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getAbsStateInternal()
 }
 
-// Close closes datachannel - its web socket connection.
-func (dataChannel *DataChannel) Close(log log.T) error {
-	log.Infof("Closing datachannel with channel Id %s", dataChannel.ChannelId)
-	return dataChannel.wsChannel.Close(log)
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetAbsState() mset[ft.Fact] {
+	return unfolding acc(dc.Mem(), _) in dc.getAbsState()
 }
 
-// PrepareToCloseChannel waits for all messages to be sent to MGS
-func (dataChannel *DataChannel) PrepareToCloseChannel(log log.T) {
-	done := make(chan bool)
-	go func() {
-		for dataChannel.OutgoingMessageBuffer.Messages.Len() > 0 {
-			time.Sleep(10 * time.Millisecond)
-		}
-		done <- true
-	}()
+ghost
+preserves dc.AbsStateMem()
+ensures dc.getAbsStateInternal() == state
+// ensures getToken(sessionId) == old(getToken(sessionId))
+// ensures getRid(sessionId) == old(getRid(sessionId))
+func (dc *dataChannel) setAbsState(state mset[ft.Fact])
 
-	select {
-	case <-done:
-		log.Tracef("Datachannel buffer is empty, datachannel can now be closed")
-	case <-time.After(2 * time.Second):
-		log.Debugf("Timeout waiting for datachannel buffer to empty.")
-	}
-}
+pred (dc *dataChannel) AgentIdTMem()
 
-// SendStreamDataMessage sends a data message in a form of AgentMessage for streaming.
-func (dataChannel *DataChannel) SendStreamDataMessage(log log.T, payloadType mgsContracts.PayloadType, inputData []byte) (err error) {
-	if len(inputData) == 0 {
-		log.Debugf("Ignoring empty stream data payload. PayloadType: %d", payloadType)
-		return nil
-	}
+ghost
+requires acc(dc.AgentIdTMem(), _)
+pure func (dc *dataChannel) getAgentIdTInternal() tm.Term
 
-	// If encryption has been enabled, encrypt the payload
-	if dataChannel.encryptionEnabled && (payloadType == mgsContracts.Output || payloadType == mgsContracts.StdErr || payloadType == mgsContracts.ExitCode) {
-		if inputData, err = dataChannel.blockCipher.EncryptWithAESGCM(inputData); err != nil {
-			return fmt.Errorf("error encrypting stream data message sequence %d, err: %v", dataChannel.StreamDataSequenceNumber, err)
-		}
-	}
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getAgentIdT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getAgentIdTInternal()
+}
 
-	// StreamDataSequenceNumber only changed in the code block below
-	dataChannel.StreamDataSequenceNumberMutex.Lock()
-	defer dataChannel.StreamDataSequenceNumberMutex.Unlock()
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetAgentIdT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getAgentIdT()
+}
 
-	var flag uint64 = 0
-	if dataChannel.StreamDataSequenceNumber == 0 {
-		flag = 1
-	}
+ghost
+preserves dc.AgentIdTMem()
+ensures dc.getAgentIdTInternal() == agentIdT
+func (dc *dataChannel) setAgentIdT(agentIdT tm.Term)
 
-	uuid.SwitchFormat(uuid.CleanHyphen)
-	messageId := uuid.NewV4()
-	agentMessage := &mgsContracts.AgentMessage{
-		MessageType:    mgsContracts.OutputStreamDataMessage,
-		SchemaVersion:  1,
-		CreatedDate:    uint64(time.Now().UnixNano() / 1000000),
-		SequenceNumber: dataChannel.StreamDataSequenceNumber,
-		Flags:          flag,
-		MessageId:      messageId,
-		PayloadType:    uint32(payloadType),
-		Payload:        inputData,
-	}
-	msg, err := agentMessage.Serialize(log)
-	if err != nil {
-		return fmt.Errorf("cannot serialize StreamData message %v", agentMessage)
-	}
+pred (dc *dataChannel) KMSIdTMem()
 
-	if dataChannel.Pause {
-		log.Tracef("Sending stream data message has been paused, saving stream data message sequence %d to local map: ", dataChannel.StreamDataSequenceNumber)
-	} else {
-		log.Tracef("Send stream data message sequence number %d", dataChannel.StreamDataSequenceNumber)
-		if err = dataChannel.SendMessage(log, msg, websocket.BinaryMessage); err != nil {
-			log.Errorf("Error sending stream data message %v", err)
-		}
-	}
+ghost
+requires acc(dc.KMSIdTMem(), _)
+pure func (dc *dataChannel) getKMSIdTInternal() tm.Term
 
-	streamingMessage := StreamingMessage{
-		msg,
-		dataChannel.StreamDataSequenceNumber,
-		time.Now(),
-	}
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getKMSIdT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getKMSIdTInternal()
+}
 
-	log.Tracef("Add stream data to OutgoingMessageBuffer. Sequence Number: %d", streamingMessage.SequenceNumber)
-	dataChannel.AddDataToOutgoingMessageBuffer(streamingMessage)
-	dataChannel.StreamDataSequenceNumber = dataChannel.StreamDataSequenceNumber + 1
-	return nil
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetKMSIdT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getKMSIdT()
 }
 
-// ResendStreamDataMessageScheduler spawns a separate go thread which keeps checking OutgoingMessageBuffer at fixed interval
-// and resends first message if time elapsed since lastSentTime of the message is more than acknowledge wait time
-func (dataChannel *DataChannel) ResendStreamDataMessageScheduler(log log.T) error {
-	go func() {
-		defer func() {
-			if r := recover(); r != nil {
-				log.Errorf("Resend stream data message scheduler panic: %v", r)
-				log.Errorf("Stacktrace:\n%s", debug.Stack())
-			}
-		}()
-		for {
-			time.Sleep(mgsConfig.ResendSleepInterval)
-			if dataChannel.Pause {
-				log.Tracef("Resend stream data message has been paused")
-				continue
-			}
-			streamMessageElement := dataChannel.OutgoingMessageBuffer.Messages.Front()
-			if streamMessageElement == nil {
-				continue
-			}
+ghost
+preserves dc.KMSIdTMem()
+ensures dc.getKMSIdTInternal() == kmsIdT
+func (dc *dataChannel) setKMSIdT(kmsIdT tm.Term)
 
-			streamMessage := streamMessageElement.Value.(StreamingMessage)
-			if time.Since(streamMessage.LastSentTime) > dataChannel.RetransmissionTimeout {
-				log.Tracef("Resend stream data message: %d", streamMessage.SequenceNumber)
-				if err := dataChannel.SendMessage(log, streamMessage.Content, websocket.BinaryMessage); err != nil {
-					log.Errorf("Unable to send stream data message: %s", err)
-				}
-				streamMessage.LastSentTime = time.Now()
-				streamMessageElement.Value = streamMessage
-			}
-		}
-	}()
-	return nil
-}
+pred (dc *dataChannel) ClientIdTMem()
 
-// ProcessAcknowledgedMessage processes acknowledge messages by deleting them from OutgoingMessageBuffer.
-func (dataChannel *DataChannel) ProcessAcknowledgedMessage(log log.T, acknowledgeMessageContent mgsContracts.AcknowledgeContent) {
-	acknowledgeSequenceNumber := acknowledgeMessageContent.SequenceNumber
-	for streamMessageElement := dataChannel.OutgoingMessageBuffer.Messages.Front(); streamMessageElement != nil; streamMessageElement = streamMessageElement.Next() {
-		streamMessage := streamMessageElement.Value.(StreamingMessage)
-		if streamMessage.SequenceNumber == acknowledgeSequenceNumber {
+ghost
+requires acc(dc.ClientIdTMem(), _)
+pure func (dc *dataChannel) getClientIdTInternal() tm.Term
 
-			//Calculate retransmission timeout based on latest round trip time of message
-			dataChannel.calculateRetransmissionTimeout(log, streamMessage)
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getClientIdT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getClientIdTInternal()
+}
 
-			log.Tracef("Delete stream data from OutgoingMessageBuffer. Sequence Number: %d", streamMessage.SequenceNumber)
-			dataChannel.RemoveDataFromOutgoingMessageBuffer(streamMessageElement)
-			break
-		}
-	}
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetClientIdT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getClientIdT()
 }
 
-// SendAcknowledgeMessage sends acknowledge message for stream data over data channel
-func (dataChannel *DataChannel) SendAcknowledgeMessage(log log.T, streamDataMessage mgsContracts.AgentMessage) error {
-	dataStreamAcknowledgeContent := &mgsContracts.AcknowledgeContent{
-		MessageType:         streamDataMessage.MessageType,
-		MessageId:           streamDataMessage.MessageId.String(),
-		SequenceNumber:      streamDataMessage.SequenceNumber,
-		IsSequentialMessage: true,
-	}
+ghost
+preserves dc.ClientIdTMem()
+ensures dc.getClientIdTInternal() == clientIdT
+func (dc *dataChannel) setClientIdT(clientIdT tm.Term)
 
-	acknowledgeContentBytes, err := dataStreamAcknowledgeContent.Serialize(log)
-	if err != nil {
-		// should not happen
-		log.Errorf("Cannot serialize Acknowledge message err: %v", err)
-		return err
-	}
+pred (dc *dataChannel) ReaderIdTMem()
 
-	log.Tracef("Send %s message for stream data: %d", mgsContracts.AcknowledgeMessage, streamDataMessage.SequenceNumber)
-	if err := dataChannel.sendAgentMessage(log, mgsContracts.AcknowledgeMessage, acknowledgeContentBytes); err != nil {
-		return err
-	}
-	return nil
+ghost
+requires acc(dc.ReaderIdTMem(), _)
+pure func (dc *dataChannel) getReaderIdTInternal() tm.Term
+
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getReaderIdT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getReaderIdTInternal()
 }
 
-// SendAgentSessionStateMessage sends agent session state to MGS
-func (dataChannel *DataChannel) SendAgentSessionStateMessage(log log.T, sessionStatus mgsContracts.SessionStatus) error {
-	agentSessionStateContent := &mgsContracts.AgentSessionStateContent{
-		SchemaVersion: schemaVersion,
-		SessionState:  string(sessionStatus),
-		SessionId:     dataChannel.ChannelId,
-	}
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetReaderIdT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getReaderIdT()
+}
 
-	var agentSessionStateContentBytes []byte
-	var err error
-	if agentSessionStateContentBytes, err = json.Marshal(agentSessionStateContent); err != nil {
-		log.Errorf("Cannot serialize AgentSessionState message err: %v", err)
-		return err
-	}
+ghost
+preserves dc.ReaderIdTMem()
+ensures dc.getReaderIdTInternal() == readerIdT
+func (dc *dataChannel) setReaderIdT(readerIdT tm.Term)
 
-	log.Debugf("Send %s message with session status %s", mgsContracts.AgentSessionState, string(sessionStatus))
-	if err := dataChannel.sendAgentMessage(log, mgsContracts.AgentSessionState, agentSessionStateContentBytes); err != nil {
-		return err
-	}
-	return nil
-}
+// ghost
+// requires acc(IoSpecMem(sessionId), _)
+// pure func getSendKeyT(sessionId string) tm.Term
 
-// sendAgentMessage sends agent message for given messageType and content
-func (dataChannel *DataChannel) sendAgentMessage(log log.T, messageType string, messageContent []byte) error {
-	uuid.SwitchFormat(uuid.CleanHyphen)
-	messageId := uuid.NewV4()
-	agentMessage := &mgsContracts.AgentMessage{
-		MessageType:    messageType,
-		SchemaVersion:  schemaVersion,
-		CreatedDate:    uint64(time.Now().UnixNano() / 1000000),
-		SequenceNumber: sequenceNumber,
-		Flags:          messageFlags,
-		MessageId:      messageId,
-		Payload:        messageContent,
-	}
+pred (dc *dataChannel) LogLTPkTMem()
 
-	msg, err := agentMessage.Serialize(log)
-	if err != nil {
-		log.Errorf("Cannot serialize agent message err: %v", err)
-		return err
-	}
+ghost
+requires acc(dc.LogLTPkTMem(), _)
+pure func (dc *dataChannel) getLogLTPkTInternal() tm.Term
 
-	err = dataChannel.SendMessage(log, msg, websocket.BinaryMessage)
-	if err != nil {
-		log.Errorf("Error sending %s message %v", messageType, err)
-		return err
-	}
-	return nil
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getLogLTPkT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getLogLTPkTInternal()
 }
 
-// AddDataToOutgoingMessageBuffer adds given message at the end of OutputMessageBuffer if it has capacity.
-func (dataChannel *DataChannel) AddDataToOutgoingMessageBuffer(streamMessage StreamingMessage) {
-	if dataChannel.OutgoingMessageBuffer.Messages.Len() == dataChannel.OutgoingMessageBuffer.Capacity {
-		return
-	}
-	dataChannel.OutgoingMessageBuffer.Mutex.Lock()
-	dataChannel.OutgoingMessageBuffer.Messages.PushBack(streamMessage)
-	dataChannel.OutgoingMessageBuffer.Mutex.Unlock()
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetLogLTPkT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getLogLTPkT()
 }
 
-// RemoveDataFromOutgoingMessageBuffer removes given element from OutgoingMessageBuffer.
-func (dataChannel *DataChannel) RemoveDataFromOutgoingMessageBuffer(streamMessageElement *list.Element) {
-	dataChannel.OutgoingMessageBuffer.Mutex.Lock()
-	dataChannel.OutgoingMessageBuffer.Messages.Remove(streamMessageElement)
-	dataChannel.OutgoingMessageBuffer.Mutex.Unlock()
-}
+ghost
+preserves dc.LogLTPkTMem()
+ensures dc.getLogLTPkTInternal() == logLTPkT
+func (dc *dataChannel) setLogLTPkT(logLTPkT tm.Term)
 
-// AddDataToIncomingMessageBuffer adds given message to IncomingMessageBuffer if it has capacity.
-func (dataChannel *DataChannel) AddDataToIncomingMessageBuffer(streamMessage StreamingMessage) {
-	if len(dataChannel.IncomingMessageBuffer.Messages) == dataChannel.IncomingMessageBuffer.Capacity {
-		return
-	}
-	dataChannel.IncomingMessageBuffer.Mutex.Lock()
-	dataChannel.IncomingMessageBuffer.Messages[streamMessage.SequenceNumber] = streamMessage
-	dataChannel.IncomingMessageBuffer.Mutex.Unlock()
+pred (dc *dataChannel) AgentShareTMem()
+
+ghost
+requires acc(dc.AgentShareTMem(), _)
+pure func (dc *dataChannel) getAgentShareTInternal() tm.Term
+
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getAgentShareT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getAgentShareTInternal()
 }
 
-// RemoveDataFromIncomingMessageBuffer removes given sequence number message from IncomingMessageBuffer.
-func (dataChannel *DataChannel) RemoveDataFromIncomingMessageBuffer(sequenceNumber int64) {
-	dataChannel.IncomingMessageBuffer.Mutex.Lock()
-	delete(dataChannel.IncomingMessageBuffer.Messages, sequenceNumber)
-	dataChannel.IncomingMessageBuffer.Mutex.Unlock()
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetAgentShareT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getAgentShareT()
 }
 
-// dataChannelIncomingMessageHandler deserialize incoming message and
-// processes that data based on MessageType.
-func (dataChannel *DataChannel) dataChannelIncomingMessageHandler(log log.T, rawMessage []byte) error {
+ghost
+preserves dc.AgentShareTMem()
+ensures dc.getAgentShareTInternal() == shareT
+func (dc *dataChannel) setAgentShareT(shareT tm.Term)
 
-	streamDataMessage := &mgsContracts.AgentMessage{}
-	if err := streamDataMessage.Deserialize(log, rawMessage); err != nil {
-		log.Errorf("Cannot deserialize raw message, err: %v.", err)
-		return err
-	}
+pred (dc *dataChannel) AgentShareSignatureTMem()
 
-	if err := streamDataMessage.Validate(); err != nil {
-		log.Errorf("Invalid StreamDataMessage, err: %v.", err)
-		return err
-	}
+ghost
+requires acc(dc.AgentShareSignatureTMem(), _)
+pure func (dc *dataChannel) getAgentShareSignatureTInternal() tm.Term
 
-	switch streamDataMessage.MessageType {
-	case mgsContracts.InputStreamDataMessage:
-		return dataChannel.handleStreamDataMessage(log, *streamDataMessage, rawMessage)
-	case mgsContracts.AcknowledgeMessage:
-		return dataChannel.handleAcknowledgeMessage(log, *streamDataMessage)
-	case mgsContracts.ChannelClosedMessage:
-		return dataChannel.handleChannelClosedMessage(log, *streamDataMessage)
-	case mgsContracts.PausePublicationMessage:
-		dataChannel.handlePausePublicationMessage(log, *streamDataMessage)
-		return nil
-	case mgsContracts.StartPublicationMessage:
-		dataChannel.handleStartPublicationMessage(log, *streamDataMessage)
-		return nil
-	default:
-		log.Warnf("Invalid message type received: %s", streamDataMessage.MessageType)
-	}
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getAgentShareSignatureT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getAgentShareSignatureTInternal()
+}
 
-	return nil
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetAgentShareSignatureT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getAgentShareSignatureT()
 }
 
-// calculateRetransmissionTimeout calculates message retransmission timeout value based on round trip time on given message.
-func (dataChannel *DataChannel) calculateRetransmissionTimeout(log log.T, streamingMessage StreamingMessage) {
-	newRoundTripTime := float64(time.Since(streamingMessage.LastSentTime))
+ghost
+preserves dc.AgentShareSignatureTMem()
+ensures dc.getAgentShareSignatureTInternal() == signatureT
+func (dc *dataChannel) setAgentShareSignatureT(signatureT tm.Term)
 
-	dataChannel.RoundTripTimeVariation = ((1 - mgsConfig.RTTVConstant) * dataChannel.RoundTripTimeVariation) +
-		(mgsConfig.RTTVConstant * math.Abs(dataChannel.RoundTripTime-newRoundTripTime))
+pred (dc *dataChannel) InFactTMem()
 
-	dataChannel.RoundTripTime = ((1 - mgsConfig.RTTConstant) * dataChannel.RoundTripTime) +
-		(mgsConfig.RTTConstant * newRoundTripTime)
+ghost
+requires acc(dc.InFactTMem(), _)
+pure func (dc *dataChannel) getInFactTInternal() tm.Term
 
-	dataChannel.RetransmissionTimeout = time.Duration(dataChannel.RoundTripTime +
-		math.Max(float64(mgsConfig.ClockGranularity), float64(4*dataChannel.RoundTripTimeVariation)))
+ghost
+requires acc(dc.IoSpecMem(), _)
+pure func (dc *dataChannel) getInFactT() tm.Term {
+	return unfolding acc(dc.IoSpecMem(), _) in dc.getInFactTInternal()
+}
 
-	// Ensure RetransmissionTimeout do not exceed maximum timeout defined
-	if dataChannel.RetransmissionTimeout > mgsConfig.MaxTransmissionTimeout {
-		dataChannel.RetransmissionTimeout = mgsConfig.MaxTransmissionTimeout
-	}
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= Initialized
+pure func (dc *dataChannel) GetInFactT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.getInFactT()
+}
+
+ghost
+preserves dc.InFactTMem()
+ensures dc.getInFactTInternal() == inFactT
+func (dc *dataChannel) setInFactT(inFactT tm.Term)
 
-	log.Tracef("Retransmission timeout calculated in mills. "+
-		"AcknowledgeMessageSequenceNumber: %d, RoundTripTime: %d, RoundTripTimeVariation: %d, RetransmissionTimeout: %d",
-		streamingMessage.SequenceNumber,
-		dataChannel.RoundTripTime,
-		dataChannel.RoundTripTimeVariation,
-		dataChannel.RetransmissionTimeout/time.Millisecond)
+ghost
+requires acc(dc.Mem(), _) && dc.getState() >= BlockCipherInitialized
+pure func (dc *dataChannel) GetEncKeyT() tm.Term {
+	return unfolding acc(dc.Mem(), _) in dc.blockCipher.GetEncKeyT()
 }
 
-// handleStreamDataMessage handles incoming stream data messages by processing the payload and updating expectedSequenceNumber.
-func (dataChannel *DataChannel) handleStreamDataMessage(log log.T,
-	streamDataMessage mgsContracts.AgentMessage,
-	rawMessage []byte) (err error) {
+// while assuming that verification is enabled is not necessary to prove
+// memory safety, we need this assumption for verifying refinement.
+// Leaving this function abstract will consider both cases, i.e.,
+// encryption being disabled or enabled.
+ghost
+pure func assumeEncryptionEnabledForVerification() bool {
+	return true
+}
+@*/
 
-	dataChannel.Pause = false
-	// On receiving expected stream data message, send acknowledgement, process it and increment expected sequence number by 1.
-	// Further process messages from IncomingMessageBuffer
-	if streamDataMessage.SequenceNumber == dataChannel.ExpectedSequenceNumber {
-		log.Tracef("Process new incoming stream data message. Sequence Number: %d", streamDataMessage.SequenceNumber)
-		if err = dataChannel.processStreamDataMessage(log, streamDataMessage); err != nil {
-			if errors.Is(err, mgsContracts.ErrHandlerNotReady) {
-				return nil
-			}
-			log.Errorf("Unable to process stream data payload %v, err: %v.", streamDataMessage, err)
-			return err
+// NewDataChannel constructs datachannel objects.
+// @ requires context.Mem() && cancelFlag.Mem()
+// @ requires ctx != nil && ctx.Inv() && inputStreamMessageHandler implements StreamDataHandlerSpec{ctx}
+// @ requires pl.token(t0) && iospec.P_Agent(t0, rid, mset[ft.Fact]{})
+// @ ensures  res.Mem() && typeOf(res) == *dataChannel
+// @ ensures  err == nil ==> res.(* dataChannel).getState() == Initialized
+// TODO: make `ctx` a ghost parameter as soon as Gobra supports ghost fields
+func NewDataChannel(context contextPkg.T,
+	channelId string,
+	clientId string,
+	logReaderId string,
+	inputStreamMessageHandler InputStreamMessageHandler,
+	cancelFlag task.CancelFlag,
+	/*@ ctx StreamDataHandlerContext, t0 pl.Place, rid tm.Term @*/) (res IDataChannel, err error) {
+
+	tmp /*@ @ @*/ := dataChannel{}
+	dc := &tmp
+	cl := // @ requires log != nil
+		// @ requires datastream.QuantifiedStreamDataHandlerSpecWand(msg)
+		// @ preserves acc(log.Mem(), _) && tmp.RecvRoutineMem()
+		// @ ensures msg.Mem()
+		// @ ensures err != nil ==> err.ErrorMem()
+		func /*@ callHandler @*/ (log logger.T, msg *mgsContracts.AgentMessage) (err error) {
+			err = tmp.processStreamDataMessage(log, msg)
+			return
 		}
+	/*@
+		proof cl implements datastream.StreamDataHandlerSpec{dc} {
+	        unfold dc.Inv()
+	        err = cl(log, msg) as callHandler
+			fold dc.Inv()
+	    }
+	@*/
+
+	dc.dataChannelState = Uninitialized
+	dc.hs.startReceivingChan = make(chan MessageReceptionPayload)
+	//@ dc.hs.startReceivingChan.Init(StartReceivingChanInv!<dc, _!>, PredTrue!<!>)
+	dc.inputStreamMessageHandler = inputStreamMessageHandler
+	//@ dc.msgHandlerCtx = ctx
+	dc.hs.responseChan = make(chan bool)
+	//@ dc.hs.responseChan.Init(ResponseChanInv!<dc, _!>, PredTrue!<!>)
+	// we allocate some ghost heap space:
+	//@ inhale dc.IoSpecMem()
+	//@ unfold dc.IoSpecMem()
+	// the following assertion is needed:
+	//@ assert dc.TokenMem()
+	//@ dc.setToken(t0)
+	//@ dc.setRid(rid)
+	//@ dc.setAbsState(mset[ft.Fact]{})
+	//@ fold dc.IoSpecMem()
+
+	//@ fold dc.RecvRoutineMem()
+	//@ fold dc.Mem()
+	//@ fold dc.Inv()
+	dataStream, err := datastream.NewDataStream(context,
+		channelId,
+		clientId,
+		cl,
+		cancelFlag,
+		/*@ dc @*/)
+	if err != nil {
+		// we return a non-nil dc such that we can ensure `dc.Mem()`
+		// independent of `err`. However, clients should check whether
+		// `err` is nil.
+		return dc, fmtErrorf("failed to create data stream with error: %s", err /*@, perm(1/2) @*/)
+	}
 
-		if err = dataChannel.SendAcknowledgeMessage(log, streamDataMessage); err != nil {
-			return err
-		}
+	err = dc.initialize(dataStream, logReaderId)
+	if err != nil {
+		return dc, err
+	}
 
-		// Message is acknowledged so increment expected sequence number
-		dataChannel.ExpectedSequenceNumber = dataChannel.ExpectedSequenceNumber + 1
-		return dataChannel.processIncomingMessageBufferItems(log)
+	return dc, nil
+}
 
-	} else if streamDataMessage.SequenceNumber > dataChannel.ExpectedSequenceNumber {
-		// If incoming message sequence number is greater than expected sequence number and IncomingMessageBuffer has capacity,
-		// add message to IncomingMessageBuffer and send acknowledgement
-		log.Debugf("Unexpected sequence message received. Received Sequence Number: %d. Expected Sequence Number: %d",
-			streamDataMessage.SequenceNumber, dataChannel.ExpectedSequenceNumber)
+// initialize populates datachannel object.
+// @ requires dc.Mem() && dc.getState() == Uninitialized && dataStream.Mem()
+// @ requires dc.IoSpecMem() && pl.token(dc.getToken()) && iospec.P_Agent(dc.getToken(), dc.getRid(), dc.getAbsState())
+// @ ensures  dc.Mem()
+// @ ensures  err == nil ==> dc.getState() == Initialized
+func (dc *dataChannel) initialize(dataStream *datastream.DataStream, logReaderId string) (err error) {
+	// @ unfold dc.Mem()
+	dc.dataStream = dataStream
+	dc.encryptionEnabled = false
+	dc.hs.error = nil
+	dc.hs.complete = false
+	dc.hs.skipped = false
+	dc.hs.handshakeEndTime = time.Now()
+	dc.hs.handshakeStartTime = time.Now()
+	dc.state.kmsService, err = dc.dataStream.GetKMSService( /*@ perm(1/2) @*/ )
+	if err != nil {
+		// @ fold dc.Mem()
+		return fmtErrorf("failed to initialize KMS service: %v", err /*@, perm(1/2) @*/)
+	}
+
+	// @ t0 := dc.getToken()
+	// @ rid := dc.getRid()
+	// @ s0 := dc.getAbsState()
+	// @ unfold iospec.P_Agent(t0, rid, s0)
+	// @ unfold iospec.phiRF_Agent_17(t0, rid, s0)
+	// @ t1 := iospec.get_e_Setup_Agent_placeDst(t0, rid)
+	// @ agentIdT := iospec.get_e_Setup_Agent_r1(t0, rid)
+	// @ kmsIdT := iospec.get_e_Setup_Agent_r2(t0, rid)
+	// @ clientIdT := iospec.get_e_Setup_Agent_r3(t0, rid)
+	// @ readerIdT := iospec.get_e_Setup_Agent_r4(t0, rid)
+	// @ logLTPkT := iospec.get_e_Setup_Agent_r6(t0, rid)
+	// @ setupFact := ft.Setup_Agent(rid, agentIdT, kmsIdT, clientIdT, readerIdT, iospec.get_e_Setup_Agent_r5(t0, rid), logLTPkT)
+	dc.agentLTKeyARN, dc.logLTPk, err = getInitialValues(dc.state.kmsService, dc.dataStream.GetClientId(), logReaderId /*@, t0, rid @*/)
+	if err != nil {
+		// @ fold iospec.phiRF_Agent_17(t0, rid, s0)
+		// @ fold iospec.P_Agent(t0, rid, s0)
+		// @ fold dc.Mem()
+		return fmtErrorf("failed to initialize KMS service: %v", err /*@, perm(1/2) @*/)
+	}
+
+	// @ s1 := s0 union mset[ft.Fact]{ setupFact }
+	// @ unfold dc.IoSpecMem()
+	// @ dc.setToken(t1)
+	// @ dc.setAbsState(s1)
+	// @ dc.setAgentIdT(agentIdT)
+	// @ dc.setKMSIdT(kmsIdT)
+	// @ dc.setClientIdT(clientIdT)
+	// @ dc.setReaderIdT(readerIdT)
+	// @ dc.setLogLTPkT(logLTPkT)
+	// @ fold dc.IoSpecMem()
+	dc.logReaderId = logReaderId
+	dc.dataChannelState = Initialized
+	// @ fold dc.Mem()
+	return
+}
 
-		if len(dataChannel.IncomingMessageBuffer.Messages) < dataChannel.IncomingMessageBuffer.Capacity {
-			if err = dataChannel.SendAcknowledgeMessage(log, streamDataMessage); err != nil {
-				return err
-			}
+// we assume that this function returns the initial values used by this agent session
+// according to the `Agent_Init` Tamarin rule
+// @ trusted
+// @ preserves kmsService.Mem()
+// @ requires pl.token(t) && iospec.e_Setup_Agent(t, rid)
+// @ ensures  err == nil ==> logLTPk.Mem()
+// @ ensures  err == nil ==> pl.token(old(iospec.get_e_Setup_Agent_placeDst(t, rid))) &&
+// @	by.gamma(tm.pubTerm(pub.pub_msg(clientId))) == by.gamma(old(iospec.get_e_Setup_Agent_r3(t, rid))) &&
+// @	by.gamma(tm.pubTerm(pub.pub_msg(logReaderId))) == by.gamma(old(iospec.get_e_Setup_Agent_r4(t, rid))) &&
+// @	by.gamma(tm.pubTerm(pub.pub_msg(agentLTKeyARN))) == by.gamma(old(iospec.get_e_Setup_Agent_r5(t, rid))) &&
+// @	logLTPk.Abs() == by.gamma(old(iospec.get_e_Setup_Agent_r6(t, rid)))
+// Patern axiom applies locally:
+// @ ensures  by.gamma(old(iospec.get_e_Setup_Agent_r3(t, rid))) == by.gamma(tm.pubTerm(pub.pub_msg(clientId))) ==> old(iospec.get_e_Setup_Agent_r3(t, rid)) == tm.pubTerm(pub.pub_msg(clientId))
+// @ ensures  by.gamma(old(iospec.get_e_Setup_Agent_r4(t, rid))) == by.gamma(tm.pubTerm(pub.pub_msg(logReaderId))) ==> old(iospec.get_e_Setup_Agent_r4(t, rid)) == tm.pubTerm(pub.pub_msg(logReaderId))
+// @ ensures  by.gamma(old(iospec.get_e_Setup_Agent_r5(t, rid))) == by.gamma(tm.pubTerm(pub.pub_msg(agentLTKeyARN))) ==> old(iospec.get_e_Setup_Agent_r5(t, rid)) == tm.pubTerm(pub.pub_msg(agentLTKeyARN))
+// @ ensures err != nil ==> err.ErrorMem()
+// @ ensures err != nil ==> pl.token(t) && iospec.e_Setup_Agent(t, rid) &&
+// @ 	iospec.get_e_Setup_Agent_placeDst(t, rid) == old(iospec.get_e_Setup_Agent_placeDst(t, rid)) &&
+// @ 	iospec.get_e_Setup_Agent_r1(t, rid) == old(iospec.get_e_Setup_Agent_r1(t, rid)) &&
+// @ 	iospec.get_e_Setup_Agent_r2(t, rid) == old(iospec.get_e_Setup_Agent_r2(t, rid)) &&
+// @ 	iospec.get_e_Setup_Agent_r3(t, rid) == old(iospec.get_e_Setup_Agent_r3(t, rid)) &&
+// @ 	iospec.get_e_Setup_Agent_r4(t, rid) == old(iospec.get_e_Setup_Agent_r4(t, rid)) &&
+// @ 	iospec.get_e_Setup_Agent_r5(t, rid) == old(iospec.get_e_Setup_Agent_r5(t, rid)) &&
+// @ 	iospec.get_e_Setup_Agent_r6(t, rid) == old(iospec.get_e_Setup_Agent_r6(t, rid))
+func getInitialValues(kmsService *crypto.KMSService, clientId string, logReaderId string /*@, ghost t pl.Place, ghost rid tm.Term @*/) (agentLTKeyARN string, logLTPk *rsa.PublicKey, err error) {
+	metadata, err := kmsService.CreateKeyAssymetric()
+	if err != nil {
+		err = fmtErrorf("failed to create agent LTK: %v", err /*@, perm(1/1) @*/)
+		return "", nil, err /*@, t @*/
+	}
 
-			streamingMessage := StreamingMessage{
-				rawMessage,
-				streamDataMessage.SequenceNumber,
-				time.Now(),
-			}
+	//@ unfold metadata.Mem()
+	if metadata.Arn == nil {
+		err = fmtErrorfMetadata("asymmetric key ARN is nil, metadata: %+v", metadata /*@, perm(1/2) @*/)
+		return "", nil, err /*@, t @*/
+	}
+	agentLTKeyARN = *metadata.Arn
+	//@ cryptoRand.GetReaderMem()
+	sk, err := rsa.GenerateKey(cryptoRand.Reader, 4096 /*@, perm(1/2) @*/)
+	if err != nil {
+		err = fmtErrorf("failed to create log secret key: %v", err /*@, perm(1/1) @*/)
+		return "", nil, err /*@, t @*/
+	}
+	//@ unfold sk.Mem()
+	logLTPk = &sk.PublicKey
+	return
+}
 
-			//Add message to buffer for future processing
-			log.Debugf("Add stream data to IncomingMessageBuffer. Sequence Number: %d", streamDataMessage.SequenceNumber)
-			dataChannel.AddDataToIncomingMessageBuffer(streamingMessage)
+// SendStreamDataMessage sends a data message in a form of AgentMessage for streaming.
+// Requires that the handshake is either complete or skipped
+// @ requires log != nil
+// @ requires QuantifiedSendStreamDataMessageWand(inputData, inputDataT, p)
+// @ preserves dc.Mem()
+// @ preserves acc(log.Mem(), _)
+// @ ensures err != nil ==> err.ErrorMem()
+func (dc *dataChannel) SendStreamDataMessage(log logger.T, payloadType mgsContracts.PayloadType, inputData []byte /*@, ghost p perm, ghost inputDataT tm.Term @*/) (err error) {
+	if dc.getState() < HandshakeCompleted {
+		return fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+	}
+
+	if payloadType != mgsContracts.Output && payloadType != mgsContracts.StdErr && payloadType != mgsContracts.ExitCode {
+		return fmtErrorfPayloadType("Rejecting stream data message with payload type %d as it would otherwise be sent in plaintext", payloadType)
+	}
+
+	//@ unfold dc.Mem()
+	//@ t0 := dc.getToken()
+	//@ rid := dc.getRid()
+	//@ s0 := dc.getAbsState()
+
+	// receive `inputData` from environment:
+	//@ unfold iospec.P_Agent(t0, rid, s0)
+	//@ unfold iospec.phiRF_Agent_16(t0, rid, s0)
+	//@ t1 := iospec.get_e_InFact_placeDst(t0, rid)
+	//@ s1 := s0 union mset[ft.Fact]{ ft.InFact_Agent(rid, iospec.get_e_InFact_r1(t0, rid)) }
+	//@ unfold QuantifiedSendStreamDataMessageWand(inputData, inputDataT, p)
+	//@ unfold SendStreamDataMessageWand(t0, rid, inputData, inputDataT, p)
+	//@ apply (pl.token(t0) && iospec.e_InFact(t0, rid)) --* (acc(bytes.SliceMem(inputData), p) && by.gamma(inputDataT) == abs.Abs(inputData) && inputDataT == old[#lhs](iospec.get_e_InFact_r1(t0, rid)) && pl.token(old[#lhs](iospec.get_e_InFact_placeDst(t0, rid))))
+
+	// obtain permission to send the ciphertext containing `inputData`:
+	//@ assert exists AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey tm.Term :: ft.St_Agent_10(dc.getRid(), AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) in s0 && tm.kdf1(tm.exp(Y, x)) == dc.blockCipher.GetEncKeyT()
+	// existential elimination:
+	//@ AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey := arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm()
+	//@ assume ft.St_Agent_10(dc.getRid(), AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) in s0 && tm.kdf1(tm.exp(Y, x)) == dc.blockCipher.GetEncKeyT()
+	/*@
+		l := mset[ft.Fact] {
+			ft.St_Agent_10(rid, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+			ft.InFact_Agent(rid, inputDataT),
 		}
-	} else {
-		log.Tracef("Discarding already processed message. Received Sequence Number: %d. Expected Sequence Number: %d",
-			streamDataMessage.SequenceNumber, dataChannel.ExpectedSequenceNumber)
+		a := mset[cl.Claim] {
+			cl.AgentSendLoop(rid, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y),
+		}
+		r := mset[ft.Fact] {
+	    	ft.St_Agent_10(rid, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey),
+	        ft.OutFact_Agent(rid, tm.pair(tm.pubTerm(pub.const_Message_pub()), tm.senc(inputDataT, tm.kdf1(tm.exp(Y, x))))),
+	        ft.OutFact_Agent(rid, tm.pair(tm.pubTerm(pub.const_Log_pub()), tm.pair(tm.pubTerm(pub.const_Message_pub()), tm.senc(inputDataT, tm.kdf1(tm.exp(Y, x)))))),
+		}
+		@*/
+	//@ unfold iospec.P_Agent(t1, rid, s1)
+	//@ unfold iospec.phiR_Agent_11(t1, rid, s1)
+	//@ t2 := iospec.get_e_Agent_SendMessages_placeDst(t1, rid, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, inputDataT, l, a, r)
+	//@ s2 := ft.U(l, r, s1)
+	//@ unfold dc.IoSpecMem()
+	//@ dc.setToken(t2)
+	//@ dc.setAbsState(s2)
+	//@ fold dc.IoSpecMem()
+	//@ iospec.internBIO_e_Agent_SendMessages(t1, rid, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey, inputDataT, l, a, r)
+	// the following assert stmt is necessary:
+	//@ assert ft.St_Agent_10(rid, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) in s2
+	//@ fold dc.Mem()
+
+	if len(inputData) == 0 {
+		logDebugfPayloadType(log, "Ignoring empty stream data payload. PayloadType: %d", payloadType)
+		return nil
 	}
-	return nil
+
+	return dc.sendData(log, payloadType, inputData /*@, p/2, inputDataT @*/)
 }
 
-// handleAcknowledgeMessage deserialize acknowledge content and process it.
-func (dataChannel *DataChannel) handleAcknowledgeMessage(log log.T, streamDataMessage mgsContracts.AgentMessage) (err error) {
-	dataChannel.Pause = false
-	acknowledgeMessage := &mgsContracts.AcknowledgeContent{}
-	if err = acknowledgeMessage.Deserialize(log, streamDataMessage); err != nil {
-		log.Errorf("Cannot deserialize payload to AcknowledgeMessage: %s, err: %v.", string(streamDataMessage.Payload), err)
-		return err
+// @ requires log != nil && noPerm < p && p <= writePerm
+// @ requires dc.Mem()
+// @ requires dc.getState() >= (payloadType == mgsContracts.Output || payloadType == mgsContracts.StdErr || payloadType == mgsContracts.ExitCode || payloadType == mgsContracts.HandshakeComplete ? BlockCipherReady : BlockCipherInitialized)
+// @ requires acc(bytes.SliceMem(inputData), p) && by.gamma(inputDataT) == abs.Abs(inputData)
+// @ requires (payloadType == mgsContracts.Output || payloadType == mgsContracts.StdErr || payloadType == mgsContracts.ExitCode || payloadType == mgsContracts.HandshakeComplete) ?
+// @ 	ft.OutFact_Agent(dc.GetRid(), tm.pair(mgsContracts.payloadTypeTerm(payloadType), tm.senc(inputDataT, dc.GetEncKeyT()))) # dc.GetAbsState() > 0 :
+// @ 	ft.OutFact_Agent(dc.GetRid(), tm.pair(mgsContracts.payloadTypeTerm(payloadType), inputDataT)) # dc.GetAbsState() > 0
+// @ preserves acc(log.Mem(), _)
+// @ ensures dc.Mem() && dc.getState() == old(dc.getState())
+// @ ensures err != nil ==> err.ErrorMem()
+func (dc *dataChannel) sendData(log logger.T, payloadType mgsContracts.PayloadType, inputData []byte /*@, ghost p perm, ghost inputDataT tm.Term @*/) (err error) {
+	// @ oldState := dc.getState()
+	// @ unfold dc.Mem()
+	// @ channelId := dc.dataStream.GetChannelId()
+
+	// If encryption has been enabled, encrypt the payload
+	if dc.encryptionEnabled && (payloadType == mgsContracts.Output || payloadType == mgsContracts.StdErr || payloadType == mgsContracts.ExitCode || payloadType == mgsContracts.HandshakeComplete) {
+		if inputData, err = dc.blockCipher.EncryptWithAESGCM(inputData /*@, p/2 @*/); err != nil {
+			err = fmtErrorfInt64Err("error encrypting stream data message sequence %d, err: %v", dc.dataStream.GetStreamDataSequenceNumber( /*@ p/2 @*/ ), err /*@, perm(1/1) @*/)
+			// @ fold dc.Mem()
+			return
+		}
+		//@ inputDataT = tm.senc(inputDataT, dc.blockCipher.GetEncKeyT())
+	}
+
+	/*@
+	t0 := dc.getToken()
+	rid := dc.getRid()
+	s0 := dc.getAbsState()
+	m := tm.pair(mgsContracts.payloadTypeTerm(payloadType), inputDataT)
+	unfold iospec.P_Agent(t0, rid, s0)
+	unfold iospec.phiRG_Agent_13(t0, rid, s0)
+	@*/
+
+	/*@
+	// existential elimination:
+	AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey := arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm(), arb.GetArbTerm()
+	ghost if dc.dataChannelState >= HandshakeCompleted {
+		assert exists AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey tm.Term :: ft.St_Agent_10(dc.getRid(), AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) in s0 && tm.kdf1(tm.exp(Y, x)) == dc.blockCipher.GetEncKeyT()
+		assume ft.St_Agent_10(dc.getRid(), AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) in s0 && tm.kdf1(tm.exp(Y, x)) == dc.blockCipher.GetEncKeyT()
 	}
+	@*/
 
-	dataChannel.ProcessAcknowledgedMessage(log, *acknowledgeMessage)
+	//@ ghost var t1 pl.Place
+	err /*@, t1 @*/ = dc.dataStream.Send(log, payloadType, inputData /*@, p/2, t0, rid, inputDataT, m @*/)
+	if err != nil {
+		// @ fold iospec.phiRG_Agent_13(t0, rid, s0)
+		// @ fold iospec.P_Agent(t0, rid, s0)
+		// @ fold dc.Mem()
+		return err
+	}
+	// @ unfold dc.IoSpecMem()
+	// @ dc.setToken(t1)
+	// @ s1 := s0 setminus mset[ft.Fact]{ ft.OutFact_Agent(rid, m) }
+	// @ dc.setAbsState(s1)
+	// @ fold dc.IoSpecMem()
+	/*@
+	ghost if dc.dataChannelState >= HandshakeCompleted {
+		// the following assert stmt is necessary:
+		assert ft.St_Agent_10(dc.getRid(), AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) in s1
+	}
+	@*/
+	// @ fold dc.Mem()
 	return nil
 }
 
-// handleChannelClosedMessage deserialize channel_closed message content and terminate the session.
-func (dataChannel *DataChannel) handleChannelClosedMessage(log log.T, streamDataMessage mgsContracts.AgentMessage) (err error) {
-	channelClosedMessage := &mgsContracts.ChannelClosed{}
-	if err = channelClosedMessage.Deserialize(log, streamDataMessage); err != nil {
-		log.Errorf("Cannot deserialize payload to ChannelClosed message: %s, err: %v.", string(streamDataMessage.Payload), err)
-		return err
+// TODO: treat this function as trusted / unrelated to the security protocol because it
+// does not involve any cryptography. We might have to model in Tamarin that `GetChannelId()`
+// can savely be sent to the network.
+// SendAgentSessionStateMessage sends agent session state to MGS
+// @ trusted
+// @ requires log != nil
+// @ preserves dc.Mem() && acc(log.Mem(), _)
+// @ ensures dc.getState() == old(dc.getState())
+// @ ensures err != nil ==> err.ErrorMem()
+func (dc *dataChannel) SendAgentSessionStateMessage(log logger.T, sessionStatus mgsContracts.SessionStatus) (err error) {
+	agentSessionStateContent := &mgsContracts.AgentSessionStateContent{
+		SchemaVersion: schemaVersion,
+		SessionState:  string(sessionStatus),
+		SessionId:     dc.dataStream.GetChannelId(),
 	}
 
-	log.Debugf("Processing terminate session request: messageId %s, sessionId %s", channelClosedMessage.MessageId, channelClosedMessage.SessionId)
-	dataChannel.cancelFlag.Set(task.Canceled)
+	var agentSessionStateContentBytes []byte
+	if agentSessionStateContentBytes, err = json.Marshal(agentSessionStateContent); err != nil {
+		log.Errorf("Cannot serialize AgentSessionState message err: %v", err)
+		return err
+	}
 
+	sessionStatusStr := string(sessionStatus)
+	//@ fold sessionStatusStr.Mem()
+	log.Debugf("Send %s message with session status %s", mgsContracts.AgentSessionState, sessionStatusStr)
+	if err := dc.dataStream.SendAgentMessage(log, mgsContracts.AgentSessionState, agentSessionStateContentBytes); err != nil {
+		return err
+	}
 	return nil
 }
 
-// handlePausePublicationMessage sets pause status of datachannel to true.
-func (dataChannel *DataChannel) handlePausePublicationMessage(log log.T, streamDataMessage mgsContracts.AgentMessage) {
-	dataChannel.Pause = true
-	log.Debugf("Processed %s message. Datachannel pause status set to %s", streamDataMessage.MessageType, dataChannel.Pause)
+// @ trusted
+// @ preserves dc.RecvRoutineMem()
+// @ ensures  err == nil ==> StartReceivingChanInv!<dc, _!>(res)
+// @ ensures  err != nil ==> err.ErrorMem()
+func (dc *dataChannel) tryReceiveMessageReceptionStatus(timeout time.Duration) (res MessageReceptionPayload, err error) {
+	var ok bool
+	select {
+	case res, ok = <-dc.hs.startReceivingChan:
+		if !ok {
+			err = fmtError("Channel has been closed")
+		}
+	case <-time.After(timeout):
+		err = fmtError("Timeout occurred waiting for receiving a message on a channel")
+	}
+	return
 }
 
-// handleStartPublicationMessage sets pause status of datachannel to false.
-func (dataChannel *DataChannel) handleStartPublicationMessage(log log.T, streamDataMessage mgsContracts.AgentMessage) {
-	dataChannel.Pause = false
-	log.Debugf("Processed %s message. Datachannel pause status set to %s", streamDataMessage.MessageType, dataChannel.Pause)
+// @ trusted
+// @ requires noPerm < p
+// @ preserves acc(dc.Mem(), p) && dc.getState() == AgentSecretCreatedAndSigned
+// @ ensures  err == nil ==> ResponseChanInv!<dc, _!>(res)
+// @ ensures  err != nil ==> err.ErrorMem()
+func (dc *dataChannel) tryReceiveResponse(timeout time.Duration /*@, ghost p perm @*/) (res bool, err error) {
+	var ok bool
+	select {
+	case res, ok = <-dc.hs.responseChan:
+		if !ok {
+			err = fmtError("Channel has been closed")
+		}
+	case <-time.After(timeout):
+		err = fmtError("Timeout occurred waiting for receiving a message on a channel")
+	}
+	return
 }
 
-// processIncomingMessageBufferItems checks if new expected sequence stream data is present in IncomingMessageBuffer.
-// If so process it and increment expected sequence number.
-// Repeat until expected sequence stream data is not found in IncomingMessageBuffer.
-func (dataChannel *DataChannel) processIncomingMessageBufferItems(log log.T) (err error) {
-	for {
-		bufferedStreamMessage := dataChannel.IncomingMessageBuffer.Messages[dataChannel.ExpectedSequenceNumber]
-		if bufferedStreamMessage.Content != nil {
-			log.Debugf("Process stream data message from IncomingMessageBuffer. "+
-				"Sequence Number: %d", bufferedStreamMessage.SequenceNumber)
-
-			streamDataMessage := &mgsContracts.AgentMessage{}
-
-			if err = streamDataMessage.Deserialize(log, bufferedStreamMessage.Content); err != nil {
-				log.Errorf("Cannot deserialize raw message: %d, err: %v.", bufferedStreamMessage.SequenceNumber, err)
-				return err
-			}
-			if err = dataChannel.processStreamDataMessage(log, *streamDataMessage); err != nil {
-				log.Errorf("Unable to process stream data payload, err: %v.", err)
-				return err
-			}
-
-			dataChannel.ExpectedSequenceNumber = dataChannel.ExpectedSequenceNumber + 1
-
-			log.Debugf("Delete stream data from IncomingMessageBuffer. Sequence Number: %d", bufferedStreamMessage.SequenceNumber)
-			dataChannel.RemoveDataFromIncomingMessageBuffer(bufferedStreamMessage.SequenceNumber)
-		} else {
-			break
+// @ trusted
+// @ requires acc(responseChan.RecvChannel(), _)
+// @ requires responseChan.RecvGivenPerm() == PredTrue!<!>
+// @ requires responseChan.RecvGotPerm() == ResponseChanInv!<dc, _!>
+// @ ensures  responseChan.RecvChannel()
+// @ ensures  responseChan.RecvGivenPerm() == PredTrue!<!>
+// @ ensures  responseChan.RecvGotPerm() == ResponseChanInv!<dc, _!>
+// @ ensures  err == nil ==> ResponseChanInv!<dc, _!>(res)
+// @ ensures  err != nil ==> err.ErrorMem()
+func (dc *dataChannel) tryReceiveResponseAlt(responseChan chan bool, timeout time.Duration) (res bool, err error) {
+	var ok bool
+	select {
+	case res, ok = <-responseChan:
+		if !ok {
+			err = fmtError("Channel has been closed")
 		}
+	case <-time.After(timeout):
+		err = fmtError("Timeout occurred waiting for receiving a message on a channel")
 	}
-	return nil
+	return
 }
 
-// processStreamDataMessage gets called for all messages of type OutputStreamDataMessage
-func (dataChannel *DataChannel) processStreamDataMessage(log log.T, streamDataMessage mgsContracts.AgentMessage) (err error) {
-
-	if dataChannel.encryptionEnabled && streamDataMessage.PayloadType == uint32(mgsContracts.Output) {
-		if streamDataMessage.Payload, err = dataChannel.blockCipher.DecryptWithAESGCM(streamDataMessage.Payload); err != nil {
-			return fmt.Errorf("Error decrypting stream data message sequence %d, err: %v", streamDataMessage.SequenceNumber, err)
+/*@
+// `nonDeterministicChoice` returns either true or false.
+// Since we do not constrain the result value, the verifier
+// considers both return values for any invocation of `nonDeterministicChoice()`
+ghost
+func nonDeterministicChoice() bool
+
+// this models `tryReceiveMessageReceptionStatus` as Gobra does not yet support the `select` statement
+// we use this function to validate the spec of `tryReceiveMessageReceptionStatus`
+ghost
+preserves dc.RecvRoutineMem()
+ensures  err == nil ==> StartReceivingChanInv!<dc, _!>(res)
+ensures  err != nil ==> err.ErrorMem()
+func (dc *dataChannel) tryReceiveMessageReceptionStatusModel(timeout time.Duration) (res MessageReceptionPayload, err error) {
+	if nonDeterministicChoice() {
+		unfold dc.RecvRoutineMem()
+		fold PredTrue!<!>()
+		var ok bool
+		res, ok = <-dc.hs.startReceivingChan
+		fold dc.RecvRoutineMem()
+		if !ok {
+			err = fmtError("Channel has been closed")
+			return
 		}
+	} else {
+		err = fmtError("Timeout occurred waiting for receiving a message on a channel")
 	}
+	return
+}
 
-	switch mgsContracts.PayloadType(streamDataMessage.PayloadType) {
-	case mgsContracts.HandshakeResponse:
-		{
-			// PayloadType is HandshakeResponse so we call our own handler instead of the plugin handler
-			if err = dataChannel.handleHandshakeResponse(log, streamDataMessage); err != nil {
-				return fmt.Errorf("processing of HandshakeResponse message failed, %v", err)
-			}
+// this models `tryReceiveResponse` as Gobra does not yet support the `select` statement
+// we use this function to validate the spec of `tryReceiveResponse`
+ghost
+requires noPerm < p
+preserves acc(dc.Mem(), p) && dc.getState() == AgentSecretCreatedAndSigned
+ensures  err == nil ==> ResponseChanInv!<dc, _!>(res)
+ensures  err != nil ==> err.ErrorMem()
+func (dc *dataChannel) tryReceiveResponseModel(timeout time.Duration, ghost p perm) (res bool, err error) {
+	if nonDeterministicChoice() {
+		unfold acc(dc.Mem(), p)
+		fold PredTrue!<!>()
+		var ok bool
+		res, ok = <-dc.hs.responseChan
+		fold acc(dc.Mem(), p)
+		if !ok {
+			err = fmtError("Channel has been closed")
+			return
 		}
-	case mgsContracts.EncChallengeResponse:
-		{
-			// PayloadType is HandshakeResponse so we call our own handler instead of the plugin handler
-			if err = dataChannel.handleEncryptionChallengeResponse(log, streamDataMessage); err != nil {
-				return fmt.Errorf("processing of EncryptionChallengeReponse message failed, %v", err)
-			}
+	} else {
+		err = fmtError("Timeout occurred waiting for receiving a message on a channel")
+	}
+	return
+}
+
+ghost
+requires noPerm < p
+preserves acc(responseChan.RecvChannel(), p)
+preserves responseChan.RecvGivenPerm() == PredTrue!<!>
+preserves responseChan.RecvGotPerm() == ResponseChanInv!<dc, _!>
+ensures  err == nil ==> ResponseChanInv!<dc, _!>(res)
+ensures  err != nil ==> err.ErrorMem()
+func (dc *dataChannel) tryReceiveResponseModelAlt(responseChan chan bool, timeout time.Duration, ghost p perm) (res bool, err error) {
+	if nonDeterministicChoice() {
+		fold PredTrue!<!>()
+		var ok bool
+		res, ok = <-responseChan
+		if !ok {
+			err = fmtError("Channel has been closed")
+			return
+		}
+	} else {
+		err = fmtError("Timeout occurred waiting for receiving a message on a channel")
+	}
+	return
+}
+@*/
+
+/*@
+// TODO remove (used to  justify magic wand for `processStreamDataMessage`)
+trusted
+requires pl.token(t) && iospec.e_InFact(t, rid)
+ensures   ok ==> msg.Mem() // && by.gamma(term) == abs.Abs(packet)
+ensures   ok ==> pl.token(t1) && t1 == old(iospec.get_e_InFact_placeDst(t, rid)) && term == old(iospec.get_e_InFact_r1(t, rid))
+ensures  !ok ==> t1 == t && pl.token(t) && iospec.e_InFact(t, rid) && iospec.get_e_InFact_placeDst(t, rid) == old(iospec.get_e_InFact_placeDst(t, rid)) && iospec.get_e_InFact_r1(t, rid) == old(iospec.get_e_InFact_r1(t, rid))
+func Receive(streamDataMessage *mgsContracts.AgentMessage, ghost t pl.Place, ghost rid tm.Term) (msg *mgsContracts.AgentMessage, ok bool, ghost term tm.Term, ghost t1 pl.Place) {
+	msg = streamDataMessage
+	return
+}
+
+// TODO remove (used to  justify magic wand for `processStreamDataMessage`)
+func ReceiveWand(streamDataMessage *mgsContracts.AgentMessage, ghost t pl.Place, ghost rid tm.Term) (msg *mgsContracts.AgentMessage, ok bool, ghost term tm.Term, ghost t1 pl.Place) {
+	package (pl.token(t) && iospec.e_InFact(t, rid)) --* (ok ==> msg.Mem() && pl.token(t1) && t1 == old[#lhs](iospec.get_e_InFact_placeDst(t, rid)) && term == old[#lhs](iospec.get_e_InFact_r1(t, rid))) {
+		msg, ok, term, t1 = Receive(streamDataMessage, t, rid)
+		assert ok ==> msg.Mem()
+	}
+}
+@*/
+
+// processStreamDataMessage gets called for all messages of type OutputStreamDataMessage
+// @ requires log != nil
+// @ requires datastream.QuantifiedStreamDataHandlerSpecWand(streamDataMessage)
+// @ preserves acc(log.Mem(), _) && dc.RecvRoutineMem()
+// @ ensures err == nil ==> streamDataMessage.Mem()
+// @ ensures err != nil ==> err.ErrorMem()
+func (dc *dataChannel) processStreamDataMessage(log logger.T, streamDataMessage *mgsContracts.AgentMessage) (err error) {
+
+	payload, err := dc.tryReceiveMessageReceptionStatus(channelStatusTimeout)
+	if err != nil {
+		logInfo(log, "Timeout while receiving channel status")
+		return err
+	}
+
+	//@ unfold StartReceivingChanInv!<dc, _!>(payload)
+	switch payload.status {
+	case ReceiveHandshakeResponeEncryptionEnabled:
+		//@ unfold dc.MemTransfer(true)
+		//@ t0 := dc.getToken()
+		//@ rid := dc.getRid()
+		//@ s0 := dc.getAbsState()
+		//@ unfold iospec.P_Agent(t0, rid, s0)
+		//@ unfold iospec.phiRF_Agent_16(t0, rid, s0)
+		//@ t1 := iospec.get_e_InFact_placeDst(t0, rid)
+		//@ receivedMsgT := iospec.get_e_InFact_r1(t0, rid)
+		//@ s1 := s0 union mset[ft.Fact]{ ft.InFact_Agent(rid, receivedMsgT) }
+		//@ unfold datastream.QuantifiedStreamDataHandlerSpecWand(streamDataMessage)
+		//@ unfold datastream.StreamDataHandlerSpecWand(t0, rid, streamDataMessage)
+		//@ apply (pl.token(t0) && iospec.e_InFact(t0, rid)) --* (streamDataMessage.Mem() && by.gamma(old[#lhs](iospec.get_e_InFact_r1(t0, rid))) == streamDataMessage.Abs() && pl.token(old[#lhs](iospec.get_e_InFact_placeDst(t0, rid))))
+		//@ unfold dc.IoSpecMem()
+		//@ dc.setToken(t1)
+		//@ dc.setAbsState(s1)
+		//@ dc.setInFactT(receivedMsgT)
+		//@ fold dc.IoSpecMem()
+		//@ assert by.gamma(receivedMsgT) == streamDataMessage.Abs()
+		//@ fold dc.MemTransfer(true)
+		payloadType := /*@ unfolding streamDataMessage.Mem() in @*/ streamDataMessage.PayloadType
+		switch mgsContracts.PayloadType(payloadType) {
+		case mgsContracts.HandshakeResponse:
+			{
+				// PayloadType is HandshakeResponse so we call our own handler instead of the plugin handler
+				if err = dc.handleHandshakeResponse(log, streamDataMessage, true); err != nil {
+					return fmtErrorf("processing of HandshakeResponse message failed, %v", err /*@, perm(1/1) @*/)
+				}
+			}
+		default:
+			return fmtError("received message with unexpected payload type")
 		}
-	default:
+		//@ assert streamDataMessage.Mem()
+	case ReceiveHandshakeResponeEncryptionDisabled:
+		// since we assume that encryption is enabled for proving refinement, we can derive here
+		// a contradiction, i.e., this case corresponds to dead code if encryption is enabled:
+		//@ assert false
+		payloadType := /*@ unfolding streamDataMessage.Mem() in @*/ streamDataMessage.PayloadType
+		switch mgsContracts.PayloadType(payloadType) {
+		case mgsContracts.HandshakeResponse:
+			{
+				// PayloadType is HandshakeResponse so we call our own handler instead of the plugin handler
+				if err = dc.handleHandshakeResponse(log, streamDataMessage, false); err != nil {
+					return fmtErrorf("processing of HandshakeResponse message failed, %v", err /*@, perm(1/1) @*/)
+				}
+			}
+		default:
+			return fmtError("received message with unexpected payload type")
+		}
+	case ReceiveOtherResponse:
+		// the problem is that dc.Mem() is shared between the two threads
+		// thus, we have to remove IO spec from Mem at the end of the handshake and share it
+		// with both threads using a ghost lock
+		//@ unfold acc(dc.Mem(), 1/2)
+		//@ unfold streamDataMessage.Mem()
+		if dc.encryptionEnabled && streamDataMessage.PayloadType == uint32(mgsContracts.Output) {
+			plaintext, err := dc.blockCipher.DecryptWithAESGCM(streamDataMessage.Payload /*@, perm(1/2) @*/)
+			if err != nil {
+				// send a message to the channel to prepare for next message reception:
+				//@ fold acc(dc.Mem(), 1/2)
+				dc.resendReceiveOtherResponse()
+				err = fmtErrorfInt64Err("Error decrypting stream data message sequence %d, err: %v", streamDataMessage.SequenceNumber, err /*@, perm(1/1) @*/)
+				//@ fold streamDataMessage.Mem()
+				return err
+			}
+			streamDataMessage.Payload = plaintext
+		}
+		//@ fold streamDataMessage.Mem()
+
 		// Ignore stream data message if handshake is neither skipped nor completed
-		if !dataChannel.handshake.skipped && !dataChannel.handshake.complete {
-			log.Tracef("Handshake still in progress, ignore stream data message sequence %d", streamDataMessage.SequenceNumber)
-			return nil
+		if !dc.hs.skipped && !dc.hs.complete {
+			// this case should provably not occur as status `ReceiveOtherResponse`
+			// is supposed to be sent on the `startReceivingChan` channel AFTER the
+			// handshake has completed.
+			// We can indeed proof the inexistence of this branch:
+			// @ assert false
 		}
 
-		if err = dataChannel.inputStreamMessageHandler(log, streamDataMessage); err != nil {
+		//@ fold acc(dc.Mem(), 1/2)
+		//@ unfold dc.RecvRoutineMem()
+		err = dc.inputStreamMessageHandler(log, streamDataMessage) /*@ as StreamDataHandlerSpec{dc.msgHandlerCtx} @*/
+		//@ fold dc.RecvRoutineMem()
+		if err != nil {
+			dc.resendReceiveOtherResponse()
 			return err
 		}
+		dc.resendReceiveOtherResponse()
 	}
 
 	return nil
 }
 
-// handleHandshakeResponse is the handler for payload type HandshakeResponse
-func (dataChannel *DataChannel) handleHandshakeResponse(log log.T, streamDataMessage mgsContracts.AgentMessage) error {
-	log.Debug("Received Handshake Response.")
-	var handshakeResponse mgsContracts.HandshakeResponsePayload
-	if err := json.Unmarshal(streamDataMessage.Payload, &handshakeResponse); err != nil {
-		return fmt.Errorf("Unmarshalling of HandshakeResponse message failed, %s", err)
+// @ requires acc(dc.Mem(), 1/2) && dc.getState() == AgentSecretCreatedAndSigned && unfolding acc(dc.Mem(), 1/2) in dc.hs.complete
+// @ preserves dc.RecvRoutineMem()
+func (dc *dataChannel) resendReceiveOtherResponse() {
+	//@ unfold acc(dc.Mem(), 1/2)
+	//@ unfold dc.RecvRoutineMem()
+	//@ fold acc(dc.Mem(), 1/2)
+	payload := MessageReceptionPayload{
+		status: ReceiveOtherResponse,
+	}
+	//@ fold StartReceivingChanInv!<dc, _!>(payload)
+	dc.hs.startReceivingChan <- payload
+	//@ fold dc.RecvRoutineMem()
+}
+
+// @ trusted
+// @ requires noPerm < p
+// @ preserves acc(bytes.SliceMem(input), p)
+// @ ensures bytes.SliceMem(res)
+func computeSHA384(input []byte /*@, ghost p perm @*/) (res []byte) {
+	hash := sha512.New384()
+	hash.Write(input)
+	return hash.Sum(nil)
+}
+
+// @ trusted
+// @ requires noPerm < p
+// @ preserves acc(bytes.SliceMem(input), p)
+// @ ensures err == nil ==> bytes.SliceMem(res)
+// @ ensures err != nil ==> err.ErrorMem()
+func computeKdf(input []byte, isKdf1 bool /*@, ghost p perm @*/) (res []byte, err error) {
+	hash512 := sha512.New
+	hkPRK := hkdf.Extract(hash512, input, nil) //it's pretty complicated what using a salt with HKDF means, we should double check this
+
+	const keySize = 32
+	res = make([]byte, keySize)
+
+	var ctx string
+	if isKdf1 {
+		ctx = "S"
+	} else {
+		ctx = "C"
+	}
+
+	bytesRead, err := hkdf.Expand(hash512, hkPRK, []byte(ctx)).Read(res)
+	if err != nil {
+		return nil, err
 	}
+	if bytesRead != keySize {
+		return nil, errors.New("result of applying KDF has unexpected length")
+	}
+	return
+}
+
+/*@
+ghost
+requires endIdx <= len(actions)
+requires forall i int :: { actions[i] } 0 <= i && i < len(actions) ==> acc(actions[i].Mem(), _)
+decreases endIdx
+pure func secSessionNotFoundBelow(actions []mgsContracts.ProcessedClientAction, endIdx int) bool {
+	return endIdx <= 0 ||
+		!actions[endIdx - 1].IsSuccessfulSecureSession() && secSessionNotFoundBelow(actions, endIdx - 1)
+}
+
+ghost
+requires noPerm < p
+requires 0 <= idx && idx < len(actions)
+requires forall i int :: { actions[i] } 0 <= i && i < len(actions) ==> acc(actions[i].Mem(), p)
+requires secSessionNotFoundBelow(actions, idx)
+requires actions[idx].IsSuccessfulSecureSession()
+ensures  forall i int :: { actions[i] } 0 <= i && i < len(actions) ==> acc(actions[i].Mem(), p)
+ensures  mgsContracts.containsSecureSession(actions, 0)
+ensures  mgsContracts.getSecureSessionIndex(actions, 0) == idx
+func containsSecureSessionLemma(actions []mgsContracts.ProcessedClientAction, idx int, p perm) {
+	containsSecureSessionHelperLemma(actions, idx, p, 0)
+}
+
+ghost
+requires noPerm < p
+requires 0 <= startIdx && startIdx <= idx && idx < len(actions)
+requires forall i int :: { actions[i] } 0 <= i && i < len(actions) ==> acc(actions[i].Mem(), p)
+requires secSessionNotFoundBelow(actions, idx)
+requires actions[idx].IsSuccessfulSecureSession()
+ensures  forall i int :: { actions[i] } 0 <= i && i < len(actions) ==> acc(actions[i].Mem(), p)
+ensures  mgsContracts.containsSecureSession(actions, startIdx)
+ensures  mgsContracts.getSecureSessionIndex(actions, startIdx) == idx
+decreases len(actions) - startIdx
+func containsSecureSessionHelperLemma(actions []mgsContracts.ProcessedClientAction, idx int, p perm, startIdx int) {
+	if startIdx != idx {
+		containsSecureSessionHelperLemma(actions, idx, p/2, startIdx + 1)
+		secSessionNotFoundLemma(actions, idx, p/2, startIdx)
+	}
+}
+
+ghost
+requires noPerm < p
+requires 0 <= startIdx && startIdx < idx && idx < len(actions)
+requires forall i int :: { actions[i] } 0 <= i && i < len(actions) ==> acc(actions[i].Mem(), p)
+requires secSessionNotFoundBelow(actions, idx)
+ensures  forall i int :: { actions[i] } 0 <= i && i < len(actions) ==> acc(actions[i].Mem(), p)
+ensures  !actions[startIdx].IsSuccessfulSecureSession()
+decreases idx
+func secSessionNotFoundLemma(actions []mgsContracts.ProcessedClientAction, idx int, p perm, startIdx int) {
+	if startIdx + 1 != idx {
+		secSessionNotFoundLemma(actions, idx - 1, p/2, startIdx)
+	}
+}
+@*/
+
+/*
+ghost
+decreases
+pure func IsSuccessfulSecureSession(action mgsContracts.ProcessedClientActionAdt) bool {
+	return action.ActionType == mgsContracts.SecureSession &&
+		action.ActionStatus == mgsContracts.Success
+}
 
-	for _, action := range handshakeResponse.ProcessedClientActions {
+ghost
+requires 0 <= startIdx && startIdx <= len(actions)
+decreases len(actions) - startIdx
+pure func containsSecureSession(actions seq[mgsContracts.ProcessedClientActionAdt], startIdx int) bool {
+	return startIdx == len(actions) ? false :
+		(IsSuccessfulSecureSession(actions[startIdx]) ?
+			true : containsSecureSession(actions, startIdx + 1))
+}
+
+ghost
+requires 0 <= startIdx && startIdx <= len(actions)
+requires containsSecureSession(actions, startIdx)
+ensures  startIdx <= res && res < len(actions)
+ensures  IsSuccessfulSecureSession(actions[res])
+decreases len(actions) - startIdx
+pure func getSecureSessionIndex(actions seq[mgsContracts.ProcessedClientActionAdt], startIdx int) (res int) {
+	return IsSuccessfulSecureSession(actions[startIdx]) ?
+			startIdx : getSecureSessionIndex(actions, startIdx + 1)
+}
+
+ghost
+requires endIdx <= len(actions)
+decreases endIdx
+pure func secSessionNotFoundBelow(actions seq[mgsContracts.ProcessedClientActionAdt], endIdx int) bool {
+	return endIdx <= 0 ||
+		(!IsSuccessfulSecureSession(actions[endIdx - 1]) &&
+			secSessionNotFoundBelow(actions, endIdx - 1))
+}
+
+ghost
+requires 0 <= idx && idx < len(actions)
+requires secSessionNotFoundBelow(actions, idx)
+requires IsSuccessfulSecureSession(actions[idx])
+ensures  containsSecureSession(actions, 0)
+ensures  getSecureSessionIndex(actions, 0) == idx
+func containsSecureSessionLemma(actions seq[mgsContracts.ProcessedClientActionAdt], idx int) {
+	containsSecureSessionHelperLemma(actions, idx, 0)
+}
+
+ghost
+requires 0 <= startIdx && startIdx <= idx && idx < len(actions)
+requires secSessionNotFoundBelow(actions, idx)
+requires IsSuccessfulSecureSession(actions[idx])
+ensures  containsSecureSession(actions, startIdx)
+ensures  getSecureSessionIndex(actions, startIdx) == idx
+decreases len(actions) - startIdx
+func containsSecureSessionHelperLemma(actions seq[mgsContracts.ProcessedClientActionAdt], idx int, startIdx int) {
+	if startIdx != idx {
+		containsSecureSessionHelperLemma(actions, idx, startIdx + 1)
+		secSessionNotFoundLemma(actions, idx, startIdx)
+	}
+}
+
+ghost
+requires 0 <= startIdx && startIdx < idx && idx < len(actions)
+requires secSessionNotFoundBelow(actions, idx)
+ensures  !IsSuccessfulSecureSession(actions[startIdx])
+decreases idx
+func secSessionNotFoundLemma(actions seq[mgsContracts.ProcessedClientActionAdt], idx int, startIdx int) {
+	if startIdx + 1 != idx {
+		secSessionNotFoundLemma(actions, idx - 1, startIdx)
+	}
+}
+
+ghost
+requires noPerm < p
+requires acc(handshakeResponsePayload.Mem(), p)
+requires 0 <= startIdx && startIdx <= unfolding acc(handshakeResponsePayload.Mem(), p) in len(handshakeResponsePayload.ProcessedClientActions)
+ensures acc(handshakeResponsePayload.Mem(), p)
+ensures unfolding acc(handshakeResponsePayload.Mem(), p) in
+	let res := old(handshakeResponsePayload.Adt(startIdx)) in
+	(len(res) == len(handshakeResponsePayload.ProcessedClientActions) - startIdx) &&
+	(forall i int :: { res[i] } 0 <= i && i < len(res) ==> res[i] == handshakeResponsePayload.ProcessedClientActions[startIdx + i].Adt())
+func HandshakeResponsePayloadAdtLemma(handshakeResponsePayload *mgsContracts.HandshakeResponsePayload, startIdx int, p perm) {
+	actionsLen := unfolding acc(handshakeResponsePayload.Mem(), p/2) in len(handshakeResponsePayload.ProcessedClientActions)
+	if startIdx != actionsLen {
+		HandshakeResponsePayloadAdtLemma(handshakeResponsePayload, startIdx + 1, p/2)
+	}
+}
+*/
+
+// handleHandshakeResponse is the handler for payload type HandshakeResponse
+// @ requires log != nil && dc.MemTransfer(encryptionEnabled)
+// @ requires streamDataMessage.Mem()
+// @ requires unfolding streamDataMessage.Mem() in mgsContracts.PayloadType(streamDataMessage.PayloadType) == mgsContracts.HandshakeResponse
+// @ requires unfolding dc.MemTransfer(encryptionEnabled) in by.gamma(dc.getInFactT()) == streamDataMessage.Abs()
+// @ preserves acc(log.Mem(), _) && dc.RecvRoutineMem()
+// @ ensures  streamDataMessage.Mem()
+// @ ensures  err != nil ==> err.ErrorMem()
+func (dc *dataChannel) handleHandshakeResponse(log logger.T, streamDataMessage *mgsContracts.AgentMessage, encryptionEnabled bool) (err error) {
+	logDebug(log, "Received Handshake Response.")
+	// var handshakeResponse /*@ @ @*/ mgsContracts.HandshakeResponsePayload
+	// fold handshakeResponse.Mem()
+	//@ unfold streamDataMessage.Mem()
+	// if err := json.Unmarshal(streamDataMessage.Payload, &handshakeResponse /*@, perm(1/2) @*/); err != nil {
+	// 	//@ fold streamDataMessage.Mem()
+	// 	return fmtErrorf("Unmarshalling of HandshakeResponse message failed, %s", err /*@, perm(1/1) @*/)
+	// }
+	handshakeResponse, err := unmarshalHandshakeResponse(streamDataMessage.Payload /*@, perm(1/2) @*/)
+	if err != nil {
+		//@ fold streamDataMessage.Mem()
+		return fmtErrorf("Unmarshalling of HandshakeResponse message failed, %s", err /*@, perm(1/1) @*/)
+	}
+	//@ assert abs.Abs(streamDataMessage.Payload) == handshakeResponse.Abs()
+	// assert handshakeResponse.ContainsSecureSession()
+	// assert handshakeResponse.Abs() ==
+	//@ ghost var firstActionAbs by.Bytes
+	/*@
+	ghost if handshakeResponse.ContainsSecureSession() {
+		// assert unfolding handshakeResponse.Mem() in mgsContracts.containsSecureSession(handshakeResponse.ProcessedClientActions, 0)
+		assert unfolding handshakeResponse.Mem() in len(handshakeResponse.ProcessedClientActions) == 1
+		// firstActionAbs := unfolding handshakeResponse.Mem() in handshakeResponse.ProcessedClientActions[mgsContracts.getSecureSessionIndex(handshakeResponse.ProcessedClientActions, 0)].Abs()
+		// assert abs.Abs(streamDataMessage.Payload) == by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), firstActionAbs)
+		firstActionAbs = unfolding handshakeResponse.Mem() in handshakeResponse.ProcessedClientActions[0].Abs()
+		assert abs.Abs(streamDataMessage.Payload) == by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), firstActionAbs)
+	}
+	@*/
+	// assert abs.Abs(streamDataMessage.Payload) == by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), handshakeResponse.Abs())
+	//@ msgPayloadB := abs.Abs(streamDataMessage.Payload)
+	//@ fold streamDataMessage.Mem()
+	// absActions := handshakeResponse.Adt(0)
+	// HandshakeResponsePayloadAdtLemma(handshakeResponse, 0, perm(1/2))
+	//@ unfold handshakeResponse.Mem()
+
+	i := 0
+	actions := handshakeResponse.ProcessedClientActions
+	// assert secSessionNotFoundBelow(actions, 0)
+	// assert secSessionNotFoundBelow(absActions, 0)
+	secureSessionActionIndex := -1
+	//@ invariant 0 <= i &&  i <= len(actions)
+	//@ invariant dc.MemTransfer(encryptionEnabled)
+	//@ invariant acc(log.Mem(), _)
+	//@ invariant acc(streamDataMessage.Mem(), 1/2)
+	//@ invariant forall j int :: { actions[j] } 0 <= j && j < len(actions) ==> acc(actions[j].Mem(), 1/2) // && actions[j].Adt() == absActions[j]
+	// invariant 0 <= secureSessionActionIndex ==>
+	//		secureSessionActionIndex < len(actions) &&
+	// 	mgsContracts.containsSecureSession(actions, 0) &&
+	// 	mgsContracts.getSecureSessionIndex(actions, 0) == secureSessionActionIndex
+	// invariant secureSessionActionIndex < 0 ==> (forall j int :: { !actions[j].IsSuccessfulSecureSession() } 0 <= j && j < i ==> !actions[j].IsSuccessfulSecureSession())
+	// invariant secureSessionActionIndex < 0 ==> secSessionNotFoundBelow(actions, i)
+	// invariant secureSessionActionIndex < 0 ==> secSessionNotFoundBelow(absActions, i)
+	//@ invariant msgPayloadB == unfolding acc(streamDataMessage.Mem(), 1/2) in abs.Abs(streamDataMessage.Payload)
+	//@ invariant mgsContracts.containsSecureSession(actions, 0) ==> firstActionAbs == actions[0].Abs()
+	//@ invariant mgsContracts.containsSecureSession(actions, 0) ==>
+	//@		(unfolding acc(streamDataMessage.Mem(), 1/2) in abs.Abs(streamDataMessage.Payload)) == by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), actions[0].Abs())
+	for i = range actions {
+		//@ unfold acc(actions[i].Mem(), 1/2)
+		action := actions[i]
 		var err error
 		if action.ActionStatus != mgsContracts.Success {
-			err = fmt.Errorf("%s failed on client with status %v error: %s",
+			err = fmtErrorfActionTypeActionStatusActionError("%s failed on client with status %v error: %s",
 				action.ActionType, action.ActionStatus, action.Error)
+			//@ fold acc(actions[i].Mem(), 1/2)
 		} else {
 			switch action.ActionType {
-			case mgsContracts.KMSEncryption:
-				err = dataChannel.finalizeKMSEncryption(log, action.ActionResult)
-				break
+			case mgsContracts.SecureSession:
+				//@ fold acc(actions[i].Mem(), 1/2)
+				if secureSessionActionIndex < 0 {
+					// this is the *first* action we found with matching type and status
+					secureSessionActionIndex = i
+					// assert i < len(actions)
+					// assert actions[i].Type() == mgsContracts.SecureSession
+					// assert actions[i].Status() == mgsContracts.Success
+					//@ assert mgsContracts.containsSecureSession(actions, i)
+					//@ containsSecureSessionLemma(actions, i, perm(1/2))
+					// containsSecureSessionLemma(absActions, i)
+					//@ assert mgsContracts.containsSecureSession(actions, 0)
+					//@ assert mgsContracts.getSecureSessionIndex(actions, 0) == i
+					// assert
+				} else {
+					// this is not necessarily true since the current index
+					// could be a duplicate but successful secure session action:
+					// assert secSessionNotFoundBelow(actions, i + 1)
+				}
+
+				if !encryptionEnabled {
+					err = fmtError("unexpected action type 'SecureSession' because encryption is disabled")
+					break
+				}
+
+				err = dc.processSecureSessionResponse(log, &actions[i])
+				if err != nil {
+					break
+				}
+			// case mgsContracts.KMSEncryption:
+			// 	err = dc.finalizeKMSEncryption(log, action.ActionResult)
+			// 	break
 			case mgsContracts.SessionType:
+				//@ fold acc(actions[i].Mem(), 1/2)
 				break
 			default:
-				log.Warnf("Unknown handshake client action found, %s", action.ActionType)
+				//@ fold acc(actions[i].Mem(), 1/2)
+				logWarnfActionType(log, "Unknown handshake client action found, %s", action.ActionType)
 			}
 		}
 		if err != nil {
-			log.Error(err)
+			logError(log, err /*@, perm(1/1) @*/)
 			// Cancel the session because handshake FAILED
-			dataChannel.cancelFlag.Set(task.Canceled)
+			//@ unfold dc.MemTransfer(encryptionEnabled)
+			dc.dataStream.CancelSession( /*@ perm(1/2) @*/ )
 			// Set handshake error. Initiate handshake waits on handshake.responseChan and will return this error when channel returns.
-			dataChannel.handshake.error = err
+			dc.hs.error = err
+			//@ fold dc.MemTransfer(encryptionEnabled)
 		}
 	}
-	dataChannel.handshake.clientVersion = handshakeResponse.ClientVersion
-	log.Infof("Client side session manager plugin version is: %s", handshakeResponse.ClientVersion)
-	dataChannel.handshake.responseChan <- true
+	//@ unfold dc.MemTransfer(encryptionEnabled)
+	dc.hs.clientVersion = handshakeResponse.ClientVersion
+	logInfofString(log, "Client side session manager plugin version is: %s", handshakeResponse.ClientVersion)
+	//@ fold dc.MemTransfer(encryptionEnabled)
+	//@ fold ResponseChanInv!<dc, _!>(encryptionEnabled)
+	//@ unfold dc.RecvRoutineMem()
+	dc.hs.responseChan <- encryptionEnabled
+	//@ fold dc.RecvRoutineMem()
 	return nil
 }
 
-// handleEncryptionChallengeResponse is the handler for payload type EncryptionChallengeRequest
-func (dataChannel *DataChannel) handleEncryptionChallengeResponse(log log.T, streamDataMessage mgsContracts.AgentMessage) error {
-	log.Debug("Received Encryption Challenge Response.")
-	var encChallengeResponse mgsContracts.EncryptionChallengeResponse
-	if err := json.Unmarshal(streamDataMessage.Payload, &encChallengeResponse); err != nil {
-		return fmt.Errorf("Unmarshalling of EncryptionChallengeResponse message failed, %s AND %v", streamDataMessage.Payload, err)
+// @ trusted
+// @ requires noPerm < p
+// @ preserves acc(bytes.SliceMem(payload), p)
+// @ ensures  handshakeResponse.Mem()
+// @ ensures  err == nil && abs.Abs(payload) == handshakeResponse.Abs()
+// @ ensures  err != nil ==> err.ErrorMem()
+func unmarshalHandshakeResponse(payload []byte /*@, p perm @*/) (handshakeResponse *mgsContracts.HandshakeResponsePayload, err error) {
+	handshakeResponse = &mgsContracts.HandshakeResponsePayload{}
+	//@ fold handshakeResponse.Mem()
+	err = json.Unmarshal(payload, handshakeResponse /*@, p/2 @*/)
+	return
+}
+
+// @ trusted
+// @ requires noPerm < p
+// @ preserves acc(bytes.SliceMem(payload), p)
+// @ ensures  secureSessionResponse.Mem()
+// @ ensures  err == nil && abs.Abs(payload) == secureSessionResponse.Abs()
+// @ ensures  err != nil ==> err.ErrorMem()
+func unmarshalSecureSessionResponse(payload []byte /*@, p perm @*/) (secureSessionResponse *mgsContracts.SecureSessionResponse, err error) {
+	secureSessionResponse = &mgsContracts.SecureSessionResponse{}
+	//@ fold secureSessionResponse.Mem()
+	err = json.Unmarshal(payload, secureSessionResponse /*@, p/2 @*/)
+	return
+}
+
+// @ requires log != nil
+// @ preserves dc.MemTransfer(true) && acc(log.Mem(), _) && acc(action.Mem(), 1/4) && action.IsSuccessfulSecureSession()
+func (dc *dataChannel) processSecureSessionResponse(log logger.T, action *mgsContracts.ProcessedClientAction) (err error) {
+	//@ unfold acc(action.Mem(), 1/4)
+	resp, err := unmarshalSecureSessionResponse(action.ActionResult /*@, perm(1/8) @*/)
+	//@ fold acc(action.Mem(), 1/4)
+	if err != nil {
+		return fmtErrorf("failed to unmarshal action to SecureSessionResponse: %v", err /*@, perm(1/1) @*/)
 	}
 
-	log.Info("Verifying encryption challenge..")
-	responseChallenge, err := dataChannel.blockCipher.DecryptWithAESGCM(encChallengeResponse.Challenge)
+	// decode the client share
+	//@ unfold resp.Mem()
+	//@ unfold dc.MemTransfer(true)
+	sharedSecret, err /*@, clientSecretB @*/ := unmarshalAndCheckClientShare(resp.ClientShare, dc.state.agentSecret /*@, perm(1/2) @*/)
 	if err != nil {
-		dataChannel.handshake.error = err
+		logError(log, err /*@, perm(1/1) @*/)
 		return err
 	}
-	if !bytes.Equal(responseChallenge, dataChannel.handshake.encryptionChallenge) {
-		err = fmt.Errorf("Encryption challenge does not match!")
-		dataChannel.handshake.error = err
+
+	//@ receivedMsgT := dc.getInFactT()
+	// assert by.gamma(receivedMsgT) == by.gamma(Term_M2(rid, by.oneTerm(sidR), ltkT, pskT, ekiT, c3T, h4T, by.oneTerm(epkR), by.oneTerm(mac1), by.oneTerm(mac2)))
+	//@ clientSecretT := by.oneTerm(clientSecretB)
+	//@ xT := dc.getAgentShareT()
+	//@ sigYB := by.msgB(resp.Signature)
+	//@ sigYT := by.oneTerm(sigYB)
+	//@ clientLtKeyIdB := by.msgB(resp.ClientLTKeyARN)
+	//@ clientLtKeyIdT := by.oneTerm(clientLtKeyIdB)
+	//@ assert by.gamma(receivedMsgT) == by.gamma(tm.pair(tm.pubTerm(pub.const_SecureSessionResponse_pub()), tm.pair(tm.exp(tm.pubTerm(pub.const_g_pub()), clientSecretT), tm.pair(sigYT, tm.pair(clientLtKeyIdT, tm.hash(tm.exp(tm.exp(tm.pubTerm(pub.const_g_pub()), clientSecretT), xT)))))))
+
+	// verify client signature
+	sig, err := base64.StdEncoding.DecodeString(resp.Signature)
+	if err != nil {
+		return fmtErrorf("failed to decode signature: %v", err /*@, perm(1/1) @*/)
+	}
+
+	agentId := dc.dataStream.GetInstanceId()
+	//@ fold dc.MemTransfer(true)
+	clientSignPayload := &mgsContracts.SignClientSharePayload{
+		ClientShare: resp.ClientShare,
+		AgentId:     agentId,
+	}
+
+	//@ fold clientSignPayload.Mem()
+	clientSignPayloadBytes, err := json.Marshal(clientSignPayload /*@, perm(1/2) @*/)
+	if err != nil {
+		err = fmtErrorf("failed to encode client sign payload: %v", err /*@, perm(1/1) @*/)
+		logError(log, err /*@, perm(1/1) @*/)
 		return err
 	}
+
+	//@ unfold dc.MemTransfer(true)
+	ok, err := dc.state.kmsService.Verify(resp.ClientLTKeyARN, clientSignPayloadBytes, sig /*@, perm(1/2) @*/)
+	//@ fold dc.MemTransfer(true)
+	if !ok {
+		return fmtError("failed to verify signature")
+	}
 	if err != nil {
-		dataChannel.handshake.encryptionConfirmedChan <- false
-	} else {
-		dataChannel.handshake.encryptionConfirmedChan <- true
+		return fmtErrorf("failed to verify signature: %v", err /*@, perm(1/1) @*/)
 	}
-	return nil
-}
 
-// SkipHandshake is used to skip handshake if the plugin decides it is not necessary
-func (dataChannel *DataChannel) SkipHandshake(log log.T) {
-	log.Info("Skipping handshake.")
-	dataChannel.handshake.skipped = true
-}
+	// generate and store the shared secret
+	//@ unfold dc.MemTransfer(true)
+	dc.state.sharedSecret = sharedSecret
+
+	// hash the shared secret to obtain the session identifier
+	dc.state.sessionID = computeSHA384(dc.state.sharedSecret /*@, 1/2 @*/)
+
+	logDebugfString(log, "agent computed session ID: %v", base64.StdEncoding.EncodeToString(dc.state.sessionID /*@, perm(1/1) @*/))
+	// decode the session ID
+	var sessionIDBytes []byte
+	sessionIDBytes, err = base64.StdEncoding.DecodeString(resp.SessionID)
+	if err != nil {
+		//@ fold dc.MemTransfer(true)
+		err = fmtErrorf("failed to decode server session id: %v", err /*@, perm(1/1) @*/)
+		logError(log, err /*@, perm(1/1) @*/)
+		return err
+	}
+
+	if !bytes.Equal(dc.state.sessionID, sessionIDBytes) {
+		err = fmtErrorfBytes2("session ID mismatch: session ID %s does not match client session ID %s", sessionIDBytes, dc.state.sessionID /*@, perm(1/1) @*/)
+		//@ fold dc.MemTransfer(true)
+		logError(log, err /*@, perm(1/1) @*/)
+		return err
+	}
 
-// finalizeKMSEncryption parses encryption parameters returned from the client and sets up encryption
-func (dataChannel *DataChannel) finalizeKMSEncryption(log log.T, actionResult json.RawMessage) error {
-	encryptionResponse := mgsContracts.KMSEncryptionResponse{}
+	// use the shared secret to generate read and write keys
+	dc.state.agentWriteKey, err = computeKdf(dc.state.sharedSecret, true /*@, 1/2 @*/)
+	if err != nil {
+		return err
+	}
+	dc.state.agentReadKey, err = computeKdf(dc.state.sharedSecret, false /*@, 1/2 @*/)
+	if err != nil {
+		return err
+	}
+
+	agentReadKey := dc.state.agentReadKey
+	encodedAgentReadKey := base64.RawStdEncoding.EncodeToString(agentReadKey /*@, perm(1/2) @*/)
+	agentWriteKey := dc.state.agentWriteKey
+	encodedAgentWriteKey := base64.RawStdEncoding.EncodeToString(agentWriteKey /*@, perm(1/2) @*/)
+	logDebugfString(log, "agent read key: %s", encodedAgentReadKey)
+	logDebugfString(log, "agent write key: %s", encodedAgentWriteKey)
 
-	if err := json.Unmarshal(actionResult, &encryptionResponse); err != nil {
+	// create ciphertext containing session keys:
+	sessionKeys := &mgsContracts.SessionKeys{
+		AgentReadKey:  encodedAgentReadKey,
+		AgentWriteKey: encodedAgentWriteKey,
+	}
+	//@ fold sessionKeys.Mem()
+	sessionKeysBytes, err := json.Marshal(sessionKeys /*@, perm(1/2) @*/)
+	if err != nil {
+		err = fmtErrorf("failed to encode session keys: %v", err /*@, perm(1/1) @*/)
+		logError(log, err /*@, perm(1/1) @*/)
 		return err
 	}
 
-	sessionId := dataChannel.ChannelId // ChannelId is SessionId
-	if err := dataChannel.blockCipher.UpdateEncryptionKey(log, encryptionResponse.KMSCipherTextKey, sessionId, dataChannel.InstanceId); err != nil {
-		return fmt.Errorf("Fetching data key failed: %s", err)
+	//@ cryptoRand.GetReaderMem()
+	encryptedSessionKeys, err := rsa.EncryptPKCS1v15(cryptoRand.Reader, dc.logLTPk, sessionKeysBytes /*@, perm(1/2) @*/)
+	if err != nil {
+		return fmtErrorf("failed to encrypt session keys: %v", err /*@, perm(1/1) @*/)
 	}
-	dataChannel.encryptionEnabled = true
+	encodedEncryptedSessionKeys := base64.StdEncoding.EncodeToString(encryptedSessionKeys /*@, perm(1/2) @*/)
+	logInfofString(log, "encrypted base-64-encoded session keys: %s", encodedEncryptedSessionKeys)
+
+	// sign ciphertext containing session keys using KMS:
+	signSessionKeysPayload := &mgsContracts.SignSessionKeysPayload{
+		EncryptedSessionKeys: encodedEncryptedSessionKeys,
+		ClientId:             dc.dataStream.GetClientId(),
+	}
+
+	//@ fold signSessionKeysPayload.Mem()
+	signSessionKeysPayloadBytes, err := json.Marshal(signSessionKeysPayload /*@, perm(1/2) @*/)
+	if err != nil {
+		err = fmtErrorf("failed to encode sign session keys payload: %v", err /*@, perm(1/1) @*/)
+		logError(log, err /*@, perm(1/1) @*/)
+		return err
+	}
+
+	/*@
+	ghost var t0 pl.Place
+	ghost var rid, agentIdT, kmsId, messageT, m tm.Term
+	@*/
+	sigSessionKeys, err /*@, signatureT @*/ := dc.state.kmsService.Sign(dc.agentLTKeyARN, signSessionKeysPayloadBytes /*@, perm(1/2), t0, rid, agentIdT, kmsId, messageT, m @*/)
+	if err != nil {
+		err = fmtErrorf("failed to sign session keys payload: %v", err /*@, perm(1/1) @*/)
+		logError(log, err /*@, perm(1/1) @*/)
+		return err
+	}
+
+	encodedSigSessionKeys := base64.StdEncoding.EncodeToString(sigSessionKeys /*@, perm(1/2) @*/)
+
+	// send ciphertext containing session keys and the corresponding signature to the log server:
+	encryptedSessionKeysPayload := &mgsContracts.EncryptedSessionKeysPayload{
+		AgentLTKeyARN:        dc.agentLTKeyARN,
+		ClientId:             dc.dataStream.GetClientId(),
+		EncryptedSessionKeys: encodedEncryptedSessionKeys,
+		Signature:            encodedSigSessionKeys,
+	}
+	//@ fold encryptedSessionKeysPayload.Mem()
+	encryptedSessionKeysPayloadBytes, err := json.Marshal(encryptedSessionKeysPayload /*@, perm(1/2) @*/)
+	if err != nil {
+		err = fmtErrorf("failed to encode encrypted session keys payload: %v", err /*@, perm(1/1) @*/)
+		logError(log, err /*@, perm(1/1) @*/)
+		return err
+	}
+	encodedEncryptedSessionKeysPayloadBytes := base64.StdEncoding.EncodeToString(encryptedSessionKeysPayloadBytes /*@, perm(1/2) @*/)
+	logInfofString(log, "encrypted session keys payload that should be sent to log server: %s", encodedEncryptedSessionKeysPayloadBytes)
+
+	// TODO: actually send `encodedEncryptedSessionKeysPayloadBytes` to the log server!
+
+	dc.encryptionEnabled = true
+
+	//@ ghost var readKeyT tm.Term
+	//@ ghost var writeKeyT tm.Term
+	if err = dc.blockCipher.UpdateEncryptionKeys(log, dc.state.agentReadKey, dc.state.agentWriteKey /*@, perm(1/2), readKeyT, writeKeyT @*/); err != nil {
+		//@ fold dc.MemTransfer(true)
+		err = fmtErrorf("failed to update block cipher: %v", err /*@, perm(1/1) @*/)
+		logError(log, err /*@, perm(1/1) @*/)
+		return err
+	}
+	//@ fold dc.MemTransfer(true)
 	return nil
 }
 
-var newBlockCipher = func(context context.T, kmsKeyId string) (blockCipher crypto.IBlockCipher, err error) {
-	return crypto.NewBlockCipher(context, kmsKeyId)
+// @ trusted
+// @ requires noPerm < p && p <= writePerm
+// @ preserves acc(bytes.SliceMem(agentSecret), p)
+// @ ensures err == nil ==> bytes.SliceMem(sharedSecret)
+// the following postcondition expresses that `IsOnCurve` guarantees that `clientShare` is a valid
+// DH pubic key. Instead of existentially quantifying over the corresponding private key, we assume
+// `privB` is the corresponding witness
+// @ ensures err == nil ==> by.msgB(clientShare) == by.expB(by.generatorB(), privB)
+// @ ensures err == nil ==> abs.Abs(sharedSecret) == by.expB(by.expB(by.generatorB(), privB), abs.Abs(agentSecret))
+// @ ensures err != nil ==> err.ErrorMem()
+func unmarshalAndCheckClientShare(clientShare string, agentSecret []byte /*@, p perm @*/) (sharedSecret []byte, err error /*@, privB by.Bytes @*/) {
+	var clientShareBytes []byte
+	clientShareBytes, err = base64.StdEncoding.DecodeString(clientShare)
+	if err != nil {
+		err = fmtErrorf("failed to decode server share: %v", err /*@, perm(1/1) @*/)
+		return
+	}
+
+	x, y := elliptic.UnmarshalCompressed(elliptic.P384(), clientShareBytes /*@, perm(1/2) @*/)
+
+	// check that the client share is on the curve
+	if !elliptic.P384().IsOnCurve(x, y /*@, perm(1/2) @*/) {
+		err = fmtError("client share is not on the curve")
+		return
+	}
+
+	ss, _ := elliptic.P384().ScalarMult(x, y, agentSecret /*@, p/2 @*/) // TODO: Double check it's fine to just use x
+	sharedSecret = ss.Bytes( /*@ perm(1/2) @*/ )
+	return
+}
+
+// SkipHandshake is used to skip handshake if the plugin decides it is not necessary
+// @ requires log != nil
+// @ preserves dc.Mem() && acc(log.Mem(), _)
+// @ ensures err == nil ==> dc.getState() == HandshakeSkipped
+func (dc *dataChannel) SkipHandshake(log logger.T) (err error) {
+	if dc.getState() != Initialized {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
+	}
+	logInfo(log, "Skipping handshake.")
+	//@ unfold dc.Mem()
+	dc.hs.skipped = true
+	dc.dataChannelState = HandshakeSkipped
+	//@ fold dc.Mem()
+	return
 }
 
 // PerformHandshake performs handshake to share version string and encryption information with clients like cli/console
-func (dataChannel *DataChannel) PerformHandshake(log log.T,
+// Note that sessionplugin.go first calls `NewDataChannel` followed by at most 1 call to `PerformHandshake`.
+// Hence, we can require in the specification that no other handshake is currently on-going for `dataChannel` without
+// restricting the current client of `DataChannel`.
+// @ requires log != nil
+// @ requires encryptionEnabled == assumeEncryptionEnabledForVerification()
+// @ preserves dc.Mem() && acc(log.Mem(), _)
+// @ ensures err == nil ==> dc.getState() == HandshakeCompleted
+func (dc *dataChannel) PerformHandshake(log logger.T,
 	kmsKeyId string,
 	encryptionEnabled bool,
 	sessionTypeRequest mgsContracts.SessionTypeRequest) (err error) {
 
-	if encryptionEnabled {
-		if dataChannel.blockCipher, err = newBlockCipher(dataChannel.context, kmsKeyId); err != nil {
-			return fmt.Errorf("Initializing BlockCipher failed: %s", err)
-		}
+	if dc.getState() != Initialized {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
 	}
 
-	dataChannel.handshake.handshakeStartTime = time.Now()
-	dataChannel.encryptionEnabled = encryptionEnabled
+	logDebug(log, "PerformHandshake")
+
+	//@ unfold dc.Mem()
 
-	log.Info("Initiating Handshake")
-	handshakeRequestPayload :=
-		dataChannel.buildHandshakeRequestPayload(log, dataChannel.encryptionEnabled, sessionTypeRequest)
-	if err := dataChannel.sendHandshakeRequest(log, handshakeRequestPayload); err != nil {
+	if encryptionEnabled {
+		// if dc.blockCipher, err = newBlockCipher(dc.context, kmsKeyId); err != nil {
+		// 	return fmtErrorf("Initializing BlockCipher failed: %s", err)
+		// }
+		logInfo(log, "Encryption enabled: initializing block cipher")
+		// dc.blockCipher = &cryptolib.BlockCipherT{}
+	}
+	// initializing the block cipher independently of `encryptionEnabled` simplifies reasoning
+	dc.blockCipher = &cryptolib.BlockCipherT{}
+	// we inhale the permissions for the modeled ghost fields of this block cipher:
+	//@ inhale dc.blockCipher.EncKeyTMem() && dc.blockCipher.DecKeyTMem()
+	//@ fold dc.blockCipher.Mem()
+
+	dc.hs.handshakeStartTime = time.Now()
+	dc.encryptionEnabled = encryptionEnabled
+	dc.dataChannelState = BlockCipherInitialized
+	//@ fold dc.Mem()
+
+	logInfo(log, "Initiating Handshake")
+	handshakeRequestPayload, err :=
+		dc.buildHandshakeRequestPayload(log, encryptionEnabled, sessionTypeRequest)
+	if err != nil {
+		return err
+	}
+	if err := dc.sendHandshakeRequest(log, handshakeRequestPayload); err != nil {
 		return err
 	}
 
-	// Block until handshake response is received or handshake times out
-	select {
-	case <-dataChannel.handshake.responseChan:
-		{
-			if dataChannel.handshake.error != nil {
-				return dataChannel.handshake.error
-			}
+	// notify Go routing handling received messages that it can process a message:
+	//@ unfold dc.Mem()
+	startReceivingChan := dc.hs.startReceivingChan
+	responseChan := dc.hs.responseChan
+	//@ fold dc.MemTransfer(encryptionEnabled)
+	var payload MessageReceptionPayload
+	if encryptionEnabled {
+		payload = MessageReceptionPayload{
+			status: ReceiveHandshakeResponeEncryptionEnabled,
 		}
-	case <-time.After(handshakeTimeout):
-		{
-			// If handshake times out here this usually means that the client does not understand handshake or something
-			// failed critically when processing handshake request.
-			return errors.New("Handshake timed out. Please ensure that you have the latest version of the session manager plugin.")
+	} else {
+		payload = MessageReceptionPayload{
+			status: ReceiveHandshakeResponeEncryptionDisabled,
 		}
 	}
+	//@ fold StartReceivingChanInv!<dc, _!>(payload)
+	startReceivingChan <- payload
 
-	// If encryption was enabled send encryption challenge and block until challenge is received
-	if dataChannel.encryptionEnabled {
-		dataChannel.sendEncryptionChallenge(log)
-		select {
-		case <-dataChannel.handshake.encryptionConfirmedChan:
-			if dataChannel.handshake.error != nil {
-				return dataChannel.handshake.error
-			}
-			log.Info("Encryption challenge confirmed.")
-		case <-time.After(handshakeTimeout):
-			{
-				// If handshake times out here this means the cli is too old and does not understand handshake protocol.
-				return errors.New("Timed out waiting for encryption challenge.")
-			}
-		}
+	// Block until handshake response is received or handshake times out
+	res, err := dc.tryReceiveResponseAlt(responseChan, handshakeTimeout)
+	if err != nil {
+		dc.dataChannelState = Erroneous
+		//@ fold dc.Mem()
+		// If handshake times out here this usually means that the client does not understand handshake or something
+		// failed critically when processing handshake request.
+		return errors.New("Handshake timed out. Please ensure that you have the latest version of the session manager plugin.")
+	}
+	// we send the flag `encryptionEnabled` back via the channel such that we are able to express the data channel's
+	// state. This flag is expected to be identical to `encryptionEnabled`:
+	if res != encryptionEnabled {
+		dc.dataChannelState = Erroneous
+		//@ fold dc.Mem()
+		return errors.New("Unexpected result from processing handshake response")
+	}
+	//@ unfold ResponseChanInv!<dc, _!>(res)
+	//@ unfold dc.MemTransfer(encryptionEnabled)
+	err = dc.hs.error
+	if err != nil {
+		//@ fold dc.Mem()
+		return err
 	}
+	logDebug(log, "Handshake response received")
 
-	dataChannel.handshake.handshakeEndTime = time.Now()
-	handshakeCompletePayload := dataChannel.buildHandshakeCompletePayload(log)
-	if err := dataChannel.sendHandshakeComplete(log, handshakeCompletePayload); err != nil {
+	dc.hs.handshakeEndTime = time.Now()
+	//@ fold dc.Mem()
+	handshakeCompletePayload, err := dc.buildHandshakeCompletePayload(log)
+	if err != nil {
 		return err
 	}
-	dataChannel.handshake.complete = true
-	log.Info("Handshake successfully completed.")
+	if err := dc.sendHandshakeComplete(log, handshakeCompletePayload); err != nil {
+		return err
+	}
+	//@ unfold dc.Mem()
+	dc.hs.complete = true
+	dc.dataChannelState = HandshakeCompleted
+	logInfo(log, "Handshake successfully completed.")
+	//@ fold dc.Mem()
 	return
 }
 
 // buildHandshakeRequestPayload builds payload for HandshakeRequest
-func (dataChannel *DataChannel) buildHandshakeRequestPayload(log log.T,
+// @ requires log != nil && dc.Mem() && dc.getState() == BlockCipherInitialized
+// @ preserves acc(log.Mem(), _)
+// @ ensures  dc.Mem()
+// @ ensures  err == nil ==> payload.Mem()
+// @ ensures  err == nil && !encryptionRequested ==> dc.getState() == BlockCipherInitialized
+// @ ensures  err == nil && encryptionRequested ==> dc.getState() == AgentSecretCreatedAndSigned
+// @ ensures  err == nil && encryptionRequested ==> unfolding dc.Mem() in (
+// @	payload.ContainsSecureSessionAction(by.tuple4B(by.expB(by.generatorB(), by.gamma(dc.getAgentShareT())), by.gamma(dc.getAgentShareSignatureT()), by.msgB(dc.agentLTKeyARN), by.msgB(dc.logReaderId))))
+func (dc *dataChannel) buildHandshakeRequestPayload(log logger.T,
 	encryptionRequested bool,
-	request mgsContracts.SessionTypeRequest) mgsContracts.HandshakeRequestPayload {
+	request mgsContracts.SessionTypeRequest) (payload *mgsContracts.HandshakeRequestPayload, err error) {
 
-	handshakeRequest := mgsContracts.HandshakeRequestPayload{}
+	handshakeRequest := &mgsContracts.HandshakeRequestPayload{}
 	handshakeRequest.AgentVersion = version.Version
-	handshakeRequest.RequestedClientActions = []mgsContracts.RequestedClientAction{
-		{
-			ActionType:       mgsContracts.SessionType,
-			ActionParameters: request,
-		}}
+	sessionTypeAction := mgsContracts.RequestedClientAction{
+		ActionType:       mgsContracts.SessionType,
+		ActionParameters: request,
+	}
+
 	if encryptionRequested {
-		handshakeRequest.RequestedClientActions = append(handshakeRequest.RequestedClientActions,
-			mgsContracts.RequestedClientAction{
-				ActionType: mgsContracts.KMSEncryption,
-				ActionParameters: mgsContracts.KMSEncryptionRequest{
-					KMSKeyID: dataChannel.blockCipher.GetKMSKeyId(),
-				}})
+		// Generate the secret using secure randomness from rand
+		//@ cryptoRand.GetReaderMem()
+		//@ unfold dc.Mem()
+		//@ t0 := dc.getToken()
+		//@ rid := dc.getRid()
+		//@ s0 := dc.getAbsState()
+		//@ unfold iospec.P_Agent(t0, rid, s0)
+		//@ unfold iospec.phiRF_Agent_14(t0, rid, s0)
+		//@ agentSecretT := iospec.get_e_FrFact_r1(t0, rid)
+		agentSecret, compressedPublic, err /*@, t1 @*/ := generateAndEncodeEllipticKey( /*@ t0, rid @*/ )
+		if err != nil {
+			//@ fold iospec.phiRF_Agent_14(t0, rid, s0)
+			//@ fold iospec.P_Agent(t0, rid, s0)
+			//@ fold dc.Mem()
+			logErrorf(log, "failed to generate client secret: %v", err /*@, perm(1/2) @*/)
+			return nil, err
+		}
+		//@ s1 := s0 union mset[ft.Fact]{ ft.FrFact_Agent(rid, agentSecretT) }
+		//@ unfold dc.IoSpecMem()
+		//@ dc.setToken(t1)
+		//@ dc.setAbsState(s1)
+		//@ fold dc.IoSpecMem()
+
+		dc.state.agentSecret = agentSecret
+
+		clientId := dc.dataStream.GetClientId()
+		signPayloadBytes, err := getSignPayloadBytes(compressedPublic, clientId, dc.logReaderId)
+		if err != nil {
+			//@ fold dc.Mem()
+			err = fmtErrorf("failed to encode sign payload: %v", err /*@, perm(1/2) @*/)
+			logError(log, err /*@, perm(1/2) @*/)
+			return nil, err
+		}
+		//@ signPayloadT := tm.pair(tm.exp(tm.pubTerm(pub.const_g_pub()), agentSecretT), tm.pair(tm.pubTerm(pub.pub_msg(dc.logReaderId)), tm.pubTerm(pub.pub_msg(clientId))))
+
+		// unfold phiR_Agent_0 to obtain Out_KMS_Agent fact
+		/*@
+			agentIdT := dc.getAgentIdT()
+			kmsIdT := dc.getKMSIdT()
+			clientIdT := dc.getClientIdT()
+			readerIdT := dc.getReaderIdT()
+			agentLtKeyIdT := tm.pubTerm(pub.pub_msg(dc.agentLTKeyARN))
+			logPkT := dc.getLogLTPkT()
+			m := tm.pair(tm.pubTerm(pub.const_SignRequest_pub()), tm.pair(agentLtKeyIdT, signPayloadT))
+			l := mset[ft.Fact] {
+				ft.Setup_Agent(rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT),
+				ft.FrFact_Agent(rid, agentSecretT),
+			}
+			a := mset[cl.Claim] {
+				cl.AgentStarted(),
+			}
+			r := mset[ft.Fact] {
+		    	ft.St_Agent_1(rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT),
+		        ft.Out_KMS_Agent(rid, agentIdT, kmsIdT, rid, m),
+			}
+			@*/
+		//@ unfold iospec.P_Agent(t1, rid, s1)
+		//@ unfold iospec.phiR_Agent_0(t1, rid, s1)
+		//@ t2 := iospec.internBIO_e_Agent_SendSignRequest(t1, rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT, l, a, r)
+		//@ s2 := ft.U(l, r, s1)
+
+		// unfold phiRG_Agent_12 to obtain e_Out_KMS permission
+		//@ unfold iospec.P_Agent(t2, rid, s2)
+		//@ unfold iospec.phiRG_Agent_12(t2, rid, s2)
+		//@ t3 := iospec.get_e_Out_KMS_placeDst(t2, rid, agentIdT, kmsIdT, rid, m)
+		//@ s3 := s2 setminus mset[ft.Fact] { ft.Out_KMS_Agent(rid, agentIdT, kmsIdT, rid, m) }
+
+		// unfold phiRF_Agent_15 to obtain e_In_KMS permission since `signAndEncode` performs a send and receive operation
+		//@ unfold iospec.P_Agent(t3, rid, s3)
+		//@ unfold iospec.phiRF_Agent_15(t3, rid, s3)
+		//@ t4 := iospec.get_e_In_KMS_placeDst(t3, rid)
+
+		sig, err /*@, signatureT @*/ := signAndEncode(dc.state.kmsService, dc.agentLTKeyARN, signPayloadBytes /*@, perm(1/2), t2, rid, agentIdT, kmsIdT, signPayloadT, m @*/)
+		if err != nil {
+			// since we have already performed `internBIO_e_Agent_SendSignRequest` and potentially partially `signAndEncode`,
+			// there is no way we can get back into a regular state that would allow re-execution of this function by, e.g.,
+			// folding I/O predicates. This is in accordance to the Tamarin model, which also does not foresee a participant
+			// instance to retry certain steps
+			dc.dataChannelState = Erroneous
+			//@ fold dc.Mem()
+			err = fmtErrorf("failed to sign agent sign payload: %v", err /*@, perm(1/2) @*/)
+			logError(log, err /*@, perm(1/2) @*/)
+			return nil, err
+		}
+
+		//@ s4 := s3 union mset[ft.Fact] { ft.In_KMS_Agent(rid, kmsIdT, agentIdT, rid, tm.pair(tm.pubTerm(pub.const_SignResponse_pub()), signatureT)) }
+
+		// unfold phiR_Agent_1 to transition to St_Agent_2
+		/*@
+			l2 := mset[ft.Fact] {
+				ft.St_Agent_1(rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT),
+				ft.In_KMS_Agent(rid, kmsIdT, agentIdT, rid, tm.pair(tm.pubTerm(pub.const_SignResponse_pub()), signatureT)),
+			}
+			a2 := mset[cl.Claim] {
+				cl.AgentSignResponse(kmsIdT, agentIdT, rid, tm.pair(tm.pubTerm(pub.const_SignResponse_pub()), signatureT)),
+			}
+			r2 := mset[ft.Fact] {
+		    	ft.St_Agent_2(rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT, signatureT),
+			}
+			@*/
+		//@ unfold iospec.P_Agent(t4, rid, s4)
+		//@ unfold iospec.phiR_Agent_1(t4, rid, s4)
+		//@ t5 := iospec.internBIO_e_Agent_RecvSignResponse(t4, rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT, signatureT, l2, a2, r2)
+		//@ s5 := ft.U(l2, r2, s4)
+
+		//@ unfold dc.IoSpecMem()
+		//@ dc.setToken(t5)
+		//@ dc.setAbsState(s5)
+		//@ dc.setAgentShareT(agentSecretT)
+		//@ dc.setAgentShareSignatureT(signatureT)
+		//@ fold dc.IoSpecMem()
+		dc.dataChannelState = AgentSecretCreatedAndSigned
+
+		logDebugfString(log, "agent signed sign payload: %x", sig)
+
+		req := &mgsContracts.SecureSessionRequest{
+			Version:        1,
+			ShareAlgorithm: "P384",
+			AgentShare:     compressedPublic,
+			Signature:      sig,
+			AgentLTKeyARN:  dc.agentLTKeyARN,
+			LogReaderId:    dc.logReaderId,
+		}
+		//@ fold acc(req.Mem(), 1/2)
+		//@ fold dc.Mem()
+
+		logDebugfSecureSessionRequest(log, "client generated SecureSessionRequest: %+v", req /*@, perm(1/2) @*/)
+
+		secureSessionAction := mgsContracts.RequestedClientAction{
+			ActionType:       mgsContracts.SecureSession,
+			ActionParameters: *req,
+		}
+		handshakeRequest.RequestedClientActions = []mgsContracts.RequestedClientAction{sessionTypeAction, secureSessionAction}
+		//@ fold handshakeRequest.RequestedClientActions[0].Mem()
+		//@ fold handshakeRequest.RequestedClientActions[1].Mem()
+		//@ fold handshakeRequest.Mem()
+	} else {
+		handshakeRequest.RequestedClientActions = []mgsContracts.RequestedClientAction{sessionTypeAction}
+		//@ fold handshakeRequest.RequestedClientActions[0].Mem()
+		//@ fold handshakeRequest.Mem()
 	}
 
-	return handshakeRequest
+	return handshakeRequest, nil
+}
+
+// @ trusted
+// @ requires pl.token(t0) && iospec.e_FrFact(t0, rid)
+// @ ensures  err == nil ==> bytes.SliceMem(priv)
+// @ ensures  err == nil ==> pl.token(t1) && t1 == old(iospec.get_e_FrFact_placeDst(t0, rid))
+// @ ensures  err == nil ==> abs.Abs(priv) == by.gamma(old(iospec.get_e_FrFact_r1(t0, rid)))
+// @ ensures  err == nil ==> by.msgB(encodedPk) == by.expB(by.generatorB(), abs.Abs(priv))
+// @ ensures  err != nil ==> err.ErrorMem()
+// @ ensures  err != nil ==> t1 == t0 && pl.token(t0) && iospec.e_FrFact(t0, rid) &&
+// @ 	iospec.get_e_FrFact_placeDst(t0, rid) == old(iospec.get_e_FrFact_placeDst(t0, rid)) &&
+// @    iospec.get_e_FrFact_r1(t0, rid) == old(iospec.get_e_FrFact_r1(t0, rid))
+func generateAndEncodeEllipticKey( /*@ ghost t0 pl.Place, ghost rid tm.Term @*/ ) (priv []byte, encodedPk string, err error /*@, ghost t1 pl.Place @*/) {
+	//@ cryptoRand.GetReaderMem()
+	priv, x, y, err /*@, t1 @*/ := elliptic.GenerateKey(elliptic.P384(), cryptoRand.Reader /*@, t0, rid @*/)
+	if err != nil {
+		return nil, "", err /*@, t0 @*/
+	}
+
+	// Base64 encode the public part and put it in the message
+	agentShare := elliptic.MarshalCompressed(elliptic.P384(), x, y /*@, perm(1/2) @*/)
+	encodedPk = base64.StdEncoding.EncodeToString(agentShare /*@, perm(1/2) @*/)
+	return
+}
+
+// @ trusted
+// @ ensures err == nil ==> bytes.SliceMem(signPayloadBytes)
+// @ ensures err == nil ==> abs.Abs(signPayloadBytes) == by.tuple3B(by.msgB(compressedPublic), by.msgB(logReaderId), by.msgB(clientId))
+// @ ensures err != nil ==> err.ErrorMem()
+func getSignPayloadBytes(compressedPublic string, clientId string, logReaderId string) (signPayloadBytes []byte, err error) {
+	signPayload := &mgsContracts.SignAgentSharePayload{
+		AgentShare:  compressedPublic,
+		ClientId:    clientId,
+		LogReaderId: logReaderId,
+	}
+
+	//@ fold signPayload.Mem()
+	return json.Marshal(signPayload /*@, perm(1/2) @*/)
+}
+
+// @ trusted
+// @ requires noPerm < p
+// @ requires kmsService.Mem() && acc(bytes.SliceMem(message), p)
+// @ requires m == tm.pair(tm.pubTerm(pub.const_SignRequest_pub()), tm.pair(tm.pubTerm(pub.pub_msg(keyId)), messageT))
+// @ requires pl.token(t) && iospec.e_Out_KMS(t, rid, agentId, kmsId, rid, m) && by.gamma(messageT) == abs.Abs(message)
+// @ requires let t1 := iospec.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m) in (
+// @     iospec.e_In_KMS(t1, rid))
+// @ ensures  kmsService.Mem() && acc(bytes.SliceMem(message), p)
+// @ ensures  err == nil ==> by.gamma(signatureT) == by.msgB(signature)
+// @ ensures  err != nil ==> err.ErrorMem()
+// @ ensures  err == nil ==> let t1 := old(iospec.get_e_Out_KMS_placeDst(t, rid, agentId, kmsId, rid, m)) in (
+// @     pl.token(old(iospec.get_e_In_KMS_placeDst(t1, rid))) &&
+// @     kmsId == old(iospec.get_e_In_KMS_r1(t1, rid)) &&
+// @     agentId == old(iospec.get_e_In_KMS_r2(t1, rid)) &&
+// @     rid == old(iospec.get_e_In_KMS_r3(t1, rid)) &&
+// @     tm.pair(tm.pubTerm(pub.const_SignResponse_pub()), signatureT) == old(iospec.get_e_In_KMS_r4(t1, rid)))
+func signAndEncode(kmsService *crypto.KMSService, keyId string, message []byte /*@, ghost p perm, ghost t pl.Place, ghost rid tm.Term, ghost agentId tm.Term, ghost kmsId tm.Term, ghost messageT tm.Term, ghost m tm.Term @*/) (signature string, err error /*@, ghost signatureT tm.Term @*/) {
+	var sig []byte
+	sig, err /*@, signatureT @*/ = kmsService.Sign(keyId, message /*@, p, t, rid, agentId, kmsId, messageT, m @*/)
+	if err != nil {
+		return
+	}
+	signature = base64.StdEncoding.EncodeToString(sig /*@, perm(1/2)@*/)
+	return
 }
 
 // buildHandshakeCompletePayload builds payload for HandshakeComplete
-func (dataChannel *DataChannel) buildHandshakeCompletePayload(log log.T) mgsContracts.HandshakeCompletePayload {
-	handshakeComplete := mgsContracts.HandshakeCompletePayload{}
+// @ requires log != nil && dc.Mem() && dc.getState() != Erroneous
+// @ preserves acc(log.Mem(), _)
+// @ ensures dc.Mem() && dc.getState() == old(dc.getState())
+// @ ensures err == nil ==> payload.Mem()
+func (dc *dataChannel) buildHandshakeCompletePayload(log logger.T) (payload *mgsContracts.HandshakeCompletePayload, err error) {
+	handshakeComplete := &mgsContracts.HandshakeCompletePayload{}
+	//@ unfold dc.Mem()
 	handshakeComplete.HandshakeTimeToComplete =
-		dataChannel.handshake.handshakeEndTime.Sub(dataChannel.handshake.handshakeStartTime)
-
-	clientVersion := dataChannel.GetClientVersion()
-	if dataChannel.separateOutputPayload == true && versionutil.Compare(clientVersion, clientVersionWithoutOutputSeparation, true) <= 0 {
+		dc.hs.handshakeEndTime.Sub(dc.hs.handshakeStartTime)
+	//@ fold dc.Mem()
+	clientVersion, err := dc.GetClientVersion( /*@ perm(1/2) @*/ )
+	if err != nil {
+		return nil, err
+	}
+	//@ unfold dc.Mem()
+	if dc.separateOutputPayload == true && versionutil.Compare(clientVersion, clientVersionWithoutOutputSeparation, true) <= 0 {
 		handshakeComplete.CustomerMessage = "Please update session manager plugin version (minimum required version " +
 			firstVersionWithOutputSeparationFeature +
 			") for fully support of separate StdOut/StdErr output.\r\n"
 	}
 
-	if dataChannel.encryptionEnabled == true {
+	if dc.encryptionEnabled {
 		handshakeComplete.CustomerMessage += "This session is encrypted using AWS KMS."
 	}
+	//@ fold dc.Mem()
+	//@ fold handshakeComplete.Mem()
 
-	return handshakeComplete
+	return handshakeComplete, nil
 }
 
 // sendHandshakeRequest sends handshake request
-func (dataChannel *DataChannel) sendHandshakeRequest(log log.T, handshakeRequestPayload mgsContracts.HandshakeRequestPayload) (err error) {
+// @ requires log != nil && handshakeRequestPayload.Mem()
+// @ requires dc.Mem() && dc.getState() >= BlockCipherInitialized
+// @ requires unfolding dc.Mem() in dc.encryptionEnabled ==>
+// @	dc.dataChannelState == AgentSecretCreatedAndSigned &&
+// @	handshakeRequestPayload.ContainsSecureSessionAction(by.tuple4B(by.expB(by.generatorB(), by.gamma(dc.getAgentShareT())), by.gamma(dc.getAgentShareSignatureT()), by.msgB(dc.agentLTKeyARN), by.msgB(dc.logReaderId)))
+// @ preserves acc(log.Mem(), _)
+// @ ensures dc.Mem()
+// @ ensures err == nil ==> dc.getState() == HandshakeRequestSent
+func (dc *dataChannel) sendHandshakeRequest(log logger.T, handshakeRequestPayload *mgsContracts.HandshakeRequestPayload) (err error) {
+	//@ secActionB := unfolding dc.Mem() in by.tuple4B(by.expB(by.generatorB(), by.gamma(dc.getAgentShareT())), by.gamma(dc.getAgentShareSignatureT()), by.msgB(dc.agentLTKeyARN), by.msgB(dc.logReaderId))
 	var handshakeRequestPayloadBytes []byte
-	if handshakeRequestPayloadBytes, err = json.Marshal(handshakeRequestPayload); err != nil {
-		return fmt.Errorf("Could not serialize HandshakeRequest message %v, err: %s", handshakeRequestPayload, err)
-	}
-
-	log.Debug("Sending Handshake Request.")
-	log.Tracef("Sending HandshakeRequest message with content %v", handshakeRequestPayload)
-	if err = dataChannel.SendStreamDataMessage(log, mgsContracts.HandshakeRequest, handshakeRequestPayloadBytes); err != nil {
-		return fmt.Errorf("Failed sending of HandshakeRequest message, err: %s", err)
+	if handshakeRequestPayloadBytes, err = marshalHandshakeRequest(handshakeRequestPayload /*@, perm(1/2), secActionB @*/); err != nil {
+		return fmtErrorfHandshakeRequestErr("Could not serialize HandshakeRequest message %v, err: %s", handshakeRequestPayload, err /*@, perm(1/2) @*/)
+	}
+
+	logDebug(log, "Sending Handshake Request.")
+	logTracefHandshakeRequestPayload(log, "Sending HandshakeRequest message with content %v", handshakeRequestPayload /*@, perm(1/2) @*/)
+	//@ secActionT := unfolding dc.Mem() in tm.pair(tm.exp(tm.pubTerm(pub.const_g_pub()), dc.getAgentShareT()), tm.pair(dc.getAgentShareSignatureT(), tm.pair(tm.pubTerm(pub.pub_msg(dc.agentLTKeyARN)), tm.pubTerm(pub.pub_msg(dc.logReaderId)))))
+
+	//@ unfold dc.Mem()
+	//@ t0 := dc.getToken()
+	//@ rid := dc.getRid()
+	//@ s0 := dc.getAbsState()
+	/*@
+	agentIdT := dc.getAgentIdT()
+	kmsIdT := dc.getKMSIdT()
+	clientIdT := dc.getClientIdT()
+	readerIdT := dc.getReaderIdT()
+	agentLtKeyIdT := tm.pubTerm(pub.pub_msg(dc.agentLTKeyARN))
+	logPkT := dc.getLogLTPkT()
+	agentSecretT := dc.getAgentShareT()
+	signatureT := dc.getAgentShareSignatureT()
+	l := mset[ft.Fact] {
+		ft.St_Agent_2(rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT, signatureT),
+	}
+	a := mset[cl.Claim] {
+		cl.AgentSecureSessionRequest(agentIdT, clientIdT, tm.exp(tm.pubTerm(pub.const_g_pub()), agentSecretT), signatureT, agentLtKeyIdT),
+	}
+	r := mset[ft.Fact] {
+		ft.St_Agent_3(rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT, signatureT),
+	    ft.OutFact_Agent(rid, tm.pair(tm.pubTerm(pub.const_SecureSessionRequest_pub()), tm.pair(tm.exp(tm.pubTerm(pub.const_g_pub()), agentSecretT), tm.pair(signatureT, tm.pair(agentLtKeyIdT, readerIdT))))),
+	    ft.OutFact_Agent(rid, tm.pair(tm.pubTerm(pub.const_Log_pub()), tm.pair(tm.pubTerm(pub.const_SecureSessionRequest_pub()), tm.pair(tm.exp(tm.pubTerm(pub.const_g_pub()), agentSecretT), tm.pair(signatureT, tm.pair(agentLtKeyIdT, readerIdT)))))),
+	}
+	@*/
+	//@ unfold iospec.P_Agent(t0, rid, s0)
+	//@ unfold iospec.phiR_Agent_2(t0, rid, s0)
+	//@ t1 := iospec.internBIO_e_Agent_SendSecureSessionRequest(t0, rid, agentIdT, kmsIdT, clientIdT, readerIdT, agentLtKeyIdT, logPkT, agentSecretT, signatureT, l, a, r)
+	//@ s1 := ft.U(l, r, s0)
+	//@ unfold dc.IoSpecMem()
+	//@ dc.setToken(t1)
+	//@ dc.setAbsState(s1)
+	//@ fold dc.IoSpecMem()
+	dc.dataChannelState = HandshakeRequestSent
+	//@ fold dc.Mem()
+
+	if err = dc.sendData(log, mgsContracts.HandshakeRequest, handshakeRequestPayloadBytes /*@, perm(1/2), secActionT @*/); err != nil {
+		return fmtErrorf("Failed sending of HandshakeRequest message, err: %s", err /*@, perm(1/2) @*/)
 	}
 	return nil
 }
 
+// @ trusted
+// @ requires noPerm < p
+// @ requires acc(handshakeRequestPayload.Mem(), p)
+// @ requires handshakeRequestPayload.ContainsSecureSessionAction(secActionB)
+// @ ensures  acc(handshakeRequestPayload.Mem(), p)
+// @ ensures  handshakeRequestPayload.ContainsSecureSessionAction(secActionB)
+// @ ensures  err == nil ==> bytes.SliceMem(handshakeRequestPayloadBytes)
+// @ ensures  err == nil ==> abs.Abs(handshakeRequestPayloadBytes) == handshakeRequestPayload.Abs(secActionB)
+// @ ensures  err != nil ==> err.ErrorMem()
+func marshalHandshakeRequest(handshakeRequestPayload *mgsContracts.HandshakeRequestPayload /*@, ghost p perm, ghost secActionB by.Bytes @*/) (handshakeRequestPayloadBytes []byte, err error) {
+	return json.Marshal(handshakeRequestPayload /*@, p/2 @*/)
+}
+
 // sendHandshakeComplete sends handshake complete
-func (dataChannel *DataChannel) sendHandshakeComplete(log log.T, handshakeCompletePayload mgsContracts.HandshakeCompletePayload) (err error) {
+// @ requires log != nil && handshakeCompletePayload.Mem()
+// @ requires dc.Mem() && dc.getState() >= BlockCipherReady
+// @ preserves acc(log.Mem(), _)
+// @ ensures dc.Mem() && dc.getState() == old(dc.getState())
+// @ ensures err != nil ==> err.ErrorMem()
+func (dc *dataChannel) sendHandshakeComplete(log logger.T, handshakeCompletePayload *mgsContracts.HandshakeCompletePayload) (err error) {
 	var handshakeCompletePayloadBytes []byte
-	if handshakeCompletePayloadBytes, err = json.Marshal(handshakeCompletePayload); err != nil {
-		return fmt.Errorf("Could not serialize HandshakeComplete message %v, err: %s", handshakeCompletePayload, err)
+	if handshakeCompletePayloadBytes, err = json.Marshal(handshakeCompletePayload /*@, perm(1/2) @*/); err != nil {
+		return fmtErrorfHandshakeCompleteErr("Could not serialize HandshakeComplete message %v, err: %s", handshakeCompletePayload, err /*@, perm(1/1) @*/)
 	}
 
-	log.Debug("Sending HandshakeComplete.")
-	log.Tracef("Sending HandshakeComplete message with content %v", handshakeCompletePayload)
-	if err = dataChannel.SendStreamDataMessage(log, mgsContracts.HandshakeComplete, handshakeCompletePayloadBytes); err != nil {
+	logDebug(log, "Sending HandshakeComplete.")
+	logTracefHandshakeCompletePayload(log, "Sending HandshakeComplete message with content %v", handshakeCompletePayload /*@, perm(1/2) @*/)
+	//@ ghost var inputDataT tm.Term
+	if err = dc.sendData(log, mgsContracts.HandshakeComplete, handshakeCompletePayloadBytes /*@, perm(1/2), inputDataT @*/); err != nil {
 		return err
 	}
 	return nil
 }
 
-// sendEncryptionChallenge sends encryption challenge
-func (dataChannel *DataChannel) sendEncryptionChallenge(log log.T) (err error) {
-	// Build the request
-	encChallengeRequest := mgsContracts.EncryptionChallengeRequest{}
-	randBytes := make([]byte, 64)
-	cryptoRand.Read(randBytes)
-	dataChannel.handshake.encryptionChallenge = randBytes
-	randBytes, err = dataChannel.blockCipher.EncryptWithAESGCM(randBytes)
-	if err != nil {
-		return err
-	}
-	encChallengeRequest.Challenge = randBytes
-
-	// Send it
-	log.Debug("Sending EncryptionChallengeRequest.")
-	err = dataChannel.sendStreamDataMessageJson(log, mgsContracts.EncChallengeRequest, encChallengeRequest)
-	if err != nil {
-		return err
-	}
-	return
-}
-
-// sendStreamDataMessageJson is utility method that serializes a struct into json and sends with the given payload type
-func (dataChannel *DataChannel) sendStreamDataMessageJson(log log.T,
-	payloadType mgsContracts.PayloadType, serializableStruct interface{}) (err error) {
-	var messageBytes []byte
-	if messageBytes, err = json.Marshal(serializableStruct); err != nil {
-		return fmt.Errorf("Could not serialize message %v, err: %s", serializableStruct, err)
-	}
-	log.Tracef("Sending message with content %v", serializableStruct)
-	err = dataChannel.SendStreamDataMessage(log, payloadType, messageBytes)
-	return err
-}
-
 // GetClientVersion returns version of the client
-func (dataChannel *DataChannel) GetClientVersion() string {
-	return dataChannel.handshake.clientVersion
+// @ requires noPerm < p
+// @ preserves acc(dc.Mem(), p)
+func (dc *dataChannel) GetClientVersion( /*@ ghost p perm @*/ ) (version string, err error) {
+	if dc.getState() == Erroneous {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
+	}
+	return /*@ unfolding acc(dc.Mem(), p) in @*/ dc.hs.clientVersion, nil
 }
 
 // GetInstanceId returns id of the target
-func (dataChannel *DataChannel) GetInstanceId() string {
-	return dataChannel.InstanceId
+// @ requires noPerm < p
+// @ preserves acc(dc.Mem(), p)
+func (dc *dataChannel) GetInstanceId( /*@ ghost p perm @*/ ) (instanceId string, err error) {
+	if dc.getState() < Initialized {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
+	}
+	return /*@ unfolding acc(dc.Mem(), p) in @*/ dc.dataStream.GetInstanceId(), nil
 }
 
 // GetRegion returns aws region of the target
-func (dataChannel *DataChannel) GetRegion() string {
-	return dataChannel.Service.GetRegion()
+// @ requires noPerm < p
+// @ preserves acc(dc.Mem(), p)
+func (dc *dataChannel) GetRegion( /*@ ghost p perm @*/ ) (region string, err error) {
+	if dc.getState() < Initialized {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
+	}
+	return /*@ unfolding acc(dc.Mem(), p) in @*/ dc.dataStream.GetRegion(), nil
 }
 
 // IsActive returns a boolean value indicating the datachannel is actively listening
 // and communicating with service
-func (dataChannel *DataChannel) IsActive() bool {
-	return !dataChannel.Pause
+// @ requires noPerm < p
+// @ preserves acc(dc.Mem(), p)
+func (dc *dataChannel) IsActive( /*@ ghost p perm @*/ ) (isActive bool, err error) {
+	if dc.getState() < Initialized {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
+	}
+	return /*@ unfolding acc(dc.Mem(), p) in @*/ dc.dataStream.IsActive(), nil
 }
 
 // GetSeparateOutputPayload returns boolean value indicating separate
 // stdout/stderr output for non-interactive session or not
-func (dataChannel *DataChannel) GetSeparateOutputPayload() bool {
-	return dataChannel.separateOutputPayload
+// @ requires noPerm < p
+// @ preserves acc(dc.Mem(), p)
+func (dc *dataChannel) GetSeparateOutputPayload( /*@ ghost p perm @*/ ) (res bool, err error) {
+	if dc.getState() == Erroneous {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
+	}
+	return /*@ unfolding acc(dc.Mem(), _) in @*/ dc.separateOutputPayload, nil
 }
 
 // SetSeparateOutputPayload set separateOutputPayload value
-func (dataChannel *DataChannel) SetSeparateOutputPayload(separateOutputPayload bool) {
-	dataChannel.separateOutputPayload = separateOutputPayload
+// @ preserves dc.Mem()
+// @ ensures dc.getState() == old(dc.getState())
+func (dc *dataChannel) SetSeparateOutputPayload(separateOutputPayload bool) (err error) {
+	if dc.getState() == Erroneous {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
+	}
+	//@ unfold dc.Mem()
+	dc.separateOutputPayload = separateOutputPayload
+	//@ fold dc.Mem()
+	return
 }
 
-// getDataChannelToken calls CreateDataChannel to get the token for this session.
-func getDataChannelToken(log log.T,
-	mgsService service.Service,
-	sessionId string,
-	requestId string,
-	clientId string) (tokenValue string, err error) {
-
-	createDataChannelInput := &service.CreateDataChannelInput{
-		MessageSchemaVersion: aws.String(mgsConfig.MessageSchemaVersion),
-		RequestId:            aws.String(requestId),
-		ClientId:             aws.String(clientId),
+// @ requires log != nil
+// @ preserves dc.Mem() && acc(log.Mem(), _)
+// @ ensures dc.getState() == old(dc.getState())
+func (dc *dataChannel) PrepareToCloseChannel(log logger.T) (err error) {
+	if dc.getState() < Initialized {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
 	}
+	//@ unfold dc.Mem()
+	dc.dataStream.PrepareToCloseChannel(log)
+	//@ fold dc.Mem()
+	return
+}
 
-	createDataChannelOutput, err := mgsService.CreateDataChannel(log, createDataChannelInput, sessionId)
-	if err != nil || createDataChannelOutput == nil {
-		return "", fmt.Errorf("CreateDataChannel failed with no output or error: %s", err)
+// @ requires log != nil
+// @ preserves dc.Mem() && acc(log.Mem(), _)
+// @ ensures dc.getState() == old(dc.getState())
+func (dc *dataChannel) Close(log logger.T) (err error) {
+	if dc.getState() < Initialized {
+		err = fmtErrorfState("DataChannel is in an invalid state %d", dc.getState())
+		return
 	}
+	//@ unfold dc.Mem()
+	err = dc.dataStream.Close(log)
+	//@ fold dc.Mem()
+	return
+}
 
-	log.Debugf("Successfully get datachannel token")
-	return *createDataChannelOutput.TokenValue, nil
+// @ trusted
+// @ requires acc(log.Mem(), _) && noPerm < p
+// @ preserves acc(param.Mem(), p)
+func logTracefHandshakeRequestPayload(log logger.T, formatStr string, param *mgsContracts.HandshakeRequestPayload /*@, ghost p perm @*/) {
+	log.Tracef(formatStr, param)
 }
 
-// getMgsEndpoint builds mgs endpoint.
-func getMgsEndpoint(context context.T, region string) (string, error) {
-	hostName := mgsConfig.GetMgsEndpoint(context, region)
-	if hostName == "" {
-		return "", fmt.Errorf("no MGS endpoint found in region %s", region)
-	}
-	var endpointBuilder bytes.Buffer
-	endpointBuilder.WriteString(mgsConfig.HttpsPrefix)
-	endpointBuilder.WriteString(hostName)
-	return endpointBuilder.String(), nil
+// @ trusted
+// @ requires acc(log.Mem(), _) && noPerm < p
+// @ preserves acc(param.Mem(), p)
+func logTracefHandshakeCompletePayload(log logger.T, formatStr string, param *mgsContracts.HandshakeCompletePayload /*@, ghost p perm @*/) {
+	log.Tracef(formatStr, param)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _)
+func logDebug(log logger.T, str string) {
+	log.Debug(str)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _)
+func logDebugfPayloadType(log logger.T, formatStr string, param mgsContracts.PayloadType) {
+	log.Debugf(formatStr, param)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _)
+func logDebugfString(log logger.T, formatStr string, param string) {
+	log.Debugf(formatStr, param)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _) && noPerm < p
+// @ preserves acc(param.Mem(), p)
+func logDebugfSecureSessionRequest(log logger.T, formatStr string, param *mgsContracts.SecureSessionRequest /*@, ghost p perm @*/) {
+	log.Debugf(formatStr, param)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _)
+func logInfo(log logger.T, str string) {
+	log.Info(str)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _)
+func logInfofString(log logger.T, formatStr string, param string) {
+	log.Infof(formatStr, param)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _)
+func logWarnfActionType(log logger.T, formatStr string, param mgsContracts.ActionType) {
+	log.Warnf(formatStr, param)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _) && noPerm < p
+// @ preserves acc(param.ErrorMem(), p)
+func logError(log logger.T, param error /*@, ghost p perm @*/) {
+	log.Error(param)
+}
+
+// @ trusted
+// @ requires acc(log.Mem(), _) && noPerm < p
+// @ preserves acc(param.ErrorMem(), p)
+func logErrorf(log logger.T, formatStr string, param error /*@, ghost p perm @*/) {
+	log.Errorf(formatStr, param)
+}
+
+// @ trusted
+// @ requires noPerm < p && acc(param.ErrorMem(), p)
+// @ ensures err != nil && acc(err.ErrorMem(), p)
+func fmtErrorf(format string, param error /*@, ghost p perm @*/) (err error) {
+	return fmt.Errorf(format, param)
+}
+
+// @ trusted
+// @ ensures err != nil && err.ErrorMem()
+func fmtError(str string) (err error) {
+	return fmt.Errorf(str)
+}
+
+// @ trusted
+// @ ensures err != nil && err.ErrorMem()
+func fmtErrorfState(format string, param DataChannelState) (err error) {
+	return fmt.Errorf(format, param)
+}
+
+// @ trusted
+// @ ensures err != nil && err.ErrorMem()
+func fmtErrorfPayloadType(format string, param mgsContracts.PayloadType) (err error) {
+	return fmt.Errorf(format, param)
+}
+
+// @ trusted
+// @ requires noPerm < p && acc(param2.ErrorMem(), p)
+// @ ensures err != nil && acc(err.ErrorMem(), p)
+func fmtErrorfInt64Err(format string, param1 int64, param2 error /*@, ghost p perm @*/) (err error) {
+	return fmt.Errorf(format, param1, param2)
+}
+
+// @ trusted
+// @ ensures err != nil && err.ErrorMem()
+func fmtErrorfActionTypeActionStatusActionError(format string, param1 mgsContracts.ActionType, param2 mgsContracts.ActionStatus, param3 string) (err error) {
+	return fmt.Errorf(format, param1, param2, param3)
+}
+
+// @ trusted
+// @ requires noPerm < p && acc(bytes.SliceMem(param1), p) && acc(bytes.SliceMem(param2), p)
+// @ ensures err != nil && acc(err.ErrorMem(), p)
+func fmtErrorfBytes2(format string, param1 []byte, param2 []byte /*@, ghost p perm @*/) (err error) {
+	return fmt.Errorf(format, param1, param2)
+}
+
+// @ trusted
+// @ requires noPerm < p && acc(param.Mem(), p)
+// @ ensures err != nil && acc(err.ErrorMem(), p)
+func fmtErrorfMetadata(format string, param *kms.KeyMetadata /*@, ghost p perm @*/) (err error) {
+	return fmt.Errorf(format, param)
+}
+
+// @ trusted
+// @ requires noPerm < p && acc(param1.Mem(), p) && acc(param2.ErrorMem(), p)
+// @ ensures err != nil && acc(err.ErrorMem(), p)
+func fmtErrorfHandshakeRequestErr(format string, param1 *mgsContracts.HandshakeRequestPayload, param2 error /*@, ghost p perm @*/) (err error) {
+	return fmt.Errorf(format, param1, param2)
 }
 
-// getNonRetryableDataChannelErrors returns list of non retryable errors for data channel retry strategy
-func getNonRetryableDataChannelErrors() []string {
-	return []string{mgsConfig.SessionAlreadyTerminatedError}
+// @ trusted
+// @ requires noPerm < p && acc(param1.Mem(), p) && acc(param2.ErrorMem(), p)
+// @ ensures err != nil && acc(err.ErrorMem(), p)
+func fmtErrorfHandshakeCompleteErr(format string, param1 *mgsContracts.HandshakeCompletePayload, param2 error /*@, ghost p perm @*/) (err error) {
+	return fmt.Errorf(format, param1, param2)
 }
diff --git a/agent/session/datastream/datastream.go b/agent/session/datastream/datastream.go
new file mode 100644
index 000000000..d765b0261
--- /dev/null
+++ b/agent/session/datastream/datastream.go
@@ -0,0 +1,770 @@
+package datastream
+
+import (
+	"bytes"
+	"container/list"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"math"
+	"math/rand"
+	"runtime/debug"
+	"sync"
+	"time"
+
+	"github.com/aws/amazon-ssm-agent/agent/context"
+	"github.com/aws/amazon-ssm-agent/agent/log"
+	"github.com/aws/amazon-ssm-agent/agent/session/communicator"
+	mgsConfig "github.com/aws/amazon-ssm-agent/agent/session/config"
+	mgsContracts "github.com/aws/amazon-ssm-agent/agent/session/contracts"
+	"github.com/aws/amazon-ssm-agent/agent/session/crypto"
+	"github.com/aws/amazon-ssm-agent/agent/session/retry"
+	"github.com/aws/amazon-ssm-agent/agent/session/service"
+	"github.com/aws/amazon-ssm-agent/agent/task"
+	"github.com/aws/aws-sdk-go/aws"
+	"github.com/gorilla/websocket"
+	"github.com/twinj/uuid"
+)
+
+const (
+	schemaVersion  = 1
+	sequenceNumber = 0
+	messageFlags   = 3
+	// Timeout period before a handshake operation expires on the agent.
+	handshakeTimeout                        = 1500 * time.Second
+	clientVersionWithoutOutputSeparation    = "1.2.295"
+	firstVersionWithOutputSeparationFeature = "1.2.312.0"
+)
+
+type DataStream struct {
+	wsChannel  communicator.IWebSocketChannel
+	context    context.T
+	Service    service.Service
+	ChannelId  string
+	ClientId   string
+	InstanceId string
+	Role       string
+	Pause      bool
+	//records sequence number of last acknowledged message received over data channel
+	ExpectedSequenceNumber int64
+	//records sequence number of last stream data message sent over data channel
+	StreamDataSequenceNumber int64
+	//ensure only one goroutine sending message with current StreamDataSequenceNumber in data channel
+	//check carefully for deadlock when not reusing of SendStreamDataMessage
+	StreamDataSequenceNumberMutex *sync.Mutex
+	//buffer to store outgoing stream messages until acknowledged
+	//using linked list for this buffer as access to oldest message is required and it support faster deletion from any position of list
+	OutgoingMessageBuffer ListMessageBuffer
+	//buffer to store incoming stream messages if received out of sequence
+	//using map for this buffer as incoming messages can be out of order and retrieval would be faster by sequenceId
+	IncomingMessageBuffer MapMessageBuffer
+	//round trip time of latest acknowledged message
+	RoundTripTime float64
+	//round trip time variation of latest acknowledged message
+	RoundTripTimeVariation float64
+	//timeout used for resending unacknowledged message
+	RetransmissionTimeout time.Duration
+	//cancelFlag is used for passing cancel signal to plugin in when channel_closed message is received over data channel
+	cancelFlag task.CancelFlag
+	//streamDataHandler handles (possibly encrypted) messages received from the stream
+	streamDataHandler func(log log.T, msg *mgsContracts.AgentMessage) error
+}
+
+type ListMessageBuffer struct {
+	Messages *list.List
+	Capacity int
+	Mutex    *sync.Mutex
+}
+
+type MapMessageBuffer struct {
+	Messages map[int64]StreamingMessage
+	Capacity int
+	Mutex    *sync.Mutex
+}
+
+type StreamingMessage struct {
+	Content        []byte
+	SequenceNumber int64
+	LastSentTime   time.Time
+}
+
+func NewDataStream(context context.T,
+	channelId string,
+	clientId string,
+	streamDataHandler func(log log.T, msg *mgsContracts.AgentMessage) error,
+	cancelFlag task.CancelFlag) (*DataStream, error) {
+
+	log := context.Log()
+	identity := context.Identity()
+	appConfig := context.AppConfig()
+
+	messageGatewayServiceConfig := appConfig.Mgs
+	if messageGatewayServiceConfig.Region == "" {
+		fetchedRegion, err := identity.Region()
+		if err != nil {
+			return nil, fmt.Errorf("failed to get region with error: %s", err)
+		}
+		messageGatewayServiceConfig.Region = fetchedRegion
+	}
+
+	if messageGatewayServiceConfig.Endpoint == "" {
+		fetchedEndpoint, err := getMgsEndpoint(context, messageGatewayServiceConfig.Region)
+		if err != nil {
+			return nil, fmt.Errorf("failed to get MessageGatewayService endpoint with error: %s", err)
+		}
+		messageGatewayServiceConfig.Endpoint = fetchedEndpoint
+	}
+
+	connectionTimeout := time.Duration(messageGatewayServiceConfig.StopTimeoutMillis) * time.Millisecond
+	mgsService := service.NewService(context, messageGatewayServiceConfig, connectionTimeout)
+
+	instanceID, err := identity.InstanceID()
+
+	if instanceID == "" {
+		return nil, fmt.Errorf("no instanceID provided, %s", err)
+	}
+
+	dataStream := &DataStream{}
+	dataStream.Initialize(
+		context,
+		mgsService,
+		channelId,
+		clientId,
+		instanceID,
+		mgsConfig.RolePublishSubscribe,
+		streamDataHandler,
+		cancelFlag)
+
+	streamMessageHandler := func(input []byte) {
+		if err := dataStream.dataChannelIncomingMessageHandler(log, input); err != nil {
+			log.Errorf("Invalid message %s\n", err)
+		}
+	}
+	if err := dataStream.SetWebSocket(context, mgsService, channelId, clientId, streamMessageHandler); err != nil {
+		return nil, fmt.Errorf("failed to create websocket for datachannel with error: %s", err)
+	}
+	if err := dataStream.Open(log); err != nil {
+		return nil, fmt.Errorf("failed to open datachannel with error: %s", err)
+	}
+	dataStream.ResendStreamDataMessageScheduler(log)
+
+	return dataStream, nil
+}
+
+// Initialize populates datastream object.
+func (dataStream *DataStream) Initialize(context context.T,
+	mgsService service.Service,
+	sessionId string,
+	clientId string,
+	instanceId string,
+	role string,
+	streamDataHandler func(log log.T, msg *mgsContracts.AgentMessage) error,
+	cancelFlag task.CancelFlag) {
+
+	dataStream.context = context
+	dataStream.Service = mgsService
+	dataStream.ChannelId = sessionId
+	dataStream.ClientId = clientId
+	dataStream.InstanceId = instanceId
+	dataStream.Role = role
+	dataStream.Pause = false
+	dataStream.ExpectedSequenceNumber = 0
+	dataStream.StreamDataSequenceNumber = 0
+	dataStream.StreamDataSequenceNumberMutex = &sync.Mutex{}
+	dataStream.OutgoingMessageBuffer = ListMessageBuffer{
+		list.New(),
+		mgsConfig.OutgoingMessageBufferCapacity,
+		&sync.Mutex{},
+	}
+	dataStream.IncomingMessageBuffer = MapMessageBuffer{
+		make(map[int64]StreamingMessage),
+		mgsConfig.IncomingMessageBufferCapacity,
+		&sync.Mutex{},
+	}
+	dataStream.RoundTripTime = float64(mgsConfig.DefaultRoundTripTime)
+	dataStream.RoundTripTimeVariation = mgsConfig.DefaultRoundTripTimeVariation
+	dataStream.RetransmissionTimeout = mgsConfig.DefaultTransmissionTimeout
+	dataStream.wsChannel = &communicator.WebSocketChannel{}
+	dataStream.streamDataHandler = streamDataHandler
+	dataStream.cancelFlag = cancelFlag
+}
+
+func (dataStream *DataStream) GetKMSService() (*crypto.KMSService, error) {
+	return crypto.NewKMSService(dataStream.context)
+}
+
+// SetWebSocket populates webchannel object.
+func (dataStream *DataStream) SetWebSocket(context context.T,
+	mgsService service.Service,
+	sessionId string,
+	clientId string,
+	onMessageHandler func(input []byte)) error {
+
+	log := context.Log()
+	uuid.SwitchFormat(uuid.CleanHyphen)
+	requestId := uuid.NewV4().String()
+
+	log.Infof("Setting up datachannel for session: %s, requestId: %s, clientId: %s", sessionId, requestId, clientId)
+	tokenValue, err := getDataChannelToken(log, mgsService, sessionId, requestId, clientId)
+	if err != nil {
+		log.Errorf("Failed to get datachannel token, error: %s", err)
+		return err
+	}
+
+	onErrorHandler := func(err error) {
+		uuid.SwitchFormat(uuid.CleanHyphen)
+		requestId := uuid.NewV4().String()
+		callable := func() (channel interface{}, err error) {
+			tokenValue, err := getDataChannelToken(log, mgsService, sessionId, requestId, clientId)
+			if err != nil {
+				return dataStream, err
+			}
+			dataStream.wsChannel.SetChannelToken(tokenValue)
+			if err = dataStream.Reconnect(log); err != nil {
+				return dataStream, err
+			}
+			return dataStream, nil
+		}
+		retryer := retry.ExponentialRetryer{
+			CallableFunc:        callable,
+			GeometricRatio:      mgsConfig.RetryGeometricRatio,
+			InitialDelayInMilli: rand.Intn(mgsConfig.DataChannelRetryInitialDelayMillis) + mgsConfig.DataChannelRetryInitialDelayMillis,
+			MaxDelayInMilli:     mgsConfig.DataChannelRetryMaxIntervalMillis,
+			MaxAttempts:         mgsConfig.DataChannelNumMaxAttempts,
+			NonRetryableErrors:  getNonRetryableDataChannelErrors(),
+		}
+		if _, err := retryer.Call(); err != nil {
+			log.Error(err)
+		}
+	}
+
+	if err := dataStream.wsChannel.Initialize(context,
+		sessionId,
+		mgsConfig.DataChannel,
+		mgsConfig.RolePublishSubscribe,
+		tokenValue,
+		mgsService.GetRegion(),
+		mgsService.GetV4Signer(),
+		onMessageHandler,
+		onErrorHandler); err != nil {
+		log.Errorf("failed to initialize websocket channel for datachannel, error: %s", err)
+		return err
+	}
+	return nil
+}
+
+func (dataStream *DataStream) GetStreamDataSequenceNumber() int64 {
+	dataStream.StreamDataSequenceNumberMutex.Lock()
+	defer dataStream.StreamDataSequenceNumberMutex.Unlock()
+
+	return dataStream.StreamDataSequenceNumber
+}
+
+func (dataStream *DataStream) GetChannelId() string {
+	return dataStream.ChannelId
+}
+
+func (dataStream *DataStream) GetClientId() string {
+	return dataStream.ClientId
+}
+
+func (dataStream *DataStream) GetInstanceId() string {
+	return dataStream.InstanceId
+}
+
+func (dataStream *DataStream) GetRegion() string {
+	return dataStream.Service.GetRegion()
+}
+
+// IsActive returns a boolean value indicating the datachannel is actively listening
+// and communicating with service
+func (dataStream *DataStream) IsActive() bool {
+	return !dataStream.Pause
+}
+
+// CancelSession cancels session because handshake failed
+func (dataStream *DataStream) CancelSession() {
+	dataStream.cancelFlag.Set(task.Canceled)
+}
+
+// Open opens the websocket connection and sends the token for service to acknowledge the connection.
+func (dataStream *DataStream) Open(log log.T) error {
+	// Opens websocket connection
+	if err := dataStream.wsChannel.Open(log, nil); err != nil {
+		return fmt.Errorf("failed to connect data channel with error: %s", err)
+	}
+
+	// finalize handshake
+	uuid.SwitchFormat(uuid.CleanHyphen)
+	uid := uuid.NewV4().String()
+
+	openDataChannelInput := service.OpenDataChannelInput{
+		MessageSchemaVersion: aws.String(mgsConfig.MessageSchemaVersion),
+		RequestId:            aws.String(uid),
+		TokenValue:           aws.String(dataStream.wsChannel.GetChannelToken()),
+		ClientInstanceId:     aws.String(dataStream.InstanceId),
+		ClientId:             aws.String(dataStream.ClientId),
+	}
+	jsonValue, err := json.Marshal(openDataChannelInput)
+	if err != nil {
+		return fmt.Errorf("error serializing openDataChannelInput: %s", err)
+	}
+
+	return dataStream.SendMessage(log, jsonValue, websocket.TextMessage)
+}
+
+// SendMessage sends a message to the service through datachannel.
+func (dataStream *DataStream) SendMessage(log log.T, input []byte, inputType int) error {
+	return dataStream.wsChannel.SendMessage(log, input, inputType)
+}
+
+// Reconnect reconnects datachannel to service endpoint.
+func (dataStream *DataStream) Reconnect(log log.T) error {
+	log.Debugf("Reconnecting datachannel: %s", dataStream.ChannelId)
+
+	if err := dataStream.wsChannel.Close(log); err != nil {
+		log.Debugf("Closing datachannel failed with error: %s", err)
+	}
+
+	if err := dataStream.Open(log); err != nil {
+		return fmt.Errorf("failed to reconnect datachannel with error: %s", err)
+	}
+
+	dataStream.Pause = false
+	log.Debugf("Successfully reconnected to datachannel %s", dataStream.ChannelId)
+	return nil
+}
+
+// Close closes datachannel - its web socket connection.
+func (dataStream *DataStream) Close(log log.T) error {
+	log.Infof("Closing datachannel with channel Id %s", dataStream.ChannelId)
+	return dataStream.wsChannel.Close(log)
+}
+
+// PrepareToCloseChannel waits for all messages to be sent to MGS
+func (dataStream *DataStream) PrepareToCloseChannel(log log.T) {
+	done := make(chan bool)
+	go func() {
+		for dataStream.OutgoingMessageBuffer.Messages.Len() > 0 {
+			time.Sleep(10 * time.Millisecond)
+		}
+		done <- true
+	}()
+
+	select {
+	case <-done:
+		log.Tracef("Datachannel buffer is empty, datachannel can now be closed")
+	case <-time.After(2 * time.Second):
+		log.Debugf("Timeout waiting for datachannel buffer to empty.")
+	}
+}
+
+func (dataStream *DataStream) Send(log log.T, payloadType mgsContracts.PayloadType, inputData []byte) error {
+	// StreamDataSequenceNumber only changed in the code block below
+	dataStream.StreamDataSequenceNumberMutex.Lock()
+	defer dataStream.StreamDataSequenceNumberMutex.Unlock()
+
+	var flag uint64 = 0
+	if dataStream.StreamDataSequenceNumber == 0 {
+		flag = 1
+	}
+
+	uuid.SwitchFormat(uuid.CleanHyphen)
+	messageId := uuid.NewV4()
+	agentMessage := &mgsContracts.AgentMessage{
+		MessageType:    mgsContracts.OutputStreamDataMessage,
+		SchemaVersion:  1,
+		CreatedDate:    uint64(time.Now().UnixNano() / 1000000),
+		SequenceNumber: dataStream.StreamDataSequenceNumber,
+		Flags:          flag,
+		MessageId:      messageId,
+		PayloadType:    uint32(payloadType), // TODO: treat this message symbolically as being a 2-tuple of payloadType and inputData
+		Payload:        inputData,
+	}
+	msg, err := agentMessage.Serialize(log)
+	if err != nil {
+		return fmt.Errorf("cannot serialize StreamData message %v", agentMessage)
+	}
+
+	if dataStream.Pause {
+		log.Tracef("Sending stream data message has been paused, saving stream data message sequence %d to local map: ", dataStream.StreamDataSequenceNumber)
+	} else {
+		log.Tracef("Send stream data message sequence number %d", dataStream.StreamDataSequenceNumber)
+		if err = dataStream.SendMessage(log, msg, websocket.BinaryMessage); err != nil {
+			log.Errorf("Error sending stream data message %v", err)
+		}
+	}
+
+	streamingMessage := StreamingMessage{
+		msg,
+		dataStream.StreamDataSequenceNumber,
+		time.Now(),
+	}
+
+	log.Tracef("Add stream data to OutgoingMessageBuffer. Sequence Number: %d", streamingMessage.SequenceNumber)
+	dataStream.AddDataToOutgoingMessageBuffer(streamingMessage)
+	dataStream.StreamDataSequenceNumber = dataStream.StreamDataSequenceNumber + 1
+	return nil
+}
+
+// ResendStreamDataMessageScheduler spawns a separate go thread which keeps checking OutgoingMessageBuffer at fixed interval
+// and resends first message if time elapsed since lastSentTime of the message is more than acknowledge wait time
+func (dataStream *DataStream) ResendStreamDataMessageScheduler(log log.T) error {
+	go func() {
+		defer func() {
+			if r := recover(); r != nil {
+				log.Errorf("Resend stream data message scheduler panic: %v", r)
+				log.Errorf("Stacktrace:\n%s", debug.Stack())
+			}
+		}()
+		for {
+			time.Sleep(mgsConfig.ResendSleepInterval)
+			if dataStream.Pause {
+				log.Tracef("Resend stream data message has been paused")
+				continue
+			}
+			streamMessageElement := dataStream.OutgoingMessageBuffer.Messages.Front()
+			if streamMessageElement == nil {
+				continue
+			}
+
+			streamMessage := streamMessageElement.Value.(StreamingMessage)
+			if time.Since(streamMessage.LastSentTime) > dataStream.RetransmissionTimeout {
+				log.Tracef("Resend stream data message: %d", streamMessage.SequenceNumber)
+				if err := dataStream.SendMessage(log, streamMessage.Content, websocket.BinaryMessage); err != nil {
+					log.Errorf("Unable to send stream data message: %s", err)
+				}
+				streamMessage.LastSentTime = time.Now()
+				streamMessageElement.Value = streamMessage
+			}
+		}
+	}()
+	return nil
+}
+
+// ProcessAcknowledgedMessage processes acknowledge messages by deleting them from OutgoingMessageBuffer.
+func (dataStream *DataStream) ProcessAcknowledgedMessage(log log.T, acknowledgeMessageContent mgsContracts.AcknowledgeContent) {
+	acknowledgeSequenceNumber := acknowledgeMessageContent.SequenceNumber
+	for streamMessageElement := dataStream.OutgoingMessageBuffer.Messages.Front(); streamMessageElement != nil; streamMessageElement = streamMessageElement.Next() {
+		streamMessage := streamMessageElement.Value.(StreamingMessage)
+		if streamMessage.SequenceNumber == acknowledgeSequenceNumber {
+
+			//Calculate retransmission timeout based on latest round trip time of message
+			dataStream.calculateRetransmissionTimeout(log, streamMessage)
+
+			log.Tracef("Delete stream data from OutgoingMessageBuffer. Sequence Number: %d", streamMessage.SequenceNumber)
+			dataStream.RemoveDataFromOutgoingMessageBuffer(streamMessageElement)
+			break
+		}
+	}
+}
+
+// SendAcknowledgeMessage sends acknowledge message for stream data over data channel
+func (dataStream *DataStream) SendAcknowledgeMessage(log log.T, streamDataMessage *mgsContracts.AgentMessage) error {
+	dataStreamAcknowledgeContent := &mgsContracts.AcknowledgeContent{
+		MessageType:         streamDataMessage.MessageType,
+		MessageId:           streamDataMessage.MessageId.String(),
+		SequenceNumber:      streamDataMessage.SequenceNumber,
+		IsSequentialMessage: true,
+	}
+
+	acknowledgeContentBytes, err := dataStreamAcknowledgeContent.Serialize(log)
+	if err != nil {
+		// should not happen
+		log.Errorf("Cannot serialize Acknowledge message err: %v", err)
+		return err
+	}
+
+	log.Tracef("Send %s message for stream data: %d", mgsContracts.AcknowledgeMessage, streamDataMessage.SequenceNumber)
+	if err := dataStream.SendAgentMessage(log, mgsContracts.AcknowledgeMessage, acknowledgeContentBytes); err != nil {
+		return err
+	}
+	return nil
+}
+
+// sendAgentMessage sends agent message for given messageType and content
+func (dataStream *DataStream) SendAgentMessage(log log.T, messageType string, messageContent []byte) error {
+	uuid.SwitchFormat(uuid.CleanHyphen)
+	messageId := uuid.NewV4()
+	agentMessage := &mgsContracts.AgentMessage{
+		MessageType:    messageType,
+		SchemaVersion:  schemaVersion,
+		CreatedDate:    uint64(time.Now().UnixNano() / 1000000),
+		SequenceNumber: sequenceNumber,
+		Flags:          messageFlags,
+		MessageId:      messageId,
+		Payload:        messageContent,
+	}
+
+	msg, err := agentMessage.Serialize(log)
+	if err != nil {
+		log.Errorf("Cannot serialize agent message err: %v", err)
+		return err
+	}
+
+	err = dataStream.SendMessage(log, msg, websocket.BinaryMessage)
+	if err != nil {
+		log.Errorf("Error sending %s message %v", messageType, err)
+		return err
+	}
+	return nil
+}
+
+// AddDataToOutgoingMessageBuffer adds given message at the end of OutputMessageBuffer if it has capacity.
+func (dataStream *DataStream) AddDataToOutgoingMessageBuffer(streamMessage StreamingMessage) {
+	if dataStream.OutgoingMessageBuffer.Messages.Len() == dataStream.OutgoingMessageBuffer.Capacity {
+		return
+	}
+	dataStream.OutgoingMessageBuffer.Mutex.Lock()
+	dataStream.OutgoingMessageBuffer.Messages.PushBack(streamMessage)
+	dataStream.OutgoingMessageBuffer.Mutex.Unlock()
+}
+
+// RemoveDataFromOutgoingMessageBuffer removes given element from OutgoingMessageBuffer.
+func (dataStream *DataStream) RemoveDataFromOutgoingMessageBuffer(streamMessageElement *list.Element) {
+	dataStream.OutgoingMessageBuffer.Mutex.Lock()
+	dataStream.OutgoingMessageBuffer.Messages.Remove(streamMessageElement)
+	dataStream.OutgoingMessageBuffer.Mutex.Unlock()
+}
+
+// AddDataToIncomingMessageBuffer adds given message to IncomingMessageBuffer if it has capacity.
+func (dataStream *DataStream) AddDataToIncomingMessageBuffer(streamMessage StreamingMessage) {
+	if len(dataStream.IncomingMessageBuffer.Messages) == dataStream.IncomingMessageBuffer.Capacity {
+		return
+	}
+	dataStream.IncomingMessageBuffer.Mutex.Lock()
+	dataStream.IncomingMessageBuffer.Messages[streamMessage.SequenceNumber] = streamMessage
+	dataStream.IncomingMessageBuffer.Mutex.Unlock()
+}
+
+// RemoveDataFromIncomingMessageBuffer removes given sequence number message from IncomingMessageBuffer.
+func (dataStream *DataStream) RemoveDataFromIncomingMessageBuffer(sequenceNumber int64) {
+	dataStream.IncomingMessageBuffer.Mutex.Lock()
+	delete(dataStream.IncomingMessageBuffer.Messages, sequenceNumber)
+	dataStream.IncomingMessageBuffer.Mutex.Unlock()
+}
+
+// dataChannelIncomingMessageHandler deserialize incoming message and
+// processes that data based on MessageType.
+func (dataStream *DataStream) dataChannelIncomingMessageHandler(log log.T, rawMessage []byte) error {
+
+	streamDataMessage := &mgsContracts.AgentMessage{}
+	if err := streamDataMessage.Deserialize(log, rawMessage); err != nil {
+		log.Errorf("Cannot deserialize raw message, err: %v.", err)
+		return err
+	}
+
+	if err := streamDataMessage.Validate(); err != nil {
+		log.Errorf("Invalid StreamDataMessage, err: %v.", err)
+		return err
+	}
+
+	switch streamDataMessage.MessageType {
+	case mgsContracts.InputStreamDataMessage:
+		return dataStream.handleStreamDataMessage(log, streamDataMessage, rawMessage)
+	case mgsContracts.AcknowledgeMessage:
+		return dataStream.handleAcknowledgeMessage(log, streamDataMessage)
+	case mgsContracts.ChannelClosedMessage:
+		return dataStream.handleChannelClosedMessage(log, streamDataMessage)
+	case mgsContracts.PausePublicationMessage:
+		dataStream.handlePausePublicationMessage(log, streamDataMessage)
+		return nil
+	case mgsContracts.StartPublicationMessage:
+		dataStream.handleStartPublicationMessage(log, streamDataMessage)
+		return nil
+	default:
+		log.Warnf("Invalid message type received: %s", streamDataMessage.MessageType)
+	}
+
+	return nil
+}
+
+// calculateRetransmissionTimeout calculates message retransmission timeout value based on round trip time on given message.
+func (dataStream *DataStream) calculateRetransmissionTimeout(log log.T, streamingMessage StreamingMessage) {
+	newRoundTripTime := float64(time.Since(streamingMessage.LastSentTime))
+
+	dataStream.RoundTripTimeVariation = ((1 - mgsConfig.RTTVConstant) * dataStream.RoundTripTimeVariation) +
+		(mgsConfig.RTTVConstant * math.Abs(dataStream.RoundTripTime-newRoundTripTime))
+
+	dataStream.RoundTripTime = ((1 - mgsConfig.RTTConstant) * dataStream.RoundTripTime) +
+		(mgsConfig.RTTConstant * newRoundTripTime)
+
+	dataStream.RetransmissionTimeout = time.Duration(dataStream.RoundTripTime +
+		math.Max(float64(mgsConfig.ClockGranularity), float64(4*dataStream.RoundTripTimeVariation)))
+
+	// Ensure RetransmissionTimeout do not exceed maximum timeout defined
+	if dataStream.RetransmissionTimeout > mgsConfig.MaxTransmissionTimeout {
+		dataStream.RetransmissionTimeout = mgsConfig.MaxTransmissionTimeout
+	}
+
+	log.Tracef("Retransmission timeout calculated in mills. "+
+		"AcknowledgeMessageSequenceNumber: %d, RoundTripTime: %d, RoundTripTimeVariation: %d, RetransmissionTimeout: %d",
+		streamingMessage.SequenceNumber,
+		dataStream.RoundTripTime,
+		dataStream.RoundTripTimeVariation,
+		dataStream.RetransmissionTimeout/time.Millisecond)
+}
+
+// handleStreamDataMessage handles incoming stream data messages by processing the payload and updating expectedSequenceNumber.
+func (dataStream *DataStream) handleStreamDataMessage(log log.T,
+	streamDataMessage *mgsContracts.AgentMessage,
+	rawMessage []byte) (err error) {
+
+	dataStream.Pause = false
+	// On receiving expected stream data message, send acknowledgement, process it and increment expected sequence number by 1.
+	// Further process messages from IncomingMessageBuffer
+	if streamDataMessage.SequenceNumber == dataStream.ExpectedSequenceNumber {
+		log.Tracef("Process new incoming stream data message. Sequence Number: %d", streamDataMessage.SequenceNumber)
+		if err = dataStream.streamDataHandler(log, streamDataMessage); err != nil {
+			if errors.Is(err, mgsContracts.ErrHandlerNotReady) {
+				return nil
+			}
+			log.Errorf("Unable to process stream data payload %v, err: %v.", streamDataMessage, err)
+			return err
+		}
+
+		if err = dataStream.SendAcknowledgeMessage(log, streamDataMessage); err != nil {
+			return err
+		}
+
+		// Message is acknowledged so increment expected sequence number
+		dataStream.ExpectedSequenceNumber = dataStream.ExpectedSequenceNumber + 1
+		return dataStream.processIncomingMessageBufferItems(log)
+
+	} else if streamDataMessage.SequenceNumber > dataStream.ExpectedSequenceNumber {
+		// If incoming message sequence number is greater than expected sequence number and IncomingMessageBuffer has capacity,
+		// add message to IncomingMessageBuffer and send acknowledgement
+		log.Debugf("Unexpected sequence message received. Received Sequence Number: %d. Expected Sequence Number: %d",
+			streamDataMessage.SequenceNumber, dataStream.ExpectedSequenceNumber)
+
+		if len(dataStream.IncomingMessageBuffer.Messages) < dataStream.IncomingMessageBuffer.Capacity {
+			if err = dataStream.SendAcknowledgeMessage(log, streamDataMessage); err != nil {
+				return err
+			}
+
+			streamingMessage := StreamingMessage{
+				rawMessage,
+				streamDataMessage.SequenceNumber,
+				time.Now(),
+			}
+
+			//Add message to buffer for future processing
+			log.Debugf("Add stream data to IncomingMessageBuffer. Sequence Number: %d", streamDataMessage.SequenceNumber)
+			dataStream.AddDataToIncomingMessageBuffer(streamingMessage)
+		}
+	} else {
+		log.Tracef("Discarding already processed message. Received Sequence Number: %d. Expected Sequence Number: %d",
+			streamDataMessage.SequenceNumber, dataStream.ExpectedSequenceNumber)
+	}
+	return nil
+}
+
+// handleAcknowledgeMessage deserialize acknowledge content and process it.
+func (dataStream *DataStream) handleAcknowledgeMessage(log log.T, streamDataMessage *mgsContracts.AgentMessage) (err error) {
+	dataStream.Pause = false
+	acknowledgeMessage := &mgsContracts.AcknowledgeContent{}
+	if err = acknowledgeMessage.Deserialize(log, streamDataMessage); err != nil {
+		log.Errorf("Cannot deserialize payload to AcknowledgeMessage: %s, err: %v.", string(streamDataMessage.Payload), err)
+		return err
+	}
+
+	dataStream.ProcessAcknowledgedMessage(log, *acknowledgeMessage)
+	return nil
+}
+
+// handleChannelClosedMessage deserialize channel_closed message content and terminate the session.
+func (dataStream *DataStream) handleChannelClosedMessage(log log.T, streamDataMessage *mgsContracts.AgentMessage) (err error) {
+	channelClosedMessage := &mgsContracts.ChannelClosed{}
+	if err = channelClosedMessage.Deserialize(log, streamDataMessage); err != nil {
+		log.Errorf("Cannot deserialize payload to ChannelClosed message: %s, err: %v.", string(streamDataMessage.Payload), err)
+		return err
+	}
+
+	log.Debugf("Processing terminate session request: messageId %s, sessionId %s", channelClosedMessage.MessageId, channelClosedMessage.SessionId)
+	dataStream.cancelFlag.Set(task.Canceled)
+
+	return nil
+}
+
+// handlePausePublicationMessage sets pause status of datachannel to true.
+func (dataStream *DataStream) handlePausePublicationMessage(log log.T, streamDataMessage *mgsContracts.AgentMessage) {
+	dataStream.Pause = true
+	log.Debugf("Processed %s message. Datachannel pause status set to %s", streamDataMessage.MessageType, dataStream.Pause)
+}
+
+// handleStartPublicationMessage sets pause status of datachannel to false.
+func (dataStream *DataStream) handleStartPublicationMessage(log log.T, streamDataMessage *mgsContracts.AgentMessage) {
+	dataStream.Pause = false
+	log.Debugf("Processed %s message. Datachannel pause status set to %s", streamDataMessage.MessageType, dataStream.Pause)
+}
+
+// processIncomingMessageBufferItems checks if new expected sequence stream data is present in IncomingMessageBuffer.
+// If so process it and increment expected sequence number.
+// Repeat until expected sequence stream data is not found in IncomingMessageBuffer.
+func (dataStream *DataStream) processIncomingMessageBufferItems(log log.T) (err error) {
+	for {
+		bufferedStreamMessage := dataStream.IncomingMessageBuffer.Messages[dataStream.ExpectedSequenceNumber]
+		if bufferedStreamMessage.Content != nil {
+			log.Debugf("Process stream data message from IncomingMessageBuffer. "+
+				"Sequence Number: %d", bufferedStreamMessage.SequenceNumber)
+
+			streamDataMessage := &mgsContracts.AgentMessage{}
+
+			if err = streamDataMessage.Deserialize(log, bufferedStreamMessage.Content); err != nil {
+				log.Errorf("Cannot deserialize raw message: %d, err: %v.", bufferedStreamMessage.SequenceNumber, err)
+				return err
+			}
+			if err = dataStream.streamDataHandler(log, streamDataMessage); err != nil {
+				log.Errorf("Unable to process stream data payload, err: %v.", err)
+				return err
+			}
+
+			dataStream.ExpectedSequenceNumber = dataStream.ExpectedSequenceNumber + 1
+
+			log.Debugf("Delete stream data from IncomingMessageBuffer. Sequence Number: %d", bufferedStreamMessage.SequenceNumber)
+			dataStream.RemoveDataFromIncomingMessageBuffer(bufferedStreamMessage.SequenceNumber)
+		} else {
+			break
+		}
+	}
+	return nil
+}
+
+// getDataChannelToken calls CreateDataChannel to get the token for this session.
+func getDataChannelToken(log log.T,
+	mgsService service.Service,
+	sessionId string,
+	requestId string,
+	clientId string) (tokenValue string, err error) {
+
+	createDataChannelInput := &service.CreateDataChannelInput{
+		MessageSchemaVersion: aws.String(mgsConfig.MessageSchemaVersion),
+		RequestId:            aws.String(requestId),
+		ClientId:             aws.String(clientId),
+	}
+
+	createDataChannelOutput, err := mgsService.CreateDataChannel(log, createDataChannelInput, sessionId)
+	if err != nil || createDataChannelOutput == nil {
+		return "", fmt.Errorf("CreateDataChannel failed with no output or error: %s", err)
+	}
+
+	log.Debugf("Successfully get datachannel token")
+	return *createDataChannelOutput.TokenValue, nil
+}
+
+// getMgsEndpoint builds mgs endpoint.
+func getMgsEndpoint(context context.T, region string) (string, error) {
+	hostName := mgsConfig.GetMgsEndpoint(context, region)
+	if hostName == "" {
+		return "", fmt.Errorf("no MGS endpoint found in region %s", region)
+	}
+	var endpointBuilder bytes.Buffer
+	endpointBuilder.WriteString(mgsConfig.HttpsPrefix)
+	endpointBuilder.WriteString(hostName)
+	return endpointBuilder.String(), nil
+}
+
+// getNonRetryableDataChannelErrors returns list of non retryable errors for data channel retry strategy
+func getNonRetryableDataChannelErrors() []string {
+	return []string{mgsConfig.SessionAlreadyTerminatedError}
+}
diff --git a/agent/session/plugins/port/port.go b/agent/session/plugins/port/port.go
index b42af721e..3592919a2 100644
--- a/agent/session/plugins/port/port.go
+++ b/agent/session/plugins/port/port.go
@@ -275,7 +275,11 @@ func (p *PortPlugin) initializeParameters(config agentContracts.Configuration) (
 		return err
 	}
 
-	p.session, err = GetSession(p.context, portParameters, p.cancelled, p.dataChannel.GetClientVersion(), config.SessionId)
+	clientVersion, err := p.dataChannel.GetClientVersion()
+	if err != nil {
+		return fmt.Errorf("Retrieving Data Channel's client version failed, %v", err)
+	}
+	p.session, err = GetSession(p.context, portParameters, p.cancelled, clientVersion, config.SessionId)
 
 	return
 }
diff --git a/agent/session/plugins/port/port_basic.go b/agent/session/plugins/port/port_basic.go
index af7c53c2e..345a18ebc 100644
--- a/agent/session/plugins/port/port_basic.go
+++ b/agent/session/plugins/port/port_basic.go
@@ -126,7 +126,12 @@ func (p *BasicPortSession) WritePump(dataChannel datachannel.IDataChannel) (erro
 	packet := make([]byte, mgsConfig.StreamDataPayloadSize)
 
 	for {
-		if dataChannel.IsActive() {
+		isActive, err := dataChannel.IsActive()
+		if err != nil {
+			log.Errorf("Retrieving Data Channel's active state failed, %v", err)
+			return appconfig.ErrorExitCode
+		}
+		if isActive {
 			numBytes, err := p.conn.Read(packet)
 			if err != nil {
 				var exitCode int
diff --git a/agent/session/plugins/port/port_mux.go b/agent/session/plugins/port/port_mux.go
index d632ac090..c48389660 100644
--- a/agent/session/plugins/port/port_mux.go
+++ b/agent/session/plugins/port/port_mux.go
@@ -226,7 +226,12 @@ func (p *MuxPortSession) transferDataToMgs(ctx context.Context, dataChannel data
 		}
 	}()
 	for {
-		if dataChannel.IsActive() {
+		isActive, err := dataChannel.IsActive()
+		if err != nil {
+			log.Errorf("Retrieving Data Channel's active state failed, %v", err)
+			return err
+		}
+		if isActive {
 			packet := make([]byte, mgsConfig.StreamDataPayloadSize)
 			select {
 			case <-ctx.Done():
diff --git a/agent/session/plugins/sessionplugin/sessionplugin.go b/agent/session/plugins/sessionplugin/sessionplugin.go
index 9d7a97e69..b6164499d 100644
--- a/agent/session/plugins/sessionplugin/sessionplugin.go
+++ b/agent/session/plugins/sessionplugin/sessionplugin.go
@@ -60,10 +60,14 @@ func (p *SessionPlugin) Execute(
 	cancelFlag task.CancelFlag,
 	output iohandler.IOHandler) {
 
+	wrapperFn := func(log log.T, streamDataMessage *mgsContracts.AgentMessage) error {
+		return p.sessionPlugin.InputStreamMessageHandler(log, *streamDataMessage)
+	}
+
 	log := p.context.Log()
 	kmsKeyId := config.KmsKeyId
 
-	dataChannel, err := getDataChannelForSessionPlugin(p.context, config.SessionId, config.ClientId, cancelFlag, p.sessionPlugin.InputStreamMessageHandler)
+	dataChannel, err := getDataChannelForSessionPlugin(p.context, config.SessionId, config.ClientId, cancelFlag, wrapperFn)
 	if err != nil {
 		errorString := fmt.Errorf("Setting up data channel with id %s failed: %s", config.SessionId, err)
 		output.MarkAsFailed(errorString)
@@ -132,6 +136,7 @@ var getDataChannelForSessionPlugin = func(context context.T, sessionId string, c
 				context,
 				sessionId,
 				clientId,
+				"logReaderId",
 				inputStreamMessageHandler,
 				cancelFlag)
 		},
@@ -144,6 +149,6 @@ var getDataChannelForSessionPlugin = func(context context.T, sessionId string, c
 	if err != nil {
 		return nil, err
 	}
-	dataChannel := channel.(*datachannel.DataChannel)
+	dataChannel := channel.(datachannel.IDataChannel)
 	return dataChannel, nil
 }
diff --git a/agent/session/shell/shell.go b/agent/session/shell/shell.go
index 40948e2f5..7613e27c2 100644
--- a/agent/session/shell/shell.go
+++ b/agent/session/shell/shell.go
@@ -678,7 +678,13 @@ func (p *ShellPlugin) setupRoutineToWriteCmdPipelineOutput(log log.T, ipcFile *o
 		outputBytes := make([]byte, mgsConfig.StreamDataPayloadSize-prefixLen)
 		needPrefix := true
 		for {
-			if p.dataChannel.IsActive() {
+			isActive, err := p.dataChannel.IsActive()
+			if err != nil {
+				log.Errorf("Retrieving Data Channel's active state failed, %v", err)
+				done <- appconfig.ErrorExitCode
+				break
+			}
+			if isActive {
 				outputBytesLen, err := pipe.Read(outputBytes)
 				if err == io.EOF {
 					log.Debugf("Pipeline closed, finish pipeline reading. Is StdErr pipe: %t", isStderr)
@@ -729,7 +735,11 @@ func (p *ShellPlugin) sendExitCode(log log.T, ipcFile *os.File, exitCode int) er
 	}
 	log.Infof("Sending exit code: %d", exitCode)
 
-	if p.dataChannel.IsActive() {
+	isActive, err := p.dataChannel.IsActive()
+	if err != nil {
+		return fmt.Errorf("Retrieving Data Channel's active state failed, %v", err)
+	}
+	if isActive {
 		if unprocessedBuf, err = p.processStdoutData(log, outputBytes, outputBytesLen, unprocessedBuf, ipcFile, mgsContracts.ExitCode); err != nil {
 			log.Errorf("Error processing command pipeline output data, %v", err)
 		}
@@ -757,7 +767,11 @@ func (p *ShellPlugin) writePump(log log.T, ipcFile *os.File, initialWaitSecond i
 
 	var unprocessedBuf bytes.Buffer
 	for {
-		if p.dataChannel.IsActive() {
+		isActive, err := p.dataChannel.IsActive()
+		if err != nil {
+			return appconfig.ErrorExitCode
+		}
+		if isActive {
 			stdoutBytesLen, err := reader.Read(stdoutBytes)
 			if err != nil {
 				log.Debugf("Failed to read from command output: %s", err)
@@ -846,10 +860,19 @@ func (p *ShellPlugin) startStreamingLogs(
 		return
 	}
 
+	region, err := p.dataChannel.GetRegion()
+	if err != nil {
+		return fmt.Errorf("Retrieving Data Channel's region failed, %v", err)
+	}
+	instanceId, err := p.dataChannel.GetInstanceId()
+	if err != nil {
+		return fmt.Errorf("Retrieving Data Channel's instance ID failed, %v", err)
+	}
+
 	p.logger.cwl.SetCloudWatchMessage(
 		"1.0",
-		p.dataChannel.GetRegion(),
-		p.dataChannel.GetInstanceId(),
+		region,
+		instanceId,
 		p.runAsUser,
 		config.SessionId,
 		config.SessionOwner)
diff --git a/go.mod b/go.mod
index a88ce18d6..9bc07095d 100644
--- a/go.mod
+++ b/go.mod
@@ -28,6 +28,7 @@ require (
 	github.com/mitchellh/go-ps v1.0.0
 	github.com/nightlyone/lockfile v0.0.0
 	github.com/pborman/ansi v1.0.0
+	github.com/smartystreets/goconvey v1.7.2 // indirect
 	github.com/stretchr/testify v1.7.0
 	github.com/twinj/uuid v0.0.0-20151029044442-89173bcdda19 // Don't update -- breaks
 	github.com/xtaci/smux v1.5.15
diff --git a/go.sum b/go.sum
index f9576e68c..c87bd5ecc 100644
--- a/go.sum
+++ b/go.sum
@@ -202,6 +202,10 @@ github.com/sergi/go-diff v1.1.0 h1:we8PVUC3FE2uYfodKH/nBHMSetSfHDR6scGdBi+erh0=
 github.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
 github.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=
 github.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
+github.com/smartystreets/assertions v1.2.0 h1:42S6lae5dvLc7BrLu/0ugRtcFVjoJNMC/N3yZFZkDFs=
+github.com/smartystreets/assertions v1.2.0/go.mod h1:tcbTF8ujkAEcZ8TElKY+i30BzYlVhC/LOxJk7iOWnoo=
+github.com/smartystreets/goconvey v1.7.2 h1:9RBaZCeXEQ3UselpuwUQHltGVXvdwm6cv1hgR6gDIPg=
+github.com/smartystreets/goconvey v1.7.2/go.mod h1:Vw0tHAZW6lzCRk3xgdin6fKYcG+G3Pg9vgXWeJpQFMM=
 github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
 github.com/stretchr/objx v0.1.1 h1:2vfRuCMp5sSVIDSqO8oNnWJq7mPa6KVP3iPIwFBuy8A=
 github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
@@ -294,11 +298,8 @@ golang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81R
 golang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
 golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
 golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
-golang.org/x/net v0.0.0-20201031054903-ff519b6c9102/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
 golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
 golang.org/x/net v0.0.0-20210326060303-6b1517762897/go.mod h1:uSPa2vr4CLtc/ILN5odXGNXS6mhrKVzTaCXzk9m6W3k=
-golang.org/x/net v0.0.0-20210508051633-16afe75a6701 h1:lQVgcB3+FoAXOb20Dp6zTzAIrpj1k/yOOBN7s+Zv1rA=
-golang.org/x/net v0.0.0-20210508051633-16afe75a6701/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20210614182718-04defd469f4e h1:XpT3nA5TvE525Ne3hInMh6+GETgn27Zfm9dxsThnX2Q=
 golang.org/x/net v0.0.0-20210614182718-04defd469f4e/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20220127200216-cd36cc0744dd h1:O7DYs+zxREGLKzKoMQrtrEacpb0ZVXA5rIwylE2Xchk=
diff --git a/secure-sessions.spthy b/secure-sessions.spthy
new file mode 100644
index 000000000..57073dd9d
--- /dev/null
+++ b/secure-sessions.spthy
@@ -0,0 +1,3519 @@
+theory SSM
+begin
+
+builtins: symmetric-encryption, asymmetric-encryption, diffie-hellman, signing
+
+functions: hash/1, kdf1/1, kdf2/1
+
+
+/*
+ * Modeling thoughts:
+ * - To ensure that all operations are logged, the client is untrusted (i.e. an untrusted employee) and for arbitrary commands, we want to make sure that they
+ *      end up (in an accessible form) in the logging service
+ * - On the other hand to ensure that MGS is "just" forwarding (end-to-end encrypted) commands, we do not want to trust MGS and treat is as a DY attacker. In
+ *      this setting, client <-> agent communication happens via an untrusted network to make the least possible assumptions about MGS.
+ * - The property that all commands that get executed have been logged cannot be proven:
+ *      Main problem is the lack of causal dependency of receiving a log message and the execution of the corresponding command.
+ *      In particular:
+ *      - Due to the attacker model, the attacker might simply drop all log messages such that none arrive
+ *      - Proving that MGS sends a particular log message is a liveness property
+ * - Instead, we want accountability, i.e., a logged command has indeed been issued by the client (or the client has reveal the session key, which it shouldn't).
+ * 
+ * Properties:
+ * - Trusted MGS & agent: all commands have been logged
+ *      not trusting MGS: logging could simply not happen
+ *      not trusting agent: session key provided by agent (or commands encrypted with a company's public key) could be wrong. I.e., logging happens but reading
+ *          log will fail
+ * - 
+ *
+ * Questions:
+ * - Whom do we actually trust? If we don't trust MGS, is guaranteed logging even achievable?
+ * - How do KMS Keys (i.e. the symmetric one) work? Customers provide them (or generate them) but who guarantees that Amazon does not use it? Is this ensured
+ *      via legal contracts? If so, what other trust assumptions can we make?
+ * - We do trust KMS fully, right? I.e. agents and clients have a secure channel to KMS?
+ * - What is the KMS key's purpose in Samarth's prototype? Isn't a DH key exchange sufficient?
+ * - KMS seems to be used as a delegate which knows a party's own authentic secret keys and those of its communication partners. Can we trust the agent trust
+ *      a client's key ID (which is provided as part of the secure session response)
+ *
+ *
+ * Notes from call with Joey:
+ * - hopefully, we do not have to trust MGS for authentication purposes
+ * - KMS has to be fully trusted as it can obtain the session key (by decrypting the encrypted data key meant for the logging service) or forge signatures
+ *      during the key exchange and thus become a man-in-the-middle.
+ * - client should not be trusted and agent should not get the logging service's public key from the client. Instead, this should be provisioned (out of band)
+ *      to the agent.
+ * - talk to Victor (and Brandon / Jason?) about a static analysis to get guarantees for the code-base that we do not verify. E.g. check that security-relevant
+ *      data (reading or changing the secret or public keys) is absent outside the verified code base.
+ *
+ * Insights:
+ * - secure channel to KMS should be parameterized by run ID.
+ * - otherwise, a client with the same ID as the agent suffers from replay attacks of KMS responses as messages are treated to be sent on the same channel
+ *      from/to KMS.
+ */
+
+
+// Begin PKI & KMS infrastructure
+rule Register_pk:
+    [ Fr(~ltk) ]
+  -->
+    [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]
+
+rule Get_pk:
+    [ !Pk(A, pubkey) ]
+  -->
+    [ Out(pubkey) ]
+
+rule Reveal_ltk:
+    [ !Ltk(A, ltk) ]
+  --[ Reveal(A), LtkReveal(A), LtkRevealKey(ltk) ]->
+    [ Out(ltk) ]
+
+rule Register_KmsSignKey:
+    [ Fr(~SignKey) ]
+  --[ CreateSignKey($KeyOwnerId, $LtkARN, ~SignKey) ]->
+    [ !KmsSignKey($KeyOwnerId, $LtkARN, ~SignKey) ]
+
+rule Reveal_KmsSignKey:
+    [ !KmsSignKey(KeyOwnerId, LtkARN, SignKey) ]
+  --[ KmsSignKeyReveal(LtkARN), KmsSignKeyRevealOwner(KeyOwnerId) ]->
+    [ Out(SignKey) ]
+// End PKI & KMS infrastructure
+
+
+// KMS checks that a particular client ID is allowed to use a KMSKeyId, that's the justification for treating connections to
+// KMS as secure (i.e., authentic & confidential). Note that a hardware secure module (HSM) such as a Yubikey could act as a
+// drop-in replacement for KMS, where a secure channel would be even more justified.
+// Begin secure channel model
+rule ChanOut_KMS:
+        [ Out_KMS(A,B,clientRunId,x) ] // here, `clientRunId` is either the RunId of agent or client
+      --[ ChanOut_KMS(A,B,clientRunId,x) ]->
+        [ Sec(A,B,clientRunId,x) ] // note that we use a non-persistent `Sec` fact here as TLS prevents replay-attacks
+
+rule ChanIn_KMS:
+        [ Sec(A,B,clientRunId,x) ]
+      --[ ChanIn_KMS(A,B,clientRunId,x) ]->
+        [ In_KMS(A,B,clientRunId,x) ]
+// End secure channel model
+
+
+// Begin Agent
+rule Agent_Init [color=#177AE8]:
+    [ Fr(~RunId), !Pk($ReaderId, logPk) ]
+  -->
+    [ Setup_Agent(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk) ]
+
+rule Agent_SendSignRequest [color=#177AE8]:
+    [ Setup_Agent(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk), Fr(~x) ]
+  --[ AgentStarted() ]->
+    [ St_Agent_1(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x), Out_KMS($AgentId, $KMSId, ~RunId, <'SignRequest', $AgentLtKeyId, <'g'^~x, $ReaderId>, $ClientId>)[+] ]
+
+rule Agent_RecvSignResponse [color=#177AE8]:
+    [ St_Agent_1(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x), In_KMS($KMSId, $AgentId, ~RunId, <'SignResponse', SigX>)[+] ]
+  --[ AgentSignResponse($KMSId, $AgentId, ~RunId, <'SignResponse', SigX>) ]->
+    [ St_Agent_2(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX) ]
+
+rule Agent_SendSecureSessionRequest [color=#177AE8]:
+    let
+      X = 'g'^~x
+      msg = <'SecureSessionRequest', X, SigX, $AgentLtKeyId, $ReaderId>
+    in
+    [ St_Agent_2(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX) ]
+  --[ AgentSecureSessionRequest($AgentId, $ClientId, X, SigX, $AgentLtKeyId) ]->
+    [ St_Agent_3(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX), Out(msg), Out(<'Log', msg>) ]
+
+rule Agent_RecvSecureSessionResponse [color=#177AE8]:
+    let
+      Y = 'g' ^ z // think of this as a group element check, i.e., we have to check in the implementation that Y and the shared secret are not 0, 1, or p-1 (see https://www.redhat.com/en/blog/understanding-and-verifying-security-diffie-hellman-parameters)
+      msg = <'SecureSessionResponse', Y, SigY, ClientLtKeyId, hash(Y^~x)>
+    in
+    [ St_Agent_3(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX), In(msg) ]
+  --[ AgentSecureSessionResponse($ClientId, $AgentId, Y, SigY, ClientLtKeyId, hash(Y^~x)) ]->
+    [ St_Agent_4(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY) ]
+
+rule Agent_SendVerifyRequest [color=#177AE8]:
+    [ St_Agent_4(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY) ]
+  -->
+    [ St_Agent_5(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY), Out_KMS($AgentId, $KMSId, ~RunId, <'VerifyRequest', ClientLtKeyId, Y, SigY, $AgentId>)[+] ]
+
+rule Agent_RecvVerifyResponse [color=#177AE8]:
+    [ St_Agent_5(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY), In_KMS($KMSId, $AgentId, ~RunId, 'VerifyResponse')[+] ]
+  --[ SecretX(~x) ]->
+    [ St_Agent_6(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY) ]
+
+rule Agent_SendSessionKeySignRequest [color=#177AE8]:
+    [ St_Agent_6(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY) ]
+  -->
+    [ St_Agent_7(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY), Out_KMS($AgentId, $KMSId, ~RunId, <'SignRequest', $AgentLtKeyId, aenc(<kdf1(Y^~x), kdf2(Y^~x)>, logPk), $ClientId>)[+] ]
+
+rule Agent_RecvSessionKeySignResponse [color=#177AE8]:
+    [ St_Agent_7(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY), In_KMS($KMSId, $AgentId, ~RunId, <'SignResponse', SigSessionKey>)[+] ]
+  -->
+    [ St_Agent_8(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) ]
+
+rule Agent_SendEncryptedSessionKey [color=#177AE8]:
+    let
+      msg = <'EncryptedSessionKey', aenc(<kdf1(Y^~x), kdf2(Y^~x)>, logPk), SigSessionKey, $AgentLtKeyId, $ClientId>
+    in
+    [ St_Agent_8(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) ]
+  -->
+    [ St_Agent_9(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey), Out(msg) ]
+
+rule Agent_SendHandshakeComplete [color=#177AE8]:
+    let
+      msg = <'HandshakeComplete', senc(<'HandshakeCompletePayload', payload>, kdf1(Y^~x))>
+    in
+    [ St_Agent_9(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey), In(payload) ]
+  --[ 
+      Agent_Finish($AgentId),
+      Secret(<kdf1(Y^~x), kdf2(Y^~x)>),
+      Commit('Agent', 'Client', <$AgentId, $ClientId, kdf1(Y^~x), kdf2(Y^~x)>),
+      Running('Agent', 'Client', <$AgentId, $ClientId, kdf1(Y^~x), kdf2(Y^~x)>),
+      HonestReader($ReaderId),
+      HonestKmsOwner($AgentId),
+      HonestKmsOwner($ClientId),
+      AgentHandshakeCompleted(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, ClientLtKeyId, Y)
+    ]->
+    [ St_Agent_10(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey), Out(msg), Out(<'Log', msg>) ]
+
+rule Agent_ReceiveMessages [color=#177AE8]:
+    [ St_Agent_10(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey), In(<'Message', senc(msg, kdf2(Y^~x))>) ]
+  --[ AgentRecvLoop(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, ClientLtKeyId, Y) ]->
+    [ St_Agent_10(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey) ]
+
+rule Agent_SendMessages [color=#177AE8]:
+    let
+      msg = <'Message', senc(msg, kdf1(Y^~x))>
+    in
+    [ St_Agent_10(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey), In(msg) ]
+  --[ AgentSendLoop(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, ClientLtKeyId, Y) ]->
+    [ St_Agent_10(~RunId, $AgentId, $KMSId, $ClientId, $ReaderId, $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY, SigSessionKey), Out(msg), Out(<'Log', msg>) ]
+// End Agent
+
+
+// Begin Client
+rule Client_Init [color=#E817E3]:
+    [ Fr(~RunId) ]
+  -->
+    [ Client_Init(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId) ] // in the code, `AgentId` is called `TargetId`.
+
+rule Client_RecvSecureSessionRequest [color=#E817E3]:
+    let
+      X = 'g' ^ z // think of this as a group element check
+      msg = <'SecureSessionRequest', X, SigX, AgentLtKeyId, ReaderId>
+    in
+    [ Client_Init(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId), In(msg) ]
+  --[ ClientStarted(), ClientSecureSessionRequest($AgentId, $ClientId, X, SigX, AgentLtKeyId) ]->
+    [ Client_S1(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId) ]
+
+rule Client_SendVerifyRequest [color=#E817E3]:
+    [ Client_S1(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId) ]
+  -->
+    [ Client_S2(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId), Out_KMS($ClientId, $KMSId, ~RunId, <'VerifyRequest', AgentLtKeyId, <X, ReaderId>, SigX, $ClientId>) ]
+
+rule Client_RecvVerifyResponse [color=#E817E3]:
+    [ Client_S2(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId), In_KMS($KMSId, $ClientId, ~RunId, 'VerifyResponse')[+] ]
+  -->
+    [ Client_S3(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId) ]
+
+rule Client_SendSignRequest [color=#E817E3]:
+    [ Client_S3(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId), Fr(~y) ]
+  -->
+    [ Client_S4(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y), Out_KMS($ClientId, $KMSId, ~RunId, <'SignRequest', $ClientLtKeyId, 'g'^~y, $AgentId>) ]
+
+rule Client_RecvSignResponse [color=#E817E3]:
+    [ Client_S4(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y), In_KMS($KMSId, $ClientId, ~RunId, <'SignResponse', SigY>)[+] ]
+  --[ ClientSignResponse($KMSId, $ClientId, ~RunId, <'SignResponse', SigY>) ]->
+    [ Client_S5(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY) ]
+
+rule Client_SendSecureSessionResponse [color=#E817E3]:
+    let
+      msg = <'SecureSessionResponse', 'g'^~y, SigY, $ClientLtKeyId, hash(X^~y)>
+    in
+    [ Client_S5(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY) ]
+  --[
+      SecretY(~y),
+      ClientSendSessionResponse($ClientId),
+      ClientSecureSessionResponse($ClientId, $AgentId, X, SigX, 'g'^~y, SigY, AgentLtKeyId, $ClientLtKeyId, hash(X^~y)),
+      Running('Client', 'Agent', <$AgentId, $ClientId, kdf1(X^~y), kdf2(X^~y)>)
+    ]->
+    [ Client_S6(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY), Out(msg), Out(<'Log', msg>) ]
+
+rule Client_RecvHandshakeComplete [color=#E817E3]:
+    let
+      msg = <'HandshakeComplete', senc(<'HandshakeCompletePayload', payload>, kdf1(X^~y))>
+    in
+    [ Client_S6(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY), In(msg) ]
+  --[
+      Client_Finish($ClientId),
+      Secret(<kdf1(X^~y), kdf2(X^~y)>),
+      Commit('Client', 'Agent', <$AgentId, $ClientId, kdf1(X^~y), kdf2(X^~y)>),
+      HonestReader(ReaderId),
+      HonestKmsOwner($AgentId),
+      HonestKmsOwner($ClientId),
+      ClientHandshakeCompleted(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, ~y)
+    ]->
+    [ Client_S7(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY) ]
+
+rule Client_SendMessage [color=#E817E3]:
+    let
+      msg = <'Message', senc(payload, kdf2(X^~y))>
+    in
+    [ Client_S7(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY), In(payload) ] // we treat `payload` to be arbitrary
+  --[ ClientSendMessage(msg), ClientSendLoop(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, ~y) ]->
+    [ Client_S7(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY), Out(msg), Out(<'Log', msg>) ]
+
+rule Client_RecvMessage [color=#E817E3]:
+    [ Client_S7(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY), In(<'Message', senc(msg, kdf1(X^~y))>) ]
+  --[ ClientRecvLoop(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, ~y) ]->
+    [ Client_S7(~RunId, $ClientId, $KMSId, $AgentId, $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY) ]
+// End Client
+
+
+// Begin KMS
+rule KMS_Init [color=#E88517]:
+    []
+  --[ KMSStarted() ]->
+    [ !KMS_Init($KMSId) ]
+
+rule KMS_RecvSignRequest [color=#E88517]:
+    // We assume here that KMS authenticates AgentId and does provides access to signing operations using AgentLtKey only to authenticated clients.
+    [ !KMS_Init($KMSId), !KmsSignKey(AgentId, AgentLtKeyId, AgentLtKey), In_KMS(AgentId, $KMSId, AgentRunId, <'SignRequest', AgentLtKeyId, payload, ReceiverId>)[+] ]
+  --[ KMSSign(AgentId) ]->
+    [ KMS_Sign_S1($KMSId, AgentId, AgentRunId, AgentLtKeyId, AgentLtKey, payload, ReceiverId) ]
+  
+rule KMS_SendSignResponse [color=#E88517]:
+    [ KMS_Sign_S1($KMSId, AgentId, AgentRunId, AgentLtKeyId, AgentLtKey, payload, ReceiverId) ]
+  --[ KMSSignResponse($KMSId, AgentId, AgentRunId, <'SignResponse', sign(<payload, ReceiverId>, AgentLtKey)>) ]->
+    [ KMS_Sign_S2($KMSId, AgentId, AgentRunId, AgentLtKeyId, AgentLtKey, payload, ReceiverId), Out_KMS($KMSId, AgentId, AgentRunId, <'SignResponse', sign(<payload, ReceiverId>, AgentLtKey)>) ]
+
+rule KMS_RecvVerifyRequest [color=#E88517]:
+    [ !KMS_Init($KMSId), !KmsSignKey(AgentId, AgentLtKeyId, AgentLtKey), In_KMS(ClientId, $KMSId, ClientRunId, <'VerifyRequest', AgentLtKeyId, payload, sign(<payload, AgentId>, AgentLtKey), AgentId>)[+] ]
+  -->
+    [ KMS_Verify_S1($KMSId, ClientId, ClientRunId, AgentId, AgentLtKeyId, AgentLtKey, payload) ]
+  
+rule KMS_SendVerifyResponse [color=#E88517]:
+    [ KMS_Verify_S1($KMSId, ClientId, ClientRunId, AgentId, AgentLtKeyId, AgentLtKey, payload) ]
+  -->
+    [ KMS_Verify_S2($KMSId, ClientId, ClientRunId, AgentId, AgentLtKeyId, AgentLtKey, payload), Out_KMS($KMSId, ClientId, ClientRunId, 'VerifyResponse') ]
+// End KMS
+
+
+// Begin Log Reader
+rule Reader_Init [color=#17E81C]:
+    [ !Ltk($ReaderId, ~ltk), Fr(~RunId) ]
+  -->
+    [ Reader_Init(~RunId, $ReaderId, $KMSId, ~ltk) ]
+
+rule Reader_RecvEncryptedSessionKey [color=#17E81C]:
+    [ Reader_Init(~RunId, $ReaderId, $KMSId, ~ltk), In(<'EncryptedSessionKey', aenc(<sessionKey1, sessionKey2>, pk(~ltk)), SigSessionKey, AgentLtKeyId, ClientId>) ]
+  -->
+    [ Reader_S1(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId) ]
+
+rule Reader_SendEncryptedSessionKeyVerifyRequest [color=#17E81C]:
+    [ Reader_S1(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId) ]
+  -->
+    [ Reader_S2(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId), Out_KMS($ReaderId, $KMSId, ~RunId, <'VerifyRequest', AgentLtKeyId, aenc(<sessionKey1, sessionKey2>, pk(~ltk)), SigSessionKey, ClientId>) ]
+
+rule Reader_RecvEncryptedSessionKeyVerifyResponse [color=#17E81C]:
+    [ Reader_S2(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId), In_KMS($KMSId, $ReaderId, ~RunId, 'VerifyResponse')[+] ]
+  -->
+    [ Reader_S3(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId) ]
+
+rule Reader_DecryptMessage1 [color=#17E81C]:
+    [ Reader_S3(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId), In(<'Log', <'Message', senc(msg, sessionKey1)>>) ]
+  -->
+    [ Reader_S3(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId) ]
+
+rule Reader_DecryptMessage2 [color=#17E81C]:
+    [ Reader_S3(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId), In(<'Log', <'Message', senc(msg, sessionKey2)>>) ]
+  -->
+    [ Reader_S3(~RunId, $ReaderId, $KMSId, ClientId, ~ltk, sessionKey1, sessionKey2, SigSessionKey, AgentLtKeyId) ]
+// End Log Reader
+
+
+// Begin lemmas
+
+// similar to what `--auto-sources` would generate:
+// auto-proven!
+lemma agent_recv_sign_response_valid [sources]:
+    "All KMSId AgentId RunId SigX #i.
+      AgentSignResponse(KMSId, AgentId, RunId, <'SignResponse', SigX>)@i ==>
+        Ex #j. KMSSignResponse(KMSId, AgentId, RunId, <'SignResponse', SigX>)@j & #j < #i
+    "
+
+
+// similar to what `--auto-sources` would generate:
+// auto-proven!
+lemma client_recv_sign_response_valid [sources]:
+    "All KMSId ClientId RunId SigY #i.
+      ClientSignResponse(KMSId, ClientId, RunId, <'SignResponse', SigY>)@i ==>
+        Ex #j. KMSSignResponse(KMSId, ClientId, RunId, <'SignResponse', SigY>)@j & #j < #i
+    "
+
+
+/* Auxiliary lemmas to escape the loop in the transport phase */
+lemma loop_induction_client [use_induction, reuse]:
+  "(All RunId ClientId KMSId AgentId ClientLtKeyId AgentLtKeyId X y #i.
+    (ClientSendLoop(RunId, ClientId, KMSId, AgentId, ClientLtKeyId, AgentLtKeyId, X, y)@i ==> (Ex #j. ClientHandshakeCompleted(RunId, ClientId, KMSId, AgentId, ClientLtKeyId, AgentLtKeyId, X, y)@j & j < i))) &
+   (All RunId ClientId KMSId AgentId ClientLtKeyId AgentLtKeyId X y #i.
+    (ClientRecvLoop(RunId, ClientId, KMSId, AgentId, ClientLtKeyId, AgentLtKeyId, X, y)@i ==> (Ex #j. ClientHandshakeCompleted(RunId, ClientId, KMSId, AgentId, ClientLtKeyId, AgentLtKeyId, X, y)@j & j < i)))"
+// #region(collapsed) Proof
+induction
+  case empty_trace
+  by contradiction /* from formulas */
+next
+  case non_empty_trace
+  simplify
+  solve( (∃ RunId ClientId KMSId AgentId ClientLtKeyId AgentLtKeyId X
+            y #i.
+           (ClientSendLoop( RunId, ClientId, KMSId, AgentId, ClientLtKeyId,
+                            AgentLtKeyId, X, y
+            ) @ #i)
+          ∧
+           ∀ #j.
+            (ClientHandshakeCompleted( RunId, ClientId, KMSId, AgentId,
+                                       ClientLtKeyId, AgentLtKeyId, X, y
+             ) @ #j)
+           ⇒
+            ¬(#j < #i)) ∥
+         (∃ RunId ClientId KMSId AgentId ClientLtKeyId AgentLtKeyId X y #i.
+           (ClientRecvLoop( RunId, ClientId, KMSId, AgentId, ClientLtKeyId,
+                            AgentLtKeyId, X, y
+            ) @ #i)
+          ∧
+           ∀ #j.
+            (ClientHandshakeCompleted( RunId, ClientId, KMSId, AgentId,
+                                       ClientLtKeyId, AgentLtKeyId, X, y
+             ) @ #j)
+           ⇒
+            ¬(#j < #i)) )
+    case case_1
+    solve( Client_S7( ~RunId, $ClientId, $KMSId, $AgentId,
+                      $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY
+           ) ▶₀ #i )
+      case Client_RecvHandshakeComplete
+      by contradiction /* from formulas */
+    next
+      case Client_RecvMessage
+      by contradiction /* from formulas */
+    next
+      case Client_SendMessage
+      by contradiction /* from formulas */
+    qed
+  next
+    case case_2
+    solve( Client_S7( ~RunId, $ClientId, $KMSId, $AgentId,
+                      $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY
+           ) ▶₀ #i )
+      case Client_RecvHandshakeComplete
+      by contradiction /* from formulas */
+    next
+      case Client_RecvMessage
+      by contradiction /* from formulas */
+    next
+      case Client_SendMessage
+      by contradiction /* from formulas */
+    qed
+  qed
+qed
+// #endregion
+    
+
+lemma loop_induction_agent [use_induction, reuse]:
+  "(All RunId AgentId KMSId ClientId ReaderId AgentLtKeyId logPk x ClientLtKeyId Y #i.
+     (AgentSendLoop(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y)@i ==> (Ex #j. AgentHandshakeCompleted(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y)@j & j < i))) &
+   (All RunId AgentId KMSId ClientId ReaderId AgentLtKeyId logPk x ClientLtKeyId Y #i.
+     (AgentRecvLoop(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y)@i ==> (Ex #j. AgentHandshakeCompleted(RunId, AgentId, KMSId, ClientId, ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y)@j & j < i)))"
+// #region(collapsed) Proof
+induction
+  case empty_trace
+  by contradiction /* from formulas */
+next
+  case non_empty_trace
+  simplify
+  solve( (∃ RunId AgentId KMSId ClientId ReaderId AgentLtKeyId logPk
+            x ClientLtKeyId Y #i.
+           (AgentSendLoop( RunId, AgentId, KMSId, ClientId, ReaderId,
+                           AgentLtKeyId, logPk, x, ClientLtKeyId, Y
+            ) @ #i)
+          ∧
+           ∀ #j.
+            (AgentHandshakeCompleted( RunId, AgentId, KMSId, ClientId,
+                                      ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y
+             ) @ #j)
+           ⇒
+            ¬(#j < #i)) ∥
+         (∃ RunId AgentId KMSId ClientId ReaderId AgentLtKeyId logPk x
+            ClientLtKeyId Y #i.
+           (AgentRecvLoop( RunId, AgentId, KMSId, ClientId, ReaderId,
+                           AgentLtKeyId, logPk, x, ClientLtKeyId, Y
+            ) @ #i)
+          ∧
+           ∀ #j.
+            (AgentHandshakeCompleted( RunId, AgentId, KMSId, ClientId,
+                                      ReaderId, AgentLtKeyId, logPk, x, ClientLtKeyId, Y
+             ) @ #j)
+           ⇒
+            ¬(#j < #i)) )
+    case case_1
+    solve( St_Agent_10( ~RunId, $AgentId, $KMSId, $ClientId, $ReaderId,
+                      $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY,
+                      SigSessionKey
+           ) ▶₀ #i )
+      case Agent_ReceiveMessages
+      by contradiction /* from formulas */
+    next
+      case Agent_SendHandshakeComplete
+      by contradiction /* from formulas */
+    next
+      case Agent_SendMessages
+      by contradiction /* from formulas */
+    qed
+  next
+    case case_2
+    solve( St_Agent_10( ~RunId, $AgentId, $KMSId, $ClientId, $ReaderId,
+                      $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY,
+                      SigSessionKey
+           ) ▶₀ #i )
+      case Agent_ReceiveMessages
+      by contradiction /* from formulas */
+    next
+      case Agent_SendHandshakeComplete
+      by contradiction /* from formulas */
+    next
+      case Agent_SendMessages
+      by contradiction /* from formulas */
+    qed
+  qed
+qed
+// #endregion
+
+
+// auto-proven
+lemma Agent_can_finish_wo_reveal3:
+  exists-trace
+  " Ex AgentId #i.
+        Agent_Finish(AgentId) @ #i
+      & (All #j #k. AgentStarted() @ #j & AgentStarted() @ #k ==> #j = #k)
+      & (All #j #k. ClientStarted() @ #j & ClientStarted() @ #k ==> #j = #k)
+      & (All #j #k. KMSStarted() @ #j & KMSStarted() @ #k ==> #j = #k)
+      & not (Ex keyId #j. KmsSignKeyReveal(keyId)@ #j)
+      & not (Ex key #j. LtkRevealKey(key)@ #j)
+      & (All AgentId ClientId X SigX AgentLtKeyId #j. ClientSecureSessionRequest(AgentId, ClientId, X, SigX, AgentLtKeyId) @ #j ==> Ex #k. AgentSecureSessionRequest(AgentId, ClientId, X, SigX, AgentLtKeyId) @ #k)
+      & (All ClientId AgentId Y SigY ClientLtKeyId sharedSecret #j. AgentSecureSessionResponse(ClientId, AgentId, Y, SigY, ClientLtKeyId, sharedSecret) @ #j ==> Ex X SigX AgentLtKeyId #k. ClientSecureSessionResponse(ClientId, AgentId, X, SigX, Y, SigY, AgentLtKeyId, ClientLtKeyId, sharedSecret) @ #k)
+      & (All AgentId2 #j. Agent_Finish(AgentId2) @ #j ==> #i = #j)
+      & (All msg1 msg2 #j #k. ClientSendMessage(msg1) @ #j & ClientSendMessage(msg2) @ #k ==> #j = #k)
+  "
+
+
+// auto-proven!
+lemma Client_can_finish_wo_reveal3 [heuristic=C]:
+  exists-trace
+  " Ex ClientId #i.
+        Client_Finish(ClientId) @ #i
+      & (All #j #k. AgentStarted() @ #j & AgentStarted() @ #k ==> #j = #k)
+      & (All #j #k. ClientStarted() @ #j & ClientStarted() @ #k ==> #j = #k)
+      & (All #j #k. KMSStarted() @ #j & KMSStarted() @ #k ==> #j = #k)
+      & (All AgentId ClientId X SigX AgentLtKeyId #j. ClientSecureSessionRequest(AgentId, ClientId, X, SigX, AgentLtKeyId) @ #j ==> Ex #k. AgentSecureSessionRequest(AgentId, ClientId, X, SigX, AgentLtKeyId) @ #k)
+      & (All ClientId AgentId Y SigY ClientLtKeyId sharedSecret #j. AgentSecureSessionResponse(ClientId, AgentId, Y, SigY, ClientLtKeyId, sharedSecret) @ #j ==> Ex X SigX AgentLtKeyId #k. ClientSecureSessionResponse(ClientId, AgentId, X, SigX, Y, SigY, AgentLtKeyId, ClientLtKeyId, sharedSecret) @ #k)
+      & (All AgentId1 AgentId2 #j #k. Agent_Finish(AgentId1) @ #j & Agent_Finish(AgentId2) @ #k ==> #j = #k)
+      & (All ClientId2 #j. Client_Finish(ClientId2) @ #j ==> #i = #j)
+      & (All ClientId1 ClientId2 #j #k. ClientSendSessionResponse(ClientId1) @ #j & ClientSendSessionResponse(ClientId2) @ #k ==> #j = #k)
+  "
+
+
+// auto-proven!
+lemma x_is_secret [reuse, heuristic=S]:
+    "All x #i.
+      SecretX(x) @i ==>
+      not (Ex #j. K(x)@j)
+    "
+// #region(collapsed) Proof
+// this is a more minimal proof than what is derived automatically:
+simplify
+solve( St_Agent_5( ~RunId, $AgentId, $KMSId, $ClientId, $ReaderId,
+                 $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY
+       ) ▶₀ #i )
+  case Agent_SendVerifyRequest
+  by solve( !KU( ~x ) @ #vk )
+qed
+// #endregion
+
+
+// auto-proven!
+lemma y_is_secret [reuse, heuristic=S]:
+    "All y #i.
+      SecretY(y) @i ==>
+      not (Ex #j. K(y)@j)
+    "
+// #region(collapsed) Proof
+// this is a more minimal proof than what is derived automatically:
+simplify
+solve( Client_S5( ~RunId, $ClientId, $KMSId, $AgentId,
+                  $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY
+       ) ▶₀ #i )
+  case Client_RecvSignResponse
+  by solve( !KU( ~y ) @ #vk )
+qed
+// #endregion
+
+
+// TODO: try to shorten proof
+lemma SharedSecret_is_secret[reuse]:
+    "All x #i.
+      Secret(x) @i ==>
+      not (Ex #j. K(x)@j)
+        | (Ex C #r. KmsSignKeyRevealOwner(C)@r & HonestKmsOwner(C)@i)
+        | (Ex C #r. LtkReveal(C)@r & HonestReader(C)@i)
+    "
+// #region(collapsed) Proof
+simplify
+solve( Secret( x ) @ #i )
+  case Agent_SendHandshakeComplete
+  solve( St_Agent_9( ~RunId, $AgentId, $KMSId, $ClientId, $ReaderId,
+                     $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY,
+                     SigSessionKey
+         ) ▶₀ #i )
+    case Agent_SendEncryptedSessionKey
+    solve( In_KMS( $KMSId, $AgentId, ~RunId, 'VerifyResponse'
+           )[+] ▶₁ #vr.4 )
+      case ChanIn_KMS
+      solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                     <'VerifyRequest', $LtkARN.2, payload.3,
+                      sign(<payload.3, $KeyOwnerId>, ~SignKey.2), $KeyOwnerId>
+             )[+] ▶₂ #vr.23 )
+        case ChanIn_KMS
+        solve( In_KMS( $KMSId, $AgentId, ~RunId,
+                       <'SignResponse',
+                        sign(<payload, ReceiverId>, ~SignKey)>
+               )[+] ▶₁ #vr.13 )
+          case ChanIn_KMS
+          solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                         <'SignRequest', $LtkARN.1, payload, ReceiverId>
+                 )[+] ▶₂ #vr.17 )
+            case ChanIn_KMS_case_1
+            solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                           <'SignRequest', $AgentLtKeyId,
+                            <'g'^~x, $ReaderId>, $ClientId>
+                   )[+] ▶₂ #vr.33 )
+              case ChanIn_KMS
+              solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                             <'SignRequest', $LtkARN.1, payload, ReceiverId>
+                     )[+] ▶₂ #vr.9 )
+                case ChanIn_KMS
+                solve( !KU( sign(<Y, $AgentId>, ~SignKey.1) ) @ #vk.9 )
+                  case Agent_SendEncryptedSessionKey
+                  solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                                 <'SignResponse',
+                                  sign(<payload.1, ReceiverId>, ~SignKey.3)>
+                         )[+] ▶₁ #vr.53 )
+                    case ChanIn_KMS
+                    solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                   <'SignRequest', $LtkARN.1, payload.1, ReceiverId>
+                           )[+] ▶₂ #vr.63 )
+                      case ChanIn_KMS_case_1
+                      by solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                        <'SignRequest', $LtkARN, Y, $AgentId>
+                                )[+] ▶₂ #vr.50 )
+                    next
+                      case ChanIn_KMS_case_2
+                      by contradiction
+                    qed
+                  qed
+                next
+                  case Agent_SendSecureSessionRequest_case_1
+                  by solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                    <'SignRequest', $LtkARN, Y, $AgentId>
+                            )[+] ▶₂ #vr.46 )
+                next
+                  case Agent_SendSecureSessionRequest_case_2
+                  by solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                    <'SignRequest', $LtkARN, Y, $AgentId>
+                            )[+] ▶₂ #vr.47 )
+                next
+                  case Client_SendSecureSessionResponse_case_1
+                  solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                                 'VerifyResponse'
+                         )[+] ▶₁ #vr.45 )
+                    case ChanIn_KMS
+                    solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                   <'VerifyRequest', $LtkARN.1, payload.1,
+                                    sign(<payload.1, $KeyOwnerId>, ~SignKey.3), $KeyOwnerId
+                                   >
+                           )[+] ▶₂ #vr.58 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                     <'SignRequest', $LtkARN, Y, $AgentId>
+                             )[+] ▶₂ #vr.50 )
+                        case ChanIn_KMS
+                        solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.6 )
+                          case Agent_SendEncryptedSessionKey
+                          solve( splitEqs(13) )
+                            case split_case_1
+                            solve( !KU( ~ltk ) @ #vk.22 )
+                              case Reveal_ltk
+                              by contradiction
+                            qed
+                          next
+                            case split_case_2
+                            solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.26 )
+                              case Agent_SendSecureSessionRequest_case_1
+                              by solve( !KU( ~y ) @ #vk.31 )
+                            next
+                              case Agent_SendSecureSessionRequest_case_2
+                              by solve( !KU( ~y ) @ #vk.31 )
+                            next
+                              case Client_SendSecureSessionResponse
+                              by solve( !KU( ~x ) @ #vk.31 )
+                            next
+                              case c_exp
+                              by solve( !KU( ~x ) @ #vk.32 )
+                            qed
+                          qed
+                        next
+                          case c_kdf1
+                          solve( !KU( 'g'^(~x*~y) ) @ #vk.22 )
+                            case Agent_SendSecureSessionRequest_case_1
+                            by solve( !KU( ~y ) @ #vk.23 )
+                          next
+                            case Agent_SendSecureSessionRequest_case_2
+                            by solve( !KU( ~y ) @ #vk.23 )
+                          next
+                            case Client_SendSecureSessionResponse
+                            by solve( !KU( ~x ) @ #vk.23 )
+                          next
+                            case c_exp
+                            by solve( !KU( ~x ) @ #vk.25 )
+                          qed
+                        qed
+                      qed
+                    qed
+                  qed
+                next
+                  case Client_SendSecureSessionResponse_case_2
+                  solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                                 'VerifyResponse'
+                         )[+] ▶₁ #vr.46 )
+                    case ChanIn_KMS
+                    solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                   <'VerifyRequest', $LtkARN.1, payload.1,
+                                    sign(<payload.1, $KeyOwnerId>, ~SignKey.3), $KeyOwnerId
+                                   >
+                           )[+] ▶₂ #vr.59 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                     <'SignRequest', $LtkARN, Y, $AgentId>
+                             )[+] ▶₂ #vr.51 )
+                        case ChanIn_KMS
+                        solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.6 )
+                          case Agent_SendEncryptedSessionKey
+                          solve( splitEqs(13) )
+                            case split_case_1
+                            solve( !KU( ~ltk ) @ #vk.22 )
+                              case Reveal_ltk
+                              by contradiction
+                            qed
+                          next
+                            case split_case_2
+                            solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.26 )
+                              case Agent_SendSecureSessionRequest_case_1
+                              by solve( !KU( ~y ) @ #vk.31 )
+                            next
+                              case Agent_SendSecureSessionRequest_case_2
+                              by solve( !KU( ~y ) @ #vk.31 )
+                            next
+                              case Client_SendSecureSessionResponse
+                              by solve( !KU( ~x ) @ #vk.31 )
+                            next
+                              case c_exp
+                              by solve( !KU( ~x ) @ #vk.32 )
+                            qed
+                          qed
+                        next
+                          case c_kdf1
+                          solve( !KU( 'g'^(~x*~y) ) @ #vk.22 )
+                            case Agent_SendSecureSessionRequest_case_1
+                            by solve( !KU( ~y ) @ #vk.23 )
+                          next
+                            case Agent_SendSecureSessionRequest_case_2
+                            by solve( !KU( ~y ) @ #vk.23 )
+                          next
+                            case Client_SendSecureSessionResponse
+                            by solve( !KU( ~x ) @ #vk.23 )
+                          next
+                            case c_exp
+                            by solve( !KU( ~x ) @ #vk.25 )
+                          qed
+                        qed
+                      qed
+                    qed
+                  qed
+                next
+                  case c_sign
+                  solve( !KU( ~SignKey.1 ) @ #vk.14 )
+                    case Reveal_KmsSignKey
+                    by contradiction
+                  qed
+                qed
+              qed
+            qed
+          next
+            case ChanIn_KMS_case_2
+            by contradiction
+          qed
+        qed
+      qed
+    qed
+  qed
+next
+  case Client_RecvHandshakeComplete
+  solve( Client_S6( ~RunId, $ClientId, $KMSId, $AgentId,
+                    $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY
+         ) ▶₀ #i )
+    case Client_SendSecureSessionResponse
+    solve( !KU( senc(<'HandshakeCompletePayload', payload.1
+                     >,
+                     kdf1(z))
+           ) @ #vk.3 )
+      case Agent_SendHandshakeComplete_case_1
+      solve( In_KMS( $KMSId, $ClientId, ~RunId, 'VerifyResponse'
+             )[+] ▶₁ #vr.4 )
+        case ChanIn_KMS
+        solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                       <'VerifyRequest', $LtkARN.3, payload.4,
+                        sign(<payload.4, $KeyOwnerId>, ~SignKey.3), $KeyOwnerId>
+               )[+] ▶₂ #vr.40 )
+          case ChanIn_KMS
+          solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                         <'SignRequest', $LtkARN.1, payload, ReceiverId>
+                 )[+] ▶₂ #vr.9 )
+            case ChanIn_KMS
+            solve( In_KMS( $KMSId.1, $AgentId.1, ~RunId.1,
+                           'VerifyResponse'
+                   )[+] ▶₁ #vr.21 )
+              case ChanIn_KMS
+              solve( In_KMS( $AgentId.1, $KMSId.1, ~RunId.1,
+                             <'VerifyRequest', $LtkARN.3, payload.3,
+                              sign(<payload.3, $KeyOwnerId>, ~SignKey.4), $KeyOwnerId>
+                     )[+] ▶₂ #vr.50 )
+                case ChanIn_KMS
+                solve( In_KMS( $KMSId.1, $KeyOwnerId, ~RunId.1,
+                               <'SignResponse',
+                                sign(<payload.1, ReceiverId>, ~SignKey.2)>
+                       )[+] ▶₁ #vr.30 )
+                  case ChanIn_KMS
+                  solve( In_KMS( $KeyOwnerId, $KMSId.1, ~RunId.1,
+                                 <'SignRequest', $LtkARN.1, payload.1, ReceiverId>
+                         )[+] ▶₂ #vr.60 )
+                    case ChanIn_KMS_case_1
+                    solve( In_KMS( $KeyOwnerId, $KMSId.1, ~RunId.1,
+                                   <'SignRequest', $LtkARN.2, payload.1, ReceiverId>
+                           )[+] ▶₂ #vr.26 )
+                      case ChanIn_KMS
+                      solve( splitEqs(1) )
+                        case split_case_1
+                        solve( splitEqs(6) )
+                          case split
+                          solve( !KU( 'g'^(~y*inv(~x)) ) @ #vk.19 )
+                            case Client_SendSecureSessionResponse_case_1
+                            by solve( !KU( ~x ) @ #vk.26 )
+                          next
+                            case Client_SendSecureSessionResponse_case_2
+                            by solve( !KU( ~x ) @ #vk.26 )
+                          next
+                            case c_exp
+                            by solve( !KU( ~y ) @ #vk.26 )
+                          qed
+                        qed
+                      next
+                        case split_case_2
+                        solve( !KU( sign(<Y, $KeyOwnerId>, ~SignKey.3) ) @ #vk.21 )
+                          case Agent_SendEncryptedSessionKey
+                          by solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                            <'SignRequest', $LtkARN.1, Y, $KeyOwnerId>
+                                    )[+] ▶₂ #vr.80 )
+                        next
+                          case Agent_SendSecureSessionRequest_case_1
+                          by solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                            <'SignRequest', $LtkARN.1, Y, $KeyOwnerId>
+                                    )[+] ▶₂ #vr.76 )
+                        next
+                          case Agent_SendSecureSessionRequest_case_2
+                          by solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                            <'SignRequest', $LtkARN.1, Y, $KeyOwnerId>
+                                    )[+] ▶₂ #vr.77 )
+                        next
+                          case Client_SendSecureSessionResponse_case_1
+                          solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                         <'SignRequest', $LtkARN.1, Y, $KeyOwnerId>
+                                 )[+] ▶₂ #vr.80 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $KMSId.2, $KeyOwnerId, ~RunId.2,
+                                           'VerifyResponse'
+                                   )[+] ▶₁ #vr.75 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                             <'VerifyRequest', $LtkARN.1, payload.1,
+                                              sign(<payload.1, $KeyOwnerId.1>, ~SignKey.5),
+                                              $KeyOwnerId.1>
+                                     )[+] ▶₂ #vr.90 )
+                                case ChanIn_KMS
+                                solve( !KU( sign(<<X, ReaderId.2>, $KeyOwnerId>,
+                                                 ~SignKey.5)
+                                       ) @ #vk.29 )
+                                  case Agent_SendEncryptedSessionKey
+                                  solve( In_KMS( $KeyOwnerId, $KMSId.3, ~RunId.3,
+                                                 <'SignRequest', $LtkARN.1,
+                                                  <X, ReaderId.2>, $KeyOwnerId>
+                                         )[+] ▶₂ #vr.107 )
+                                    case ChanIn_KMS
+                                    solve( In_KMS( $KMSId.3, $KeyOwnerId, ~RunId.3,
+                                                   <'SignResponse',
+                                                    sign(<payload.1, ReceiverId>, ~SignKey.5)
+                                                   >
+                                           )[+] ▶₁ #vr.110 )
+                                      case ChanIn_KMS
+                                      solve( In_KMS( $KeyOwnerId, $KMSId.3, ~RunId.3,
+                                                     <'SignRequest', $LtkARN.1,
+                                                      payload.1, ReceiverId>
+                                             )[+] ▶₂ #vr.122 )
+                                        case ChanIn_KMS
+                                        by contradiction /* cyclic */
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case Agent_SendSecureSessionRequest_case_1
+                                  solve( In_KMS( $KMSId.3, $KeyOwnerId, ~RunId.3,
+                                                 <'SignResponse',
+                                                  sign(<<X, ReaderId.2>, $KeyOwnerId>,
+                                                       ~SignKey.5)
+                                                 >
+                                         )[+] ▶₁ #vr.99 )
+                                    case ChanIn_KMS
+                                    solve( In_KMS( $KeyOwnerId, $KMSId.3, ~RunId.3,
+                                                   <'SignRequest', $LtkARN.1,
+                                                    <X, ReaderId.2>, $KeyOwnerId>
+                                           )[+] ▶₂ #vr.108 )
+                                      case ChanIn_KMS
+                                      solve( splitEqs(0) )
+                                        case split_case_1
+                                        solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.12 )
+                                          case Agent_SendEncryptedSessionKey
+                                          solve( splitEqs(20) )
+                                            case split_case_1
+                                            solve( !KU( ~ltk ) @ #vk.25 )
+                                              case Reveal_ltk
+                                              by contradiction /* from formulas */
+                                            qed
+                                          next
+                                            case split_case_2
+                                            solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.29 )
+                                              case Agent_SendSecureSessionRequest
+                                              by solve( !KU( ~y ) @ #vk.34 )
+                                            next
+                                              case Client_SendSecureSessionResponse
+                                              by solve( !KU( ~x ) @ #vk.34 )
+                                            next
+                                              case c_exp
+                                              by solve( !KU( ~x ) @ #vk.35 )
+                                            qed
+                                          qed
+                                        next
+                                          case c_kdf1
+                                          solve( !KU( 'g'^(~x*~y) ) @ #vk.25 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.26 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.26 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.28 )
+                                          qed
+                                        qed
+                                      next
+                                        case split_case_2
+                                        solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.17 )
+                                          case Agent_SendSecureSessionRequest_case_1
+                                          by solve( !KU( ~y ) @ #vk.34 )
+                                        next
+                                          case Agent_SendSecureSessionRequest_case_2
+                                          by solve( !KU( ~y ) @ #vk.34 )
+                                        next
+                                          case Client_SendSecureSessionResponse
+                                          by solve( !KU( ~x ) @ #vk.34 )
+                                        next
+                                          case c_exp
+                                          by solve( !KU( ~x ) @ #vk.35 )
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case Agent_SendSecureSessionRequest_case_2
+                                  solve( In_KMS( $KMSId.3, $KeyOwnerId, ~RunId.3,
+                                                 <'SignResponse',
+                                                  sign(<<X, ReaderId.2>, $KeyOwnerId>,
+                                                       ~SignKey.5)
+                                                 >
+                                         )[+] ▶₁ #vr.100 )
+                                    case ChanIn_KMS
+                                    solve( In_KMS( $KeyOwnerId, $KMSId.3, ~RunId.3,
+                                                   <'SignRequest', $LtkARN.1,
+                                                    <X, ReaderId.2>, $KeyOwnerId>
+                                           )[+] ▶₂ #vr.109 )
+                                      case ChanIn_KMS
+                                      solve( splitEqs(0) )
+                                        case split_case_1
+                                        solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.12 )
+                                          case Agent_SendEncryptedSessionKey
+                                          solve( splitEqs(20) )
+                                            case split_case_1
+                                            solve( !KU( ~ltk ) @ #vk.25 )
+                                              case Reveal_ltk
+                                              by contradiction /* from formulas */
+                                            qed
+                                          next
+                                            case split_case_2
+                                            solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.29 )
+                                              case Agent_SendSecureSessionRequest
+                                              by solve( !KU( ~y ) @ #vk.34 )
+                                            next
+                                              case Client_SendSecureSessionResponse
+                                              by solve( !KU( ~x ) @ #vk.34 )
+                                            next
+                                              case c_exp
+                                              by solve( !KU( ~x ) @ #vk.35 )
+                                            qed
+                                          qed
+                                        next
+                                          case c_kdf1
+                                          solve( !KU( 'g'^(~x*~y) ) @ #vk.25 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.26 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.26 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.28 )
+                                          qed
+                                        qed
+                                      next
+                                        case split_case_2
+                                        solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.17 )
+                                          case Agent_SendSecureSessionRequest_case_1
+                                          by solve( !KU( ~y ) @ #vk.34 )
+                                        next
+                                          case Agent_SendSecureSessionRequest_case_2
+                                          by solve( !KU( ~y ) @ #vk.34 )
+                                        next
+                                          case Client_SendSecureSessionResponse
+                                          by solve( !KU( ~x ) @ #vk.34 )
+                                        next
+                                          case c_exp
+                                          by solve( !KU( ~x ) @ #vk.35 )
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  by solve( In_KMS( $KeyOwnerId, $KMSId.3, ~RunId.3,
+                                                    <'SignRequest', $LtkARN.1,
+                                                     <X, ReaderId.2>, $KeyOwnerId>
+                                            )[+] ▶₂ #vr.107 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  by solve( In_KMS( $KeyOwnerId, $KMSId.3, ~RunId.3,
+                                                    <'SignRequest', $LtkARN.1,
+                                                     <X, ReaderId.2>, $KeyOwnerId>
+                                            )[+] ▶₂ #vr.108 )
+                                next
+                                  case c_sign
+                                  solve( splitEqs(0) )
+                                    case split_case_1
+                                    solve( !KU( ~SignKey ) @ #vk.27 )
+                                      case Reveal_KmsSignKey
+                                      by contradiction /* from formulas */
+                                    qed
+                                  next
+                                    case split_case_2
+                                    solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.16 )
+                                      case Agent_SendSecureSessionRequest_case_1
+                                      by solve( !KU( ~y ) @ #vk.38 )
+                                    next
+                                      case Agent_SendSecureSessionRequest_case_2
+                                      by solve( !KU( ~y ) @ #vk.38 )
+                                    next
+                                      case Client_SendSecureSessionResponse
+                                      by solve( !KU( ~x ) @ #vk.38 )
+                                    next
+                                      case c_exp
+                                      by solve( !KU( ~x ) @ #vk.39 )
+                                    qed
+                                  qed
+                                qed
+                              qed
+                            qed
+                          qed
+                        next
+                          case Client_SendSecureSessionResponse_case_2
+                          solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                         <'SignRequest', $LtkARN.1, Y, $KeyOwnerId>
+                                 )[+] ▶₂ #vr.81 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $KMSId.2, $KeyOwnerId, ~RunId.2,
+                                           'VerifyResponse'
+                                   )[+] ▶₁ #vr.76 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                             <'VerifyRequest', $LtkARN.1, payload.1,
+                                              sign(<payload.1, $KeyOwnerId.1>, ~SignKey.5),
+                                              $KeyOwnerId.1>
+                                     )[+] ▶₂ #vr.91 )
+                                case ChanIn_KMS
+                                solve( splitEqs(0) )
+                                  case split_case_1
+                                  solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.8 )
+                                    case Agent_SendEncryptedSessionKey
+                                    solve( splitEqs(19) )
+                                      case split_case_1
+                                      solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.29 )
+                                        case Agent_SendSecureSessionRequest_case_1
+                                        by solve( !KU( ~y ) @ #vk.34 )
+                                      next
+                                        case Agent_SendSecureSessionRequest_case_2
+                                        by solve( !KU( ~y ) @ #vk.34 )
+                                      next
+                                        case Client_SendSecureSessionResponse
+                                        by solve( !KU( ~x ) @ #vk.34 )
+                                      next
+                                        case c_exp
+                                        by solve( !KU( ~x ) @ #vk.35 )
+                                      qed
+                                    next
+                                      case split_case_2
+                                      solve( !KU( sign(<<'g'^~x, ReaderId>,
+                                                        $AgentId>,
+                                                       ~SignKey)
+                                             ) @ #vk.15 )
+                                        case Agent_SendEncryptedSessionKey
+                                        by solve( In_KMS( $AgentId, $KMSId.3, ~RunId.3,
+                                                          <'SignRequest', $LtkARN,
+                                                           <'g'^~x, ReaderId>,
+                                                           $AgentId>
+                                                  )[+] ▶₂ #vr.109 )
+                                      next
+                                        case Agent_SendSecureSessionRequest_case_1
+                                        solve( In_KMS( $KMSId.3, $AgentId, ~RunId.3,
+                                                       <'SignResponse',
+                                                        sign(<<'g'^~x, ReaderId>,
+                                                              $AgentId>,
+                                                             ~SignKey)
+                                                       >
+                                               )[+] ▶₁ #vr.101 )
+                                          case ChanIn_KMS
+                                          solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                                         <'SignResponse',
+                                                          sign(<payload.2, ReceiverId.1>,
+                                                               ~SignKey.4)
+                                                         >
+                                                 )[+] ▶₁ #vr.90 )
+                                            case ChanIn_KMS
+                                            solve( In_KMS( $AgentId, $KMSId.3, ~RunId.3,
+                                                           <'SignRequest', $LtkARN,
+                                                            <'g'^~x, ReaderId>,
+                                                            $AgentId>
+                                                   )[+] ▶₂ #vr.110 )
+                                              case ChanIn_KMS
+                                              solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                                             <'SignRequest', $LtkARN,
+                                                              payload.2, ReceiverId.1>
+                                                     )[+] ▶₂ #vr.104 )
+                                                case ChanIn_KMS_case_1
+                                                solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                                               <'SignRequest',
+                                                                $LtkARN.1, payload.1, ReceiverId>
+                                                       )[+] ▶₂ #vr.85 )
+                                                  case ChanIn_KMS
+                                                  solve( splitEqs(20) )
+                                                    case split
+                                                    solve( !KU( ~ltk ) @ #vk.25 )
+                                                      case Reveal_ltk
+                                                      by contradiction /* from formulas */
+                                                    qed
+                                                  qed
+                                                qed
+                                              next
+                                                case ChanIn_KMS_case_2
+                                                by contradiction /* cyclic */
+                                              qed
+                                            qed
+                                          qed
+                                        qed
+                                      next
+                                        case Agent_SendSecureSessionRequest_case_2
+                                        solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                                       <'SignResponse',
+                                                        sign(<payload.2, ReceiverId.1>,
+                                                             ~SignKey.4)
+                                                       >
+                                               )[+] ▶₁ #vr.90 )
+                                          case ChanIn_KMS
+                                          solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                                         <'SignRequest', $LtkARN.1,
+                                                          payload.2, ReceiverId.1>
+                                                 )[+] ▶₂ #vr.111 )
+                                            case ChanIn_KMS_case_1
+                                            solve( In_KMS( $KMSId.3, $AgentId, ~RunId.3,
+                                                           <'SignResponse',
+                                                            sign(<
+                                                                  <'g'^~x, ReaderId>,
+                                                                  $AgentId>,
+                                                                 ~SignKey)
+                                                           >
+                                                   )[+] ▶₁ #vr.102 )
+                                              case ChanIn_KMS
+                                              solve( In_KMS( $AgentId, $KMSId.3, ~RunId.3,
+                                                             <'SignRequest', $LtkARN,
+                                                              <'g'^~x, ReaderId>,
+                                                              $AgentId>
+                                                     )[+] ▶₂ #vr.118 )
+                                                case ChanIn_KMS
+                                                solve( !KU( ~ltk ) @ #vk.26 )
+                                                  case Reveal_ltk
+                                                  solve( splitEqs(20) )
+                                                    case split
+                                                    by contradiction /* from formulas */
+                                                  qed
+                                                qed
+                                              qed
+                                            qed
+                                          next
+                                            case ChanIn_KMS_case_2
+                                            by contradiction /* cyclic */
+                                          qed
+                                        qed
+                                      next
+                                        case Client_SendSecureSessionResponse_case_1
+                                        by solve( In_KMS( $AgentId, $KMSId.3, ~RunId.3,
+                                                          <'SignRequest', $LtkARN,
+                                                           <'g'^~x, ReaderId>,
+                                                           $AgentId>
+                                                  )[+] ▶₂ #vr.109 )
+                                      next
+                                        case Client_SendSecureSessionResponse_case_2
+                                        by solve( In_KMS( $AgentId, $KMSId.3, ~RunId.3,
+                                                          <'SignRequest', $LtkARN,
+                                                           <'g'^~x, ReaderId>,
+                                                           $AgentId>
+                                                  )[+] ▶₂ #vr.110 )
+                                      next
+                                        case c_sign
+                                        solve( !KU( ~SignKey ) @ #vk.36 )
+                                          case Reveal_KmsSignKey
+                                          by contradiction /* from formulas */
+                                        qed
+                                      qed
+                                    qed
+                                  next
+                                    case c_kdf1
+                                    solve( !KU( 'g'^(~x*~y) ) @ #vk.25 )
+                                      case Agent_SendSecureSessionRequest_case_1
+                                      by solve( !KU( ~y ) @ #vk.26 )
+                                    next
+                                      case Agent_SendSecureSessionRequest_case_2
+                                      by solve( !KU( ~y ) @ #vk.26 )
+                                    next
+                                      case Client_SendSecureSessionResponse
+                                      by solve( !KU( ~x ) @ #vk.26 )
+                                    next
+                                      case c_exp
+                                      by solve( !KU( ~x ) @ #vk.28 )
+                                    qed
+                                  qed
+                                next
+                                  case split_case_2
+                                  solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.14 )
+                                    case Agent_SendSecureSessionRequest_case_1
+                                    by solve( !KU( ~y ) @ #vk.34 )
+                                  next
+                                    case Agent_SendSecureSessionRequest_case_2
+                                    by solve( !KU( ~y ) @ #vk.34 )
+                                  next
+                                    case Client_SendSecureSessionResponse
+                                    by solve( !KU( ~x ) @ #vk.34 )
+                                  next
+                                    case c_exp
+                                    by solve( !KU( ~x ) @ #vk.35 )
+                                  qed
+                                qed
+                              qed
+                            qed
+                          qed
+                        next
+                          case c_sign
+                          solve( !KU( sign(<<'g'^z, ReaderId>, $ClientId
+                                           >,
+                                           ~SignKey)
+                                 ) @ #vk.12 )
+                            case Agent_SendEncryptedSessionKey
+                            solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                           <'SignResponse',
+                                            sign(<payload.1, ReceiverId>, ~SignKey.5)>
+                                   )[+] ▶₁ #vr.83 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                             <'SignRequest', $LtkARN,
+                                              <'g'^z, ReaderId>, $ClientId>
+                                     )[+] ▶₂ #vr.80 )
+                                case ChanIn_KMS
+                                solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                               <'SignRequest', $LtkARN, payload.1,
+                                                ReceiverId>
+                                       )[+] ▶₂ #vr.93 )
+                                  case ChanIn_KMS
+                                  by contradiction /* cyclic */
+                                qed
+                              qed
+                            qed
+                          next
+                            case Agent_SendSecureSessionRequest_case_1
+                            solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                           <'SignResponse',
+                                            sign(<<'g'^z, ReaderId>, $ClientId>,
+                                                 ~SignKey)
+                                           >
+                                   )[+] ▶₁ #vr.72 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                             <'SignRequest', $LtkARN,
+                                              <'g'^z, ReaderId>, $ClientId>
+                                     )[+] ▶₂ #vr.81 )
+                                case ChanIn_KMS
+                                solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.12 )
+                                  case Agent_SendEncryptedSessionKey
+                                  solve( splitEqs(15) )
+                                    case split_case_1
+                                    solve( !KU( ~ltk ) @ #vk.29 )
+                                      case Reveal_ltk
+                                      by contradiction /* from formulas */
+                                    qed
+                                  next
+                                    case split_case_2
+                                    solve( !KU( 'g'^(~x*~y*inv(~x.3)) ) @ #vk.31 )
+                                      case Agent_SendSecureSessionRequest
+                                      by solve( !KU( ~y ) @ #vk.38 )
+                                    next
+                                      case Client_SendSecureSessionResponse_case_1
+                                      by solve( !KU( ~x ) @ #vk.38 )
+                                    next
+                                      case Client_SendSecureSessionResponse_case_2
+                                      by solve( !KU( ~x ) @ #vk.38 )
+                                    next
+                                      case c_exp
+                                      by solve( !KU( ~x ) @ #vk.39 )
+                                    qed
+                                  qed
+                                next
+                                  case c_kdf1
+                                  solve( !KU( 'g'^(~x*~y) ) @ #vk.28 )
+                                    case Agent_SendSecureSessionRequest
+                                    by solve( !KU( ~y ) @ #vk.29 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_1
+                                    by solve( !KU( ~x ) @ #vk.29 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_2
+                                    by solve( !KU( ~x ) @ #vk.29 )
+                                  next
+                                    case c_exp
+                                    by solve( !KU( ~x ) @ #vk.31 )
+                                  qed
+                                qed
+                              qed
+                            qed
+                          next
+                            case Agent_SendSecureSessionRequest_case_2
+                            solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                           <'SignResponse',
+                                            sign(<<'g'^z, ReaderId>, $ClientId>,
+                                                 ~SignKey)
+                                           >
+                                   )[+] ▶₁ #vr.73 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                             <'SignRequest', $LtkARN,
+                                              <'g'^z, ReaderId>, $ClientId>
+                                     )[+] ▶₂ #vr.82 )
+                                case ChanIn_KMS
+                                solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.11 )
+                                  case Agent_SendEncryptedSessionKey
+                                  solve( splitEqs(15) )
+                                    case split_case_1
+                                    solve( !KU( ~ltk ) @ #vk.29 )
+                                      case Reveal_ltk
+                                      by contradiction /* from formulas */
+                                    qed
+                                  next
+                                    case split_case_2
+                                    solve( !KU( 'g'^(~x*~y*inv(~x.3)) ) @ #vk.31 )
+                                      case Agent_SendSecureSessionRequest
+                                      by solve( !KU( ~y ) @ #vk.38 )
+                                    next
+                                      case Client_SendSecureSessionResponse_case_1
+                                      by solve( !KU( ~x ) @ #vk.38 )
+                                    next
+                                      case Client_SendSecureSessionResponse_case_2
+                                      by solve( !KU( ~x ) @ #vk.38 )
+                                    next
+                                      case c_exp
+                                      by solve( !KU( ~x ) @ #vk.39 )
+                                    qed
+                                  qed
+                                next
+                                  case c_kdf1
+                                  solve( !KU( 'g'^(~x*~y) ) @ #vk.28 )
+                                    case Agent_SendSecureSessionRequest
+                                    by solve( !KU( ~y ) @ #vk.29 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_1
+                                    by solve( !KU( ~x ) @ #vk.29 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_2
+                                    by solve( !KU( ~x ) @ #vk.29 )
+                                  next
+                                    case c_exp
+                                    by solve( !KU( ~x ) @ #vk.31 )
+                                  qed
+                                qed
+                              qed
+                            qed
+                          next
+                            case Client_SendSecureSessionResponse_case_1
+                            solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                           'VerifyResponse'
+                                   )[+] ▶₁ #vr.75 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                             <'VerifyRequest', $LtkARN.2, payload.1,
+                                              sign(<payload.1, $KeyOwnerId.1>, ~SignKey.5),
+                                              $KeyOwnerId.1>
+                                     )[+] ▶₂ #vr.88 )
+                                case ChanIn_KMS
+                                by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                  <'SignRequest', $LtkARN,
+                                                   <'g'^z, ReaderId>, $ClientId>
+                                          )[+] ▶₂ #vr.80 )
+                              qed
+                            qed
+                          next
+                            case Client_SendSecureSessionResponse_case_2
+                            by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                              <'SignRequest', $LtkARN,
+                                               <'g'^z, ReaderId>, $ClientId>
+                                      )[+] ▶₂ #vr.81 )
+                          next
+                            case c_sign
+                            solve( !KU( ~SignKey ) @ #vk.30 )
+                              case Reveal_KmsSignKey
+                              by contradiction /* from formulas */
+                            qed
+                          qed
+                        qed
+                      qed
+                    qed
+                  next
+                    case ChanIn_KMS_case_2
+                    by contradiction /* cyclic */
+                  qed
+                qed
+              qed
+            qed
+          qed
+        qed
+      qed
+    next
+      case Agent_SendHandshakeComplete_case_2
+      solve( In_KMS( $KMSId, $ClientId, ~RunId, 'VerifyResponse'
+             )[+] ▶₁ #vr.4 )
+        case ChanIn_KMS
+        solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                       <'VerifyRequest', $LtkARN.3, payload.4,
+                        sign(<payload.4, $KeyOwnerId>, ~SignKey.3), $KeyOwnerId>
+               )[+] ▶₂ #vr.41 )
+          case ChanIn_KMS
+          solve( In_KMS( $KMSId.1, $AgentId.1, ~RunId.1,
+                         <'SignResponse',
+                          sign(<payload.2, ReceiverId.1>, ~SignKey.2)>
+                 )[+] ▶₁ #vr.31 )
+            case ChanIn_KMS
+            solve( In_KMS( $KMSId.1, $AgentId.1, ~RunId.1,
+                           'VerifyResponse'
+                   )[+] ▶₁ #vr.22 )
+              case ChanIn_KMS
+              solve( In_KMS( $AgentId.1, $KMSId.1, ~RunId.1,
+                             <'VerifyRequest', $LtkARN.4, payload.4,
+                              sign(<payload.4, $KeyOwnerId>, ~SignKey.4), $KeyOwnerId>
+                     )[+] ▶₂ #vr.54 )
+                case ChanIn_KMS
+                solve( In_KMS( $KeyOwnerId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN.2, payload.2, ReceiverId.1>
+                       )[+] ▶₂ #vr.59 )
+                  case ChanIn_KMS_case_1
+                  solve( In_KMS( $KeyOwnerId, $KMSId.1, ~RunId.1,
+                                 <'SignRequest', $AgentLtKeyId,
+                                  <'g'^~x, $ReaderId.1>, $ClientId.1>
+                         )[+] ▶₂ #vr.49 )
+                    case ChanIn_KMS
+                    solve( In_KMS( $KeyOwnerId, $KMSId.1, ~RunId.1,
+                                   <'SignRequest', $LtkARN.3, payload.2, ReceiverId.1>
+                           )[+] ▶₂ #vr.27 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                                     <'SignRequest', $LtkARN.1, payload, ReceiverId>
+                             )[+] ▶₂ #vr.9 )
+                        case ChanIn_KMS
+                        solve( !KU( sign(<<X, ReaderId>, $ClientId>, ~SignKey)
+                               ) @ #vk.11 )
+                          case Agent_SendEncryptedSessionKey
+                          solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                         <'SignResponse',
+                                          sign(<payload.1, ReceiverId>, ~SignKey.5)>
+                                 )[+] ▶₁ #vr.81 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                           <'SignRequest', $LtkARN, <X, ReaderId>,
+                                            $ClientId>
+                                   )[+] ▶₂ #vr.78 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                             <'SignRequest', $LtkARN, payload.1,
+                                              ReceiverId>
+                                     )[+] ▶₂ #vr.91 )
+                                case ChanIn_KMS
+                                by contradiction /* cyclic */
+                              qed
+                            qed
+                          qed
+                        next
+                          case Agent_SendSecureSessionRequest_case_1
+                          solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                         <'SignResponse',
+                                          sign(<<X, ReaderId>, $ClientId>, ~SignKey)>
+                                 )[+] ▶₁ #vr.70 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                           <'SignRequest', $LtkARN, <X, ReaderId>,
+                                            $ClientId>
+                                   )[+] ▶₂ #vr.79 )
+                              case ChanIn_KMS
+                              solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.8 )
+                                case Agent_SendEncryptedSessionKey
+                                solve( splitEqs(14) )
+                                  case split_case_1
+                                  solve( !KU( ~ltk ) @ #vk.26 )
+                                    case Reveal_ltk
+                                    by contradiction /* from formulas */
+                                  qed
+                                next
+                                  case split_case_2
+                                  solve( !KU( 'g'^(~x*~y*inv(~x.3)) ) @ #vk.28 )
+                                    case Agent_SendSecureSessionRequest
+                                    by solve( !KU( ~y ) @ #vk.35 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_1
+                                    by solve( !KU( ~x ) @ #vk.35 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_2
+                                    by solve( !KU( ~x ) @ #vk.35 )
+                                  next
+                                    case c_exp
+                                    by solve( !KU( ~x ) @ #vk.36 )
+                                  qed
+                                qed
+                              next
+                                case c_kdf1
+                                solve( !KU( 'g'^(~x*~y) ) @ #vk.25 )
+                                  case Agent_SendSecureSessionRequest
+                                  by solve( !KU( ~y ) @ #vk.26 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  by solve( !KU( ~x ) @ #vk.26 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  by solve( !KU( ~x ) @ #vk.26 )
+                                next
+                                  case c_exp
+                                  by solve( !KU( ~x ) @ #vk.28 )
+                                qed
+                              qed
+                            qed
+                          qed
+                        next
+                          case Agent_SendSecureSessionRequest_case_2
+                          solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                         <'SignResponse',
+                                          sign(<<X, ReaderId>, $ClientId>, ~SignKey)>
+                                 )[+] ▶₁ #vr.71 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                           <'SignRequest', $LtkARN, <X, ReaderId>,
+                                            $ClientId>
+                                   )[+] ▶₂ #vr.80 )
+                              case ChanIn_KMS
+                              solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.7 )
+                                case Agent_SendEncryptedSessionKey
+                                solve( splitEqs(14) )
+                                  case split_case_1
+                                  solve( !KU( ~ltk ) @ #vk.26 )
+                                    case Reveal_ltk
+                                    by contradiction /* from formulas */
+                                  qed
+                                next
+                                  case split_case_2
+                                  solve( !KU( 'g'^(~x*~y*inv(~x.3)) ) @ #vk.28 )
+                                    case Agent_SendSecureSessionRequest
+                                    by solve( !KU( ~y ) @ #vk.35 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_1
+                                    by solve( !KU( ~x ) @ #vk.35 )
+                                  next
+                                    case Client_SendSecureSessionResponse_case_2
+                                    by solve( !KU( ~x ) @ #vk.35 )
+                                  next
+                                    case c_exp
+                                    by solve( !KU( ~x ) @ #vk.36 )
+                                  qed
+                                qed
+                              next
+                                case c_kdf1
+                                solve( !KU( 'g'^(~x*~y) ) @ #vk.25 )
+                                  case Agent_SendSecureSessionRequest
+                                  by solve( !KU( ~y ) @ #vk.26 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  by solve( !KU( ~x ) @ #vk.26 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  by solve( !KU( ~x ) @ #vk.26 )
+                                next
+                                  case c_exp
+                                  by solve( !KU( ~x ) @ #vk.28 )
+                                qed
+                              qed
+                            qed
+                          qed
+                        next
+                          case Client_SendSecureSessionResponse_case_1
+                          by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                            <'SignRequest', $LtkARN,
+                                             <X, ReaderId>, $ClientId>
+                                    )[+] ▶₂ #vr.78 )
+                        next
+                          case Client_SendSecureSessionResponse_case_2
+                          by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                            <'SignRequest', $LtkARN,
+                                             <X, ReaderId>, $ClientId>
+                                    )[+] ▶₂ #vr.79 )
+                        next
+                          case c_sign
+                          solve( !KU( ~SignKey ) @ #vk.27 )
+                            case Reveal_KmsSignKey
+                            by contradiction /* from formulas */
+                          qed
+                        qed
+                      qed
+                    qed
+                  qed
+                next
+                  case ChanIn_KMS_case_2
+                  by contradiction /* cyclic */
+                qed
+              qed
+            qed
+          qed
+        qed
+      qed
+    next
+      case c_senc
+      solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                     <'SignRequest', $LtkARN, payload, ReceiverId>
+             )[+] ▶₂ #vr.9 )
+        case ChanIn_KMS
+        solve( In_KMS( $KMSId, $ClientId, ~RunId, 'VerifyResponse'
+               )[+] ▶₁ #vr.4 )
+          case ChanIn_KMS
+          solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                         <'VerifyRequest', $LtkARN, payload.1,
+                          sign(<payload.1, $KeyOwnerId>, ~SignKey.1), $KeyOwnerId>
+                 )[+] ▶₂ #vr.20 )
+            case ChanIn_KMS
+            solve( !KU( sign(<<X, ReaderId>, $ClientId>, ~SignKey)
+                   ) @ #vk.11 )
+              case Agent_SendEncryptedSessionKey
+              solve( In_KMS( $KMSId.1, $ClientId, ~RunId.1,
+                             <'SignResponse',
+                              sign(<payload.1, ReceiverId>, ~SignKey.2)>
+                     )[+] ▶₁ #vr.40 )
+                case ChanIn_KMS
+                solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                               >
+                       )[+] ▶₂ #vr.37 )
+                  case ChanIn_KMS
+                  solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                                 <'SignRequest', $LtkARN, payload.1, ReceiverId>
+                         )[+] ▶₂ #vr.50 )
+                    case ChanIn_KMS
+                    by contradiction /* cyclic */
+                  qed
+                qed
+              qed
+            next
+              case Agent_SendSecureSessionRequest_case_1
+              solve( In_KMS( $KMSId.1, $ClientId, ~RunId.1,
+                             <'SignResponse',
+                              sign(<<X, ReaderId>, $ClientId>, ~SignKey)>
+                     )[+] ▶₁ #vr.29 )
+                case ChanIn_KMS
+                solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                               >
+                       )[+] ▶₂ #vr.38 )
+                  case ChanIn_KMS
+                  solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.8 )
+                    case Agent_SendEncryptedSessionKey
+                    solve( splitEqs(7) )
+                      case split_case_1
+                      solve( !KU( ~ltk ) @ #vk.18 )
+                        case Reveal_ltk
+                        by contradiction /* from formulas */
+                      qed
+                    next
+                      case split_case_2
+                      solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.22 )
+                        case Agent_SendSecureSessionRequest
+                        by solve( !KU( ~y ) @ #vk.29 )
+                      next
+                        case Client_SendSecureSessionResponse_case_1
+                        by solve( !KU( ~x ) @ #vk.29 )
+                      next
+                        case Client_SendSecureSessionResponse_case_2
+                        by solve( !KU( ~x ) @ #vk.29 )
+                      next
+                        case c_exp
+                        by solve( !KU( ~x ) @ #vk.30 )
+                      qed
+                    qed
+                  next
+                    case c_kdf1
+                    solve( !KU( 'g'^(~x*~y) ) @ #vk.18 )
+                      case Agent_SendSecureSessionRequest
+                      by solve( !KU( ~y ) @ #vk.19 )
+                    next
+                      case Client_SendSecureSessionResponse_case_1
+                      by solve( !KU( ~x ) @ #vk.19 )
+                    next
+                      case Client_SendSecureSessionResponse_case_2
+                      by solve( !KU( ~x ) @ #vk.19 )
+                    next
+                      case c_exp
+                      by solve( !KU( ~x ) @ #vk.21 )
+                    qed
+                  qed
+                qed
+              qed
+            next
+              case Agent_SendSecureSessionRequest_case_2
+              solve( In_KMS( $KMSId.1, $ClientId, ~RunId.1,
+                             <'SignResponse',
+                              sign(<<X, ReaderId>, $ClientId>, ~SignKey)>
+                     )[+] ▶₁ #vr.30 )
+                case ChanIn_KMS
+                solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                               >
+                       )[+] ▶₂ #vr.39 )
+                  case ChanIn_KMS
+                  solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.7 )
+                    case Agent_SendEncryptedSessionKey
+                    solve( splitEqs(7) )
+                      case split_case_1
+                      solve( !KU( ~ltk ) @ #vk.18 )
+                        case Reveal_ltk
+                        by contradiction /* from formulas */
+                      qed
+                    next
+                      case split_case_2
+                      solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.22 )
+                        case Agent_SendSecureSessionRequest
+                        by solve( !KU( ~y ) @ #vk.29 )
+                      next
+                        case Client_SendSecureSessionResponse_case_1
+                        by solve( !KU( ~x ) @ #vk.29 )
+                      next
+                        case Client_SendSecureSessionResponse_case_2
+                        by solve( !KU( ~x ) @ #vk.29 )
+                      next
+                        case c_exp
+                        by solve( !KU( ~x ) @ #vk.30 )
+                      qed
+                    qed
+                  next
+                    case c_kdf1
+                    solve( !KU( 'g'^(~x*~y) ) @ #vk.18 )
+                      case Agent_SendSecureSessionRequest
+                      by solve( !KU( ~y ) @ #vk.19 )
+                    next
+                      case Client_SendSecureSessionResponse_case_1
+                      by solve( !KU( ~x ) @ #vk.19 )
+                    next
+                      case Client_SendSecureSessionResponse_case_2
+                      by solve( !KU( ~x ) @ #vk.19 )
+                    next
+                      case c_exp
+                      by solve( !KU( ~x ) @ #vk.21 )
+                    qed
+                  qed
+                qed
+              qed
+            next
+              case Client_SendSecureSessionResponse_case_1
+              by solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                                <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                                >
+                        )[+] ▶₂ #vr.37 )
+            next
+              case Client_SendSecureSessionResponse_case_2
+              by solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                                <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                                >
+                        )[+] ▶₂ #vr.38 )
+            next
+              case c_sign
+              solve( !KU( ~SignKey ) @ #vk.20 )
+                case Reveal_KmsSignKey
+                by contradiction /* from formulas */
+              qed
+            qed
+          qed
+        qed
+      qed
+    qed
+  qed
+qed
+// #endregion
+
+
+// TODO: try to shorten the proof
+lemma injectiveagreement_agent:
+    "All AgentId ClientId k1 k2 #i.
+      Commit('Agent', 'Client', <AgentId, ClientId, k1, k2>) @i
+      ==> (Ex #j. Running('Client', 'Agent', <AgentId, ClientId, k1, k2>) @j & j < i
+          & not (Ex AgentId2 ClientId2 #i2. Commit('Agent', 'Client', <AgentId2, ClientId2, k1, k2>) @i2
+                             & not (#i2 = #i)))
+                | (Ex C #r. LtkReveal(C)@r & HonestReader(C)@i)
+                | (Ex C #r. KmsSignKeyRevealOwner(C)@r & HonestKmsOwner(C)@i)"
+// #region(collapsed) Proof
+simplify
+solve( Commit( 'Agent', 'Client',
+               <AgentId, ClientId, k1, k2>
+       ) @ #i )
+  case Agent_SendHandshakeComplete
+  solve( St_Agent_9( ~RunId, $AgentId, $KMSId, $ClientId, $ReaderId,
+                     $AgentLtKeyId, logPk, ~x, SigX, ClientLtKeyId, Y, SigY,
+                     SigSessionKey
+         ) ▶₀ #i )
+    case Agent_SendEncryptedSessionKey
+    solve( In_KMS( $KMSId, $AgentId, ~RunId, 'VerifyResponse'
+           )[+] ▶₁ #vr.4 )
+      case ChanIn_KMS
+      solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                     <'VerifyRequest', $LtkARN.2, payload.3,
+                      sign(<payload.3, $KeyOwnerId>, ~SignKey.2), $KeyOwnerId>
+             )[+] ▶₂ #vr.23 )
+        case ChanIn_KMS
+        solve( In_KMS( $KMSId, $AgentId, ~RunId,
+                       <'SignResponse',
+                        sign(<payload, ReceiverId>, ~SignKey)>
+               )[+] ▶₁ #vr.13 )
+          case ChanIn_KMS
+          solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                         <'SignRequest', $LtkARN.1, payload, ReceiverId>
+                 )[+] ▶₂ #vr.33 )
+            case ChanIn_KMS_case_1
+            solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                           <'SignRequest', $LtkARN.1, payload, ReceiverId>
+                   )[+] ▶₂ #vr.9 )
+              case ChanIn_KMS
+              solve( !KU( sign(<Y, $AgentId>, ~SignKey.1) ) @ #vk.6 )
+                case Agent_SendEncryptedSessionKey
+                by solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                  <'SignRequest', $LtkARN, Y, $AgentId>
+                          )[+] ▶₂ #vr.53 )
+              next
+                case Agent_SendSecureSessionRequest_case_1
+                solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                               <'SignResponse', sign(<Y, $AgentId>, ~SignKey.1)
+                               >
+                       )[+] ▶₁ #vr.45 )
+                  case ChanIn_KMS
+                  by solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                    <'SignRequest', $LtkARN, Y, $AgentId>
+                            )[+] ▶₂ #vr.54 )
+                qed
+              next
+                case Agent_SendSecureSessionRequest_case_2
+                solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                               <'SignResponse', sign(<Y, $AgentId>, ~SignKey.1)
+                               >
+                       )[+] ▶₁ #vr.46 )
+                  case ChanIn_KMS
+                  by solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                    <'SignRequest', $LtkARN, Y, $AgentId>
+                            )[+] ▶₂ #vr.55 )
+                qed
+              next
+                case Client_SendSecureSessionResponse_case_1
+                solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                               'VerifyResponse'
+                       )[+] ▶₁ #vr.48 )
+                  case ChanIn_KMS
+                  solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                 <'VerifyRequest', $LtkARN.1, payload.1,
+                                  sign(<payload.1, $KeyOwnerId>, ~SignKey.3), $KeyOwnerId>
+                         )[+] ▶₂ #vr.61 )
+                    case ChanIn_KMS
+                    solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                   <'SignRequest', $LtkARN, Y, $AgentId>
+                           )[+] ▶₂ #vr.53 )
+                      case ChanIn_KMS
+                      solve( !KU( sign(<<X, ReaderId.1>, $AgentId>,
+                                       ~SignKey.3)
+                             ) @ #vk.15 )
+                        case Agent_SendEncryptedSessionKey
+                        solve( In_KMS( $KMSId.2, $AgentId, ~RunId.2,
+                                       <'SignResponse',
+                                        sign(<payload.1, ReceiverId>, ~SignKey.4)>
+                               )[+] ▶₁ #vr.83 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                         <'SignRequest', $LtkARN.1,
+                                          <X, ReaderId.1>, $AgentId>
+                                 )[+] ▶₂ #vr.80 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                           <'SignRequest', $LtkARN, payload.1, ReceiverId
+                                           >
+                                   )[+] ▶₂ #vr.93 )
+                              case ChanIn_KMS
+                              by contradiction /* cyclic */
+                            qed
+                          qed
+                        qed
+                      next
+                        case Agent_SendSecureSessionRequest_case_1
+                        solve( In_KMS( $KMSId.2, $AgentId, ~RunId.2,
+                                       <'SignResponse',
+                                        sign(<<X, ReaderId.1>, $AgentId>, ~SignKey.3)
+                                       >
+                               )[+] ▶₁ #vr.72 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                         <'SignRequest', $LtkARN, <X, ReaderId.1>,
+                                          $AgentId>
+                                 )[+] ▶₂ #vr.81 )
+                            case ChanIn_KMS
+                            solve( !KU( hash('g'^(~x*~y)) ) @ #vk.13 )
+                              case Client_SendSecureSessionResponse_case_1
+                              solve( In_KMS( $ClientId.1, $KMSId.3, ~RunId.3,
+                                             <'SignRequest', $LtkARN.1, payload.1,
+                                              ReceiverId>
+                                     )[+] ▶₂ #vr.98 )
+                                case ChanIn_KMS
+                                solve( In_KMS( $KMSId.3, $ClientId.1, ~RunId.3,
+                                               'VerifyResponse'
+                                       )[+] ▶₁ #vr.93 )
+                                  case ChanIn_KMS
+                                  solve( In_KMS( $ClientId.1, $KMSId.3, ~RunId.3,
+                                                 <'VerifyRequest', $LtkARN.1, payload.1,
+                                                  sign(<payload.1, $KeyOwnerId>, ~SignKey.5),
+                                                  $KeyOwnerId>
+                                         )[+] ▶₂ #vr.109 )
+                                    case ChanIn_KMS
+                                    solve( splitEqs(11) )
+                                      case split_case_1
+                                      solve( Commit( 'Agent', 'Client',
+                                                     <AgentId2, ClientId2,
+                                                      kdf1('g'^(~x*~y)),
+                                                      kdf2('g'^(~x*~y))>
+                                             ) @ #i2 )
+                                        case Agent_SendHandshakeComplete
+                                        solve( St_Agent_9( ~RunId.1, $AgentId.1, $KMSId.1,
+                                                           $ClientId, $ReaderId.1, $AgentLtKeyId.1,
+                                                           logPk, ~x.1, SigX, ClientLtKeyId.1,
+                                                           'g'^x.2, SigY, SigSessionKey
+                                               ) ▶₀ #i2 )
+                                          case Agent_SendEncryptedSessionKey
+                                          solve( In_KMS( $KMSId.1, $AgentId.1, ~RunId.1,
+                                                         <'SignResponse',
+                                                          sign(<payload.1, ReceiverId>,
+                                                               ~SignKey.3)
+                                                         >
+                                                 )[+] ▶₁ #vr.89 )
+                                            case ChanIn_KMS
+                                            solve( In_KMS( $KMSId.1, $AgentId.1, ~RunId.1,
+                                                           'VerifyResponse'
+                                                   )[+] ▶₁ #vr.80 )
+                                              case ChanIn_KMS
+                                              solve( In_KMS( $AgentId.1, $KMSId.1, ~RunId.1,
+                                                             <'VerifyRequest',
+                                                              $LtkARN.2, payload.4,
+                                                              sign(<payload.4, $KeyOwnerId>,
+                                                                   ~SignKey.5),
+                                                              $KeyOwnerId>
+                                                     )[+] ▶₂ #vr.104 )
+                                                case ChanIn_KMS
+                                                solve( In_KMS( $KeyOwnerId, $KMSId.1, ~RunId.1,
+                                                               <'SignRequest',
+                                                                $LtkARN.1, payload.1, ReceiverId>
+                                                       )[+] ▶₂ #vr.99 )
+                                                  case ChanIn_KMS_case_1
+                                                  solve( In_KMS( $KeyOwnerId, $KMSId.1, ~RunId.1,
+                                                                 <'SignRequest',
+                                                                  $LtkARN.1, payload.1, ReceiverId
+                                                                 >
+                                                         )[+] ▶₂ #vr.85 )
+                                                    case ChanIn_KMS
+                                                    solve( splitEqs(15) )
+                                                      case split_case_1
+                                                      by contradiction /* from formulas */
+                                                    next
+                                                      case split_case_2
+                                                      solve( !KU( 'g'^(~x*~y*inv(~x.1))
+                                                             ) @ #vk.23 )
+                                                        case Agent_SendSecureSessionRequest
+                                                        by solve( !KU( ~y ) @ #vk.28 )
+                                                      next
+                                                        case Client_SendSecureSessionResponse
+                                                        by solve( !KU( ~x ) @ #vk.28 )
+                                                      next
+                                                        case c_exp
+                                                        by solve( !KU( ~x ) @ #vk.29 )
+                                                      qed
+                                                    qed
+                                                  qed
+                                                next
+                                                  case ChanIn_KMS_case_2
+                                                  by contradiction /* cyclic */
+                                                qed
+                                              qed
+                                            qed
+                                          qed
+                                        qed
+                                      qed
+                                    next
+                                      case split_case_2
+                                      solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.21 )
+                                        case Agent_SendSecureSessionRequest_case_1
+                                        by solve( !KU( ~y ) @ #vk.28 )
+                                      next
+                                        case Agent_SendSecureSessionRequest_case_2
+                                        by solve( !KU( ~y ) @ #vk.28 )
+                                      next
+                                        case Client_SendSecureSessionResponse
+                                        by solve( !KU( ~x ) @ #vk.28 )
+                                      next
+                                        case c_exp
+                                        by solve( !KU( ~x ) @ #vk.29 )
+                                      qed
+                                    qed
+                                  qed
+                                qed
+                              qed
+                            next
+                              case Client_SendSecureSessionResponse_case_2
+                              solve( splitEqs(11) )
+                                case split
+                                solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.21 )
+                                  case Agent_SendSecureSessionRequest_case_1
+                                  by solve( !KU( ~y ) @ #vk.28 )
+                                next
+                                  case Agent_SendSecureSessionRequest_case_2
+                                  by solve( !KU( ~y ) @ #vk.28 )
+                                next
+                                  case Client_SendSecureSessionResponse
+                                  by solve( !KU( ~x ) @ #vk.28 )
+                                next
+                                  case c_exp
+                                  by solve( !KU( ~x ) @ #vk.29 )
+                                qed
+                              qed
+                            next
+                              case c_hash
+                              solve( !KU( 'g'^(~x*~y) ) @ #vk.19 )
+                                case Agent_SendSecureSessionRequest_case_1
+                                by solve( !KU( ~y ) @ #vk.20 )
+                              next
+                                case Agent_SendSecureSessionRequest_case_2
+                                by solve( !KU( ~y ) @ #vk.20 )
+                              next
+                                case Client_SendSecureSessionResponse
+                                by solve( !KU( ~x ) @ #vk.20 )
+                              next
+                                case c_exp
+                                by solve( !KU( ~x ) @ #vk.22 )
+                              qed
+                            qed
+                          qed
+                        qed
+                      next
+                        case Agent_SendSecureSessionRequest_case_2
+                        solve( !KU( hash('g'^(~x*~y)) ) @ #vk.10 )
+                          case Client_SendSecureSessionResponse_case_1
+                          solve( splitEqs(7) )
+                            case split_case_1
+                            solve( splitEqs(11) )
+                              case split
+                              solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.21 )
+                                case Agent_SendSecureSessionRequest_case_1
+                                by solve( !KU( ~y ) @ #vk.28 )
+                              next
+                                case Agent_SendSecureSessionRequest_case_2
+                                by solve( !KU( ~y ) @ #vk.28 )
+                              next
+                                case Client_SendSecureSessionResponse
+                                by solve( !KU( ~x ) @ #vk.28 )
+                              next
+                                case c_exp
+                                by solve( !KU( ~x ) @ #vk.28 )
+                              qed
+                            qed
+                          next
+                            case split_case_2
+                            solve( In_KMS( $KMSId.3, $ClientId.1, ~RunId.3,
+                                           'VerifyResponse'
+                                   )[+] ▶₁ #vr.87 )
+                              case ChanIn_KMS
+                              solve( In_KMS( $ClientId.1, $KMSId.3, ~RunId.3,
+                                             <'VerifyRequest', $LtkARN.2, payload.2,
+                                              sign(<payload.2, $KeyOwnerId>, ~SignKey.5),
+                                              $KeyOwnerId>
+                                     )[+] ▶₂ #vr.101 )
+                                case ChanIn_KMS
+                                solve( In_KMS( $KMSId.2, $AgentId, ~RunId.2,
+                                               <'SignResponse',
+                                                sign(<<'g'^z.1, ReaderId.1>,
+                                                      $AgentId>,
+                                                     ~SignKey.3)
+                                               >
+                                       )[+] ▶₁ #vr.73 )
+                                  case ChanIn_KMS
+                                  solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                                 <'SignRequest', $LtkARN,
+                                                  <'g'^z.1, ReaderId.1>, $AgentId>
+                                         )[+] ▶₂ #vr.109 )
+                                    case ChanIn_KMS
+                                    solve( In_KMS( $KeyOwnerId, $KMSId.3, ~RunId.3,
+                                                   <'SignRequest', $LtkARN.1, payload.1,
+                                                    ReceiverId>
+                                           )[+] ▶₂ #vr.92 )
+                                      case ChanIn_KMS
+                                      solve( (∀ #j.
+                                               (K( <kdf1('g'^(~x*~y)),
+                                                    kdf2('g'^(~x*~y))>
+                                                ) @ #j)
+                                              ⇒
+                                               ⊥) ∥
+                                             (∃ C #r.
+                                               (KmsSignKeyRevealOwner( C ) @ #r) ∧
+                                               (HonestKmsOwner( C ) @ #i)) ∥
+                                             (∃ C #r.
+                                               (LtkReveal( C ) @ #r) ∧ (HonestReader( C ) @ #i)) )
+                                        case case_1
+                                        solve( !KU( sign(<<'g'^x.2, ReaderId.2>,
+                                                          $KeyOwnerId>,
+                                                         ~SignKey.5)
+                                               ) @ #vk.23 )
+                                          case Agent_SendEncryptedSessionKey
+                                          solve( In_KMS( $KMSId.4, $KeyOwnerId, ~RunId.4,
+                                                         <'SignResponse',
+                                                          sign(<payload.1, ReceiverId>,
+                                                               ~SignKey.6)
+                                                         >
+                                                 )[+] ▶₁ #vr.130 )
+                                            case ChanIn_KMS
+                                            solve( In_KMS( $KeyOwnerId, $KMSId.4, ~RunId.4,
+                                                           <'SignRequest', $LtkARN.1,
+                                                            payload.1, ReceiverId>
+                                                   )[+] ▶₂ #vr.140 )
+                                              case ChanIn_KMS_case_1
+                                              by solve( In_KMS( $KeyOwnerId, $KMSId.4, ~RunId.4,
+                                                                <'SignRequest',
+                                                                 $LtkARN.1,
+                                                                 <'g'^x.2, ReaderId.2
+                                                                 >,
+                                                                 $KeyOwnerId>
+                                                        )[+] ▶₂ #vr.127 )
+                                            next
+                                              case ChanIn_KMS_case_2
+                                              by contradiction /* cyclic */
+                                            qed
+                                          qed
+                                        next
+                                          case Agent_SendSecureSessionRequest_case_1
+                                          solve( In_KMS( $KMSId.4, $KeyOwnerId, ~RunId.4,
+                                                         <'SignResponse',
+                                                          sign(<
+                                                                <'g'^x.2, ReaderId.2
+                                                                >,
+                                                                $KeyOwnerId>,
+                                                               ~SignKey.5)
+                                                         >
+                                                 )[+] ▶₁ #vr.119 )
+                                            case ChanIn_KMS
+                                            solve( In_KMS( $KeyOwnerId, $KMSId.4, ~RunId.4,
+                                                           <'SignRequest', $LtkARN.1,
+                                                            <'g'^x.2, ReaderId.2>,
+                                                            $KeyOwnerId>
+                                                   )[+] ▶₂ #vr.128 )
+                                              case ChanIn_KMS
+                                              by solve( splitEqs(11) )
+                                            qed
+                                          qed
+                                        next
+                                          case Agent_SendSecureSessionRequest_case_2
+                                          solve( In_KMS( $KMSId.4, $KeyOwnerId, ~RunId.4,
+                                                         <'SignResponse',
+                                                          sign(<
+                                                                <'g'^x.2, ReaderId.2
+                                                                >,
+                                                                $KeyOwnerId>,
+                                                               ~SignKey.5)
+                                                         >
+                                                 )[+] ▶₁ #vr.120 )
+                                            case ChanIn_KMS
+                                            solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                                           <'SignRequest', $LtkARN,
+                                                            <'g'^~x.1, $ReaderId.1>,
+                                                            $AgentId>
+                                                   )[+] ▶₂ #vr.77 )
+                                              case ChanIn_KMS
+                                              solve( In_KMS( $KeyOwnerId, $KMSId.4, ~RunId.4,
+                                                             <'SignRequest', $LtkARN.1,
+                                                              <'g'^x.2, ReaderId.2>,
+                                                              $KeyOwnerId>
+                                                     )[+] ▶₂ #vr.126 )
+                                                case ChanIn_KMS
+                                                solve( splitEqs(11) )
+                                                  case split
+                                                  solve( Commit( 'Agent', 'Client',
+                                                                 <AgentId2, ClientId2,
+                                                                  kdf1('g'^(~x*~y)),
+                                                                  kdf2('g'^(~x*~y))>
+                                                         ) @ #i2 )
+                                                    case Agent_SendHandshakeComplete
+                                                    solve( St_Agent_9( ~RunId.1, $AgentId.1,
+                                                                       $KMSId.1, $ClientId,
+                                                                       $ReaderId.1, $AgentLtKeyId.1,
+                                                                       logPk, ~x.1, SigX,
+                                                                       ClientLtKeyId.1,
+                                                                       'g'^x.2, SigY,
+                                                                       SigSessionKey
+                                                           ) ▶₀ #i2 )
+                                                      case Agent_SendEncryptedSessionKey
+                                                      solve( In_KMS( $KMSId.1, $AgentId.1, ~RunId.1,
+                                                                     <'SignResponse',
+                                                                      sign(<payload.1, ReceiverId
+                                                                           >,
+                                                                           ~SignKey.3)
+                                                                     >
+                                                             )[+] ▶₁ #vr.89 )
+                                                        case ChanIn_KMS
+                                                        solve( splitEqs(16) )
+                                                          case split_case_1
+                                                          by contradiction /* from formulas */
+                                                        next
+                                                          case split_case_2
+                                                          solve( !KU( 'g'^(~x*~y*inv(~x.1))
+                                                                 ) @ #vk.23 )
+                                                            case Agent_SendSecureSessionRequest
+                                                            by solve( !KU( ~y ) @ #vk.28 )
+                                                          next
+                                                            case Client_SendSecureSessionResponse
+                                                            by solve( !KU( ~x ) @ #vk.28 )
+                                                          next
+                                                            case c_exp
+                                                            by solve( !KU( ~x ) @ #vk.29 )
+                                                          qed
+                                                        qed
+                                                      qed
+                                                    qed
+                                                  qed
+                                                qed
+                                              qed
+                                            qed
+                                          qed
+                                        next
+                                          case Client_SendSecureSessionResponse_case_1
+                                          solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                                                         <'SignRequest', $AgentLtKeyId,
+                                                          <'g'^~x, $ReaderId>,
+                                                          $ClientId>
+                                                 )[+] ▶₂ #vr.28 )
+                                            case ChanIn_KMS
+                                            solve( splitEqs(11) )
+                                              case split
+                                              solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.24 )
+                                                case Agent_SendSecureSessionRequest_case_1
+                                                by solve( !KU( ~y ) @ #vk.36 )
+                                              next
+                                                case Agent_SendSecureSessionRequest_case_2
+                                                by solve( !KU( ~y ) @ #vk.36 )
+                                              next
+                                                case Client_SendSecureSessionResponse
+                                                by solve( !KU( ~x ) @ #vk.36 )
+                                              next
+                                                case c_exp
+                                                by solve( !KU( ~x ) @ #vk.37 )
+                                              qed
+                                            qed
+                                          qed
+                                        next
+                                          case Client_SendSecureSessionResponse_case_2
+                                          solve( splitEqs(11) )
+                                            case split
+                                            solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.24 )
+                                              case Agent_SendSecureSessionRequest_case_1
+                                              by solve( !KU( ~y ) @ #vk.36 )
+                                            next
+                                              case Agent_SendSecureSessionRequest_case_2
+                                              by solve( !KU( ~y ) @ #vk.36 )
+                                            next
+                                              case Client_SendSecureSessionResponse
+                                              by solve( !KU( ~x ) @ #vk.36 )
+                                            next
+                                              case c_exp
+                                              by solve( !KU( ~x ) @ #vk.37 )
+                                            qed
+                                          qed
+                                        next
+                                          case c_sign
+                                          solve( splitEqs(11) )
+                                            case split
+                                            solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.23 )
+                                              case Agent_SendSecureSessionRequest_case_1
+                                              by solve( !KU( ~y ) @ #vk.32 )
+                                            next
+                                              case Agent_SendSecureSessionRequest_case_2
+                                              by solve( !KU( ~y ) @ #vk.32 )
+                                            next
+                                              case Client_SendSecureSessionResponse
+                                              by solve( !KU( ~x ) @ #vk.32 )
+                                            next
+                                              case c_exp
+                                              by solve( !KU( ~x ) @ #vk.33 )
+                                            qed
+                                          qed
+                                        qed
+                                      next
+                                        case case_2
+                                        by contradiction /* from formulas */
+                                      next
+                                        case case_3
+                                        by contradiction /* from formulas */
+                                      qed
+                                    qed
+                                  qed
+                                qed
+                              qed
+                            qed
+                          qed
+                        next
+                          case Client_SendSecureSessionResponse_case_2
+                          solve( splitEqs(11) )
+                            case split
+                            solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.21 )
+                              case Agent_SendSecureSessionRequest_case_1
+                              by solve( !KU( ~y ) @ #vk.28 )
+                            next
+                              case Agent_SendSecureSessionRequest_case_2
+                              by solve( !KU( ~y ) @ #vk.28 )
+                            next
+                              case Client_SendSecureSessionResponse
+                              by solve( !KU( ~x ) @ #vk.28 )
+                            next
+                              case c_exp
+                              by solve( !KU( ~x ) @ #vk.29 )
+                            qed
+                          qed
+                        next
+                          case c_hash
+                          solve( !KU( 'g'^(~x*~y) ) @ #vk.19 )
+                            case Agent_SendSecureSessionRequest_case_1
+                            by solve( !KU( ~y ) @ #vk.20 )
+                          next
+                            case Agent_SendSecureSessionRequest_case_2
+                            by solve( !KU( ~y ) @ #vk.20 )
+                          next
+                            case Client_SendSecureSessionResponse
+                            by solve( !KU( ~x ) @ #vk.20 )
+                          next
+                            case c_exp
+                            by solve( !KU( ~x ) @ #vk.22 )
+                          qed
+                        qed
+                      next
+                        case Client_SendSecureSessionResponse_case_1
+                        by solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                          <'SignRequest', $LtkARN,
+                                           <X, ReaderId.1>, $AgentId>
+                                  )[+] ▶₂ #vr.83 )
+                      next
+                        case Client_SendSecureSessionResponse_case_2
+                        by solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                          <'SignRequest', $LtkARN,
+                                           <X, ReaderId.1>, $AgentId>
+                                  )[+] ▶₂ #vr.84 )
+                      next
+                        case c_sign
+                        solve( !KU( ~SignKey.3 ) @ #vk.21 )
+                          case Reveal_KmsSignKey
+                          by contradiction /* from formulas */
+                        qed
+                      qed
+                    qed
+                  qed
+                qed
+              next
+                case Client_SendSecureSessionResponse_case_2
+                solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN, Y, $AgentId>
+                       )[+] ▶₂ #vr.54 )
+                  case ChanIn_KMS
+                  solve( !KU( hash('g'^(~x*~y)) ) @ #vk.9 )
+                    case Client_SendSecureSessionResponse_case_1
+                    solve( In_KMS( $KMSId.2, $ClientId.1, ~RunId.2,
+                                   'VerifyResponse'
+                           )[+] ▶₁ #vr.69 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $ClientId.1, $KMSId.2, ~RunId.2,
+                                     <'VerifyRequest', $LtkARN.1, payload.2,
+                                      sign(<payload.2, $KeyOwnerId>, ~SignKey.4), $KeyOwnerId
+                                     >
+                             )[+] ▶₂ #vr.83 )
+                        case ChanIn_KMS
+                        solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                                       'VerifyResponse'
+                               )[+] ▶₁ #vr.49 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                         <'VerifyRequest', $LtkARN.2, payload.2,
+                                          sign(<payload.2, $KeyOwnerId.1>, ~SignKey.5),
+                                          $KeyOwnerId.1>
+                                 )[+] ▶₂ #vr.91 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                           <'SignRequest', $LtkARN, payload.1, ReceiverId
+                                           >
+                                   )[+] ▶₂ #vr.74 )
+                              case ChanIn_KMS
+                              solve( splitEqs(10) )
+                                case split
+                                solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.21 )
+                                  case Agent_SendSecureSessionRequest_case_1
+                                  by solve( !KU( ~y ) @ #vk.28 )
+                                next
+                                  case Agent_SendSecureSessionRequest_case_2
+                                  by solve( !KU( ~y ) @ #vk.28 )
+                                next
+                                  case Client_SendSecureSessionResponse
+                                  by solve( !KU( ~x ) @ #vk.28 )
+                                next
+                                  case c_exp
+                                  by solve( !KU( ~x ) @ #vk.29 )
+                                qed
+                              qed
+                            qed
+                          qed
+                        qed
+                      qed
+                    qed
+                  next
+                    case Client_SendSecureSessionResponse_case_2
+                    solve( In_KMS( $KMSId.2, $ClientId.1, ~RunId.2,
+                                   'VerifyResponse'
+                           )[+] ▶₁ #vr.70 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $ClientId.1, $KMSId.2, ~RunId.2,
+                                     <'VerifyRequest', $LtkARN.1, payload.2,
+                                      sign(<payload.2, $KeyOwnerId>, ~SignKey.4), $KeyOwnerId
+                                     >
+                             )[+] ▶₂ #vr.84 )
+                        case ChanIn_KMS
+                        solve( In_KMS( $KMSId.1, $AgentId, ~RunId.1,
+                                       'VerifyResponse'
+                               )[+] ▶₁ #vr.49 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $AgentId, $KMSId.1, ~RunId.1,
+                                         <'VerifyRequest', $LtkARN.2, payload.2,
+                                          sign(<payload.2, $KeyOwnerId.1>, ~SignKey.5),
+                                          $KeyOwnerId.1>
+                                 )[+] ▶₂ #vr.92 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $KeyOwnerId, $KMSId.2, ~RunId.2,
+                                           <'SignRequest', $LtkARN, payload.1, ReceiverId
+                                           >
+                                   )[+] ▶₂ #vr.75 )
+                              case ChanIn_KMS
+                              solve( splitEqs(12) )
+                                case split_case_1
+                                solve( splitEqs(10) )
+                                  case split
+                                  solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.21 )
+                                    case Agent_SendSecureSessionRequest_case_1
+                                    by solve( !KU( ~y ) @ #vk.28 )
+                                  next
+                                    case Agent_SendSecureSessionRequest_case_2
+                                    by solve( !KU( ~y ) @ #vk.28 )
+                                  next
+                                    case Client_SendSecureSessionResponse
+                                    by solve( !KU( ~x ) @ #vk.28 )
+                                  next
+                                    case c_exp
+                                    by solve( !KU( ~x ) @ #vk.28 )
+                                  qed
+                                qed
+                              next
+                                case split_case_2
+                                solve( splitEqs(10) )
+                                  case split_case_1
+                                  solve( !KU( sign(<<'g'^~x, ReaderId.1>, $AgentId
+                                                   >,
+                                                   ~SignKey.3)
+                                         ) @ #vk.15 )
+                                    case Agent_SendEncryptedSessionKey
+                                    solve( In_KMS( $KMSId.2, $AgentId, ~RunId.2,
+                                                   <'SignResponse',
+                                                    sign(<payload.1, ReceiverId>, ~SignKey.4)
+                                                   >
+                                           )[+] ▶₁ #vr.88 )
+                                      case ChanIn_KMS
+                                      by solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                                        <'SignRequest', $LtkARN.1,
+                                                         <'g'^~x, ReaderId.1>,
+                                                         $AgentId>
+                                                )[+] ▶₂ #vr.85 )
+                                    qed
+                                  next
+                                    case Agent_SendSecureSessionRequest_case_1
+                                    solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                                   <'SignRequest', $LtkARN,
+                                                    <'g'^~x, ReaderId.1>, $AgentId>
+                                           )[+] ▶₂ #vr.81 )
+                                      case ChanIn_KMS
+                                      solve( Commit( 'Agent', 'Client',
+                                                     <AgentId2, ClientId2,
+                                                      kdf1('g'^(~x*~y)),
+                                                      kdf2('g'^(~x*~y))>
+                                             ) @ #i2 )
+                                        case Agent_SendHandshakeComplete
+                                        solve( St_Agent_9( ~RunId.1, $AgentId.1, $KMSId.1,
+                                                           $ClientId, $ReaderId.1, $AgentLtKeyId.1,
+                                                           logPk, ~x.1, SigX, ClientLtKeyId.1,
+                                                           'g'^x.2, SigY, SigSessionKey
+                                               ) ▶₀ #i2 )
+                                          case Agent_SendEncryptedSessionKey
+                                          solve( splitEqs(16) )
+                                            case split_case_1
+                                            by contradiction /* from formulas */
+                                          next
+                                            case split_case_2
+                                            solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.23 )
+                                              case Agent_SendSecureSessionRequest
+                                              by solve( !KU( ~y ) @ #vk.28 )
+                                            next
+                                              case Client_SendSecureSessionResponse
+                                              by solve( !KU( ~x ) @ #vk.28 )
+                                            next
+                                              case c_exp
+                                              by solve( !KU( ~x ) @ #vk.29 )
+                                            qed
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  next
+                                    case Agent_SendSecureSessionRequest_case_2
+                                    solve( In_KMS( $KMSId.2, $AgentId, ~RunId.2,
+                                                   <'SignResponse',
+                                                    sign(<<'g'^~x, ReaderId.1>,
+                                                          $AgentId>,
+                                                         ~SignKey.3)
+                                                   >
+                                           )[+] ▶₁ #vr.78 )
+                                      case ChanIn_KMS
+                                      solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                                     <'SignRequest', $LtkARN,
+                                                      <'g'^~x, ReaderId.1>, $AgentId
+                                                     >
+                                             )[+] ▶₂ #vr.87 )
+                                        case ChanIn_KMS
+                                        solve( Commit( 'Agent', 'Client',
+                                                       <AgentId2, ClientId2,
+                                                        kdf1('g'^(~x*~y)),
+                                                        kdf2('g'^(~x*~y))>
+                                               ) @ #i2 )
+                                          case Agent_SendHandshakeComplete
+                                          solve( St_Agent_9( ~RunId.1, $AgentId.1, $KMSId.1,
+                                                             $ClientId, $ReaderId.1,
+                                                             $AgentLtKeyId.1, logPk, ~x.1, SigX,
+                                                             ClientLtKeyId.1, 'g'^x.2, SigY,
+                                                             SigSessionKey
+                                                 ) ▶₀ #i2 )
+                                            case Agent_SendEncryptedSessionKey
+                                            solve( splitEqs(16) )
+                                              case split_case_1
+                                              by contradiction /* from formulas */
+                                            next
+                                              case split_case_2
+                                              solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.23 )
+                                                case Agent_SendSecureSessionRequest
+                                                by solve( !KU( ~y ) @ #vk.28 )
+                                              next
+                                                case Client_SendSecureSessionResponse
+                                                by solve( !KU( ~x ) @ #vk.28 )
+                                              next
+                                                case c_exp
+                                                by solve( !KU( ~x ) @ #vk.29 )
+                                              qed
+                                            qed
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  next
+                                    case Client_SendSecureSessionResponse_case_1
+                                    solve( In_KMS( $AgentId, $KMSId, ~RunId,
+                                                   <'SignRequest', $AgentLtKeyId,
+                                                    <'g'^~x, $ReaderId>, $ClientId>
+                                           )[+] ▶₂ #vr.28 )
+                                      case ChanIn_KMS
+                                      by solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                                        <'SignRequest', $LtkARN,
+                                                         <'g'^~x, ReaderId.1>,
+                                                         $AgentId>
+                                                )[+] ▶₂ #vr.82 )
+                                    qed
+                                  next
+                                    case Client_SendSecureSessionResponse_case_2
+                                    by solve( In_KMS( $AgentId, $KMSId.2, ~RunId.2,
+                                                      <'SignRequest', $LtkARN,
+                                                       <'g'^~x, ReaderId.1>, $AgentId
+                                                      >
+                                              )[+] ▶₂ #vr.86 )
+                                  next
+                                    case c_sign
+                                    solve( !KU( ~SignKey.3 ) @ #vk.21 )
+                                      case Reveal_KmsSignKey
+                                      by contradiction /* from formulas */
+                                    qed
+                                  qed
+                                next
+                                  case split_case_2
+                                  solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.21 )
+                                    case Agent_SendSecureSessionRequest_case_1
+                                    by solve( !KU( ~y ) @ #vk.28 )
+                                  next
+                                    case Agent_SendSecureSessionRequest_case_2
+                                    by solve( !KU( ~y ) @ #vk.28 )
+                                  next
+                                    case Client_SendSecureSessionResponse
+                                    by solve( !KU( ~x ) @ #vk.28 )
+                                  next
+                                    case c_exp
+                                    by solve( !KU( ~x ) @ #vk.29 )
+                                  qed
+                                qed
+                              qed
+                            qed
+                          qed
+                        qed
+                      qed
+                    qed
+                  next
+                    case c_hash
+                    solve( !KU( 'g'^(~x*~y) ) @ #vk.19 )
+                      case Agent_SendSecureSessionRequest_case_1
+                      by solve( !KU( ~y ) @ #vk.20 )
+                    next
+                      case Agent_SendSecureSessionRequest_case_2
+                      by solve( !KU( ~y ) @ #vk.20 )
+                    next
+                      case Client_SendSecureSessionResponse
+                      by solve( !KU( ~x ) @ #vk.20 )
+                    next
+                      case c_exp
+                      by solve( !KU( ~x ) @ #vk.22 )
+                    qed
+                  qed
+                qed
+              next
+                case c_sign
+                solve( !KU( ~SignKey.1 ) @ #vk.11 )
+                  case Reveal_KmsSignKey
+                  by contradiction /* from formulas */
+                qed
+              qed
+            qed
+          next
+            case ChanIn_KMS_case_2
+            by contradiction /* cyclic */
+          qed
+        qed
+      qed
+    qed
+  qed
+qed
+// #endregion
+
+
+lemma injectiveagreement_client:
+    "All AgentId ClientId k1 k2 #i.
+      Commit('Client', 'Agent', <AgentId, ClientId, k1, k2>) @i
+      ==> (Ex #j. Running('Agent', 'Client', <AgentId, ClientId, k1, k2>) @j & j < i
+          & not (Ex AgentId2 ClientId2 #i2. Commit('Client', 'Agent', <AgentId2, ClientId2, k1, k2>) @i2
+                             & not (#i2 = #i)))
+                | (Ex C #r. LtkReveal(C)@r & HonestReader(C)@i)
+                | (Ex C #r. KmsSignKeyRevealOwner(C)@r & HonestKmsOwner(C)@i)"
+// #region(collapsed) Proof
+simplify
+solve( Commit( 'Client', 'Agent',
+               <AgentId, ClientId, k1, k2>
+       ) @ #i )
+  case Client_RecvHandshakeComplete
+  solve( Client_S6( ~RunId, $ClientId, $KMSId, $AgentId,
+                    $ClientLtKeyId, AgentLtKeyId, X, SigX, ReaderId, ~y, SigY
+         ) ▶₀ #i )
+    case Client_SendSecureSessionResponse
+    solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                   <'SignRequest', $LtkARN, payload, ReceiverId>
+           )[+] ▶₂ #vr.9 )
+      case ChanIn_KMS
+      solve( In_KMS( $KMSId, $ClientId, ~RunId, 'VerifyResponse'
+             )[+] ▶₁ #vr.4 )
+        case ChanIn_KMS
+        solve( In_KMS( $ClientId, $KMSId, ~RunId,
+                       <'VerifyRequest', $LtkARN, payload.1,
+                        sign(<payload.1, $KeyOwnerId>, ~SignKey.1), $KeyOwnerId>
+               )[+] ▶₂ #vr.20 )
+          case ChanIn_KMS
+          solve( (∀ #j. (K( <kdf1(z), kdf2(z)> ) @ #j) ⇒ ⊥) ∥
+                 (∃ C #r.
+                   (KmsSignKeyRevealOwner( C ) @ #r) ∧ (HonestKmsOwner( C ) @ #i)) ∥
+                 (∃ C #r. (LtkReveal( C ) @ #r) ∧ (HonestReader( C ) @ #i)) )
+            case case_1
+            solve( !KU( sign(<<X, ReaderId>, $ClientId>, ~SignKey)
+                   ) @ #vk.8 )
+              case Agent_SendEncryptedSessionKey
+              solve( In_KMS( $KMSId.1, $ClientId, ~RunId.1,
+                             <'SignResponse',
+                              sign(<payload.1, ReceiverId>, ~SignKey.2)>
+                     )[+] ▶₁ #vr.40 )
+                case ChanIn_KMS
+                solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN.1, payload.1, ReceiverId>
+                       )[+] ▶₂ #vr.50 )
+                  case ChanIn_KMS_case_1
+                  by solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                                    <'SignRequest', $LtkARN, <X, ReaderId>,
+                                     $ClientId>
+                            )[+] ▶₂ #vr.37 )
+                next
+                  case ChanIn_KMS_case_2
+                  by contradiction /* cyclic */
+                qed
+              qed
+            next
+              case Agent_SendSecureSessionRequest_case_1
+              solve( In_KMS( $KMSId.1, $ClientId, ~RunId.1,
+                             <'SignResponse',
+                              sign(<<X, ReaderId>, $ClientId>, ~SignKey)>
+                     )[+] ▶₁ #vr.29 )
+                case ChanIn_KMS
+                solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                               >
+                       )[+] ▶₂ #vr.38 )
+                  case ChanIn_KMS
+                  solve( !KU( senc(<'HandshakeCompletePayload', payload
+                                   >,
+                                   kdf1('g'^(~x*~y)))
+                         ) @ #vk.6 )
+                    case Agent_SendHandshakeComplete_case_1
+                    solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                   <'SignResponse',
+                                    sign(<payload.1, ReceiverId>, ~SignKey.2)>
+                           )[+] ▶₁ #vr.57 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                     <'SignRequest', $LtkARN, payload.1, ReceiverId>
+                             )[+] ▶₂ #vr.67 )
+                        case ChanIn_KMS_case_1
+                        solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                       <'SignRequest', $LtkARN.1, payload.1, ReceiverId
+                                       >
+                               )[+] ▶₂ #vr.53 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                         'VerifyResponse'
+                                 )[+] ▶₁ #vr.48 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                           <'VerifyRequest', $LtkARN.1, payload.1,
+                                            sign(<payload.1, $KeyOwnerId>, ~SignKey.4),
+                                            $KeyOwnerId>
+                                   )[+] ▶₂ #vr.78 )
+                              case ChanIn_KMS
+                              solve( splitEqs(8) )
+                                case split_case_1
+                                solve( !KU( sign(<'g'^~y, $ClientId>, ~SignKey.2)
+                                       ) @ #vk.18 )
+                                  case Agent_SendEncryptedSessionKey
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.84 )
+                                next
+                                  case Agent_SendSecureSessionRequest_case_1
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.80 )
+                                next
+                                  case Agent_SendSecureSessionRequest_case_2
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.81 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                 <'SignRequest', $LtkARN,
+                                                  'g'^~y, $ClientId>
+                                         )[+] ▶₂ #vr.84 )
+                                    case ChanIn_KMS
+                                    solve( Commit( 'Client', 'Agent',
+                                                   <AgentId2, ClientId2,
+                                                    kdf1('g'^(~x*~y)),
+                                                    kdf2('g'^(~x*~y))>
+                                           ) @ #i2 )
+                                      case Client_RecvHandshakeComplete
+                                      solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                        $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                        'g'^x.1, SigX, ReaderId.1, ~y.1,
+                                                        SigY
+                                             ) ▶₀ #i2 )
+                                        case Client_SendSecureSessionResponse
+                                        solve( splitEqs(16) )
+                                          case split_case_1
+                                          by contradiction /* from formulas */
+                                        next
+                                          case split_case_2
+                                          solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.33 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.33 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.34 )
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                 <'SignRequest', $LtkARN,
+                                                  'g'^~y, $ClientId>
+                                         )[+] ▶₂ #vr.85 )
+                                    case ChanIn_KMS
+                                    solve( Commit( 'Client', 'Agent',
+                                                   <AgentId2, ClientId2,
+                                                    kdf1('g'^(~x*~y)),
+                                                    kdf2('g'^(~x*~y))>
+                                           ) @ #i2 )
+                                      case Client_RecvHandshakeComplete
+                                      solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                        $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                        'g'^x.1, SigX, ReaderId.1, ~y.1,
+                                                        SigY
+                                             ) ▶₀ #i2 )
+                                        case Client_SendSecureSessionResponse
+                                        solve( splitEqs(16) )
+                                          case split_case_1
+                                          by contradiction /* from formulas */
+                                        next
+                                          case split_case_2
+                                          solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.33 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.33 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.34 )
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case c_sign
+                                  solve( !KU( ~SignKey.2 ) @ #vk.23 )
+                                    case Reveal_KmsSignKey
+                                    by contradiction /* from formulas */
+                                  qed
+                                qed
+                              next
+                                case split_case_2
+                                solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.16 )
+                                  case Agent_SendSecureSessionRequest
+                                  by solve( !KU( ~y ) @ #vk.23 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  by solve( !KU( ~x ) @ #vk.23 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  by solve( !KU( ~x ) @ #vk.23 )
+                                next
+                                  case c_exp
+                                  by solve( !KU( ~x ) @ #vk.24 )
+                                qed
+                              qed
+                            qed
+                          qed
+                        qed
+                      next
+                        case ChanIn_KMS_case_2
+                        by contradiction /* cyclic */
+                      qed
+                    qed
+                  next
+                    case Agent_SendHandshakeComplete_case_2
+                    solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                   <'SignResponse',
+                                    sign(<payload.1, ReceiverId>, ~SignKey.2)>
+                           )[+] ▶₁ #vr.58 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                     <'SignRequest', $LtkARN, payload.1, ReceiverId>
+                             )[+] ▶₂ #vr.68 )
+                        case ChanIn_KMS_case_1
+                        solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                       'VerifyResponse'
+                               )[+] ▶₁ #vr.49 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                         <'VerifyRequest', $LtkARN.2, payload.2,
+                                          sign(<payload.2, $KeyOwnerId>, ~SignKey.4),
+                                          $KeyOwnerId>
+                                 )[+] ▶₂ #vr.75 )
+                            case ChanIn_KMS
+                            solve( splitEqs(8) )
+                              case split_case_1
+                              solve( !KU( sign(<'g'^~y, $ClientId>, ~SignKey.2)
+                                     ) @ #vk.18 )
+                                case Agent_SendEncryptedSessionKey
+                                by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                  <'SignRequest', $LtkARN,
+                                                   'g'^~y, $ClientId>
+                                          )[+] ▶₂ #vr.81 )
+                              next
+                                case Agent_SendSecureSessionRequest_case_1
+                                by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                  <'SignRequest', $LtkARN,
+                                                   'g'^~y, $ClientId>
+                                          )[+] ▶₂ #vr.77 )
+                              next
+                                case Agent_SendSecureSessionRequest_case_2
+                                by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                  <'SignRequest', $LtkARN,
+                                                   'g'^~y, $ClientId>
+                                          )[+] ▶₂ #vr.78 )
+                              next
+                                case Client_SendSecureSessionResponse_case_1
+                                solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                               <'SignRequest', $LtkARN, 'g'^~y,
+                                                $ClientId>
+                                       )[+] ▶₂ #vr.81 )
+                                  case ChanIn_KMS
+                                  solve( Commit( 'Client', 'Agent',
+                                                 <AgentId2, ClientId2,
+                                                  kdf1('g'^(~x*~y)),
+                                                  kdf2('g'^(~x*~y))>
+                                         ) @ #i2 )
+                                    case Client_RecvHandshakeComplete
+                                    solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                      $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                      'g'^x.1, SigX, ReaderId.1, ~y.1, SigY
+                                           ) ▶₀ #i2 )
+                                      case Client_SendSecureSessionResponse
+                                      solve( splitEqs(14) )
+                                        case split_case_1
+                                        by contradiction /* from formulas */
+                                      next
+                                        case split_case_2
+                                        solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                          case Agent_SendSecureSessionRequest
+                                          by solve( !KU( ~y ) @ #vk.33 )
+                                        next
+                                          case Client_SendSecureSessionResponse
+                                          by solve( !KU( ~x ) @ #vk.33 )
+                                        next
+                                          case c_exp
+                                          by solve( !KU( ~x ) @ #vk.34 )
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                qed
+                              next
+                                case Client_SendSecureSessionResponse_case_2
+                                solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                               <'SignRequest', $LtkARN, 'g'^~y,
+                                                $ClientId>
+                                       )[+] ▶₂ #vr.82 )
+                                  case ChanIn_KMS
+                                  solve( Commit( 'Client', 'Agent',
+                                                 <AgentId2, ClientId2,
+                                                  kdf1('g'^(~x*~y)),
+                                                  kdf2('g'^(~x*~y))>
+                                         ) @ #i2 )
+                                    case Client_RecvHandshakeComplete
+                                    solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                      $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                      'g'^x.1, SigX, ReaderId.1, ~y.1, SigY
+                                           ) ▶₀ #i2 )
+                                      case Client_SendSecureSessionResponse
+                                      solve( splitEqs(14) )
+                                        case split_case_1
+                                        by contradiction /* from formulas */
+                                      next
+                                        case split_case_2
+                                        solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                          case Agent_SendSecureSessionRequest
+                                          by solve( !KU( ~y ) @ #vk.33 )
+                                        next
+                                          case Client_SendSecureSessionResponse
+                                          by solve( !KU( ~x ) @ #vk.33 )
+                                        next
+                                          case c_exp
+                                          by solve( !KU( ~x ) @ #vk.34 )
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                qed
+                              next
+                                case c_sign
+                                solve( !KU( ~SignKey.2 ) @ #vk.23 )
+                                  case Reveal_KmsSignKey
+                                  by contradiction /* from formulas */
+                                qed
+                              qed
+                            next
+                              case split_case_2
+                              solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.16 )
+                                case Agent_SendSecureSessionRequest
+                                by solve( !KU( ~y ) @ #vk.23 )
+                              next
+                                case Client_SendSecureSessionResponse_case_1
+                                by solve( !KU( ~x ) @ #vk.23 )
+                              next
+                                case Client_SendSecureSessionResponse_case_2
+                                by solve( !KU( ~x ) @ #vk.23 )
+                              next
+                                case c_exp
+                                by solve( !KU( ~x ) @ #vk.24 )
+                              qed
+                            qed
+                          qed
+                        qed
+                      next
+                        case ChanIn_KMS_case_2
+                        by contradiction /* cyclic */
+                      qed
+                    qed
+                  next
+                    case c_senc
+                    solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.13 )
+                      case Agent_SendEncryptedSessionKey
+                      solve( splitEqs(7) )
+                        case split_case_1
+                        solve( !KU( ~ltk ) @ #vk.16 )
+                          case Reveal_ltk
+                          by contradiction /* from formulas */
+                        qed
+                      next
+                        case split_case_2
+                        solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.20 )
+                          case Agent_SendSecureSessionRequest
+                          by solve( !KU( ~y ) @ #vk.27 )
+                        next
+                          case Client_SendSecureSessionResponse_case_1
+                          by solve( !KU( ~x ) @ #vk.27 )
+                        next
+                          case Client_SendSecureSessionResponse_case_2
+                          by solve( !KU( ~x ) @ #vk.27 )
+                        next
+                          case c_exp
+                          by solve( !KU( ~x ) @ #vk.28 )
+                        qed
+                      qed
+                    next
+                      case c_kdf1
+                      solve( !KU( 'g'^(~x*~y) ) @ #vk.16 )
+                        case Agent_SendSecureSessionRequest
+                        by solve( !KU( ~y ) @ #vk.17 )
+                      next
+                        case Client_SendSecureSessionResponse_case_1
+                        by solve( !KU( ~x ) @ #vk.17 )
+                      next
+                        case Client_SendSecureSessionResponse_case_2
+                        by solve( !KU( ~x ) @ #vk.17 )
+                      next
+                        case c_exp
+                        by solve( !KU( ~x ) @ #vk.19 )
+                      qed
+                    qed
+                  qed
+                qed
+              qed
+            next
+              case Agent_SendSecureSessionRequest_case_2
+              solve( In_KMS( $KMSId.1, $ClientId, ~RunId.1,
+                             <'SignResponse',
+                              sign(<<X, ReaderId>, $ClientId>, ~SignKey)>
+                     )[+] ▶₁ #vr.30 )
+                case ChanIn_KMS
+                solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                               <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                               >
+                       )[+] ▶₂ #vr.39 )
+                  case ChanIn_KMS
+                  solve( !KU( senc(<'HandshakeCompletePayload', payload
+                                   >,
+                                   kdf1('g'^(~x*~y)))
+                         ) @ #vk.5 )
+                    case Agent_SendHandshakeComplete_case_1
+                    solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                   <'SignResponse',
+                                    sign(<payload.1, ReceiverId>, ~SignKey.2)>
+                           )[+] ▶₁ #vr.58 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                     <'SignRequest', $LtkARN.1, payload.2, ReceiverId.1
+                                     >
+                             )[+] ▶₂ #vr.54 )
+                        case ChanIn_KMS_case_1
+                        solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                       <'SignRequest', $LtkARN, payload.1, ReceiverId>
+                               )[+] ▶₂ #vr.68 )
+                          case ChanIn_KMS
+                          by contradiction /* cyclic */
+                        qed
+                      next
+                        case ChanIn_KMS_case_2
+                        solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                       <'SignRequest', $LtkARN, payload.1, ReceiverId>
+                               )[+] ▶₂ #vr.68 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                         'VerifyResponse'
+                                 )[+] ▶₁ #vr.49 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                           <'VerifyRequest', $LtkARN.1, payload.1,
+                                            sign(<payload.1, $KeyOwnerId>, ~SignKey.4),
+                                            $KeyOwnerId>
+                                   )[+] ▶₂ #vr.79 )
+                              case ChanIn_KMS
+                              solve( splitEqs(8) )
+                                case split_case_1
+                                solve( !KU( sign(<'g'^~y, $ClientId>, ~SignKey.2)
+                                       ) @ #vk.18 )
+                                  case Agent_SendEncryptedSessionKey
+                                  solve( In_KMS( $KMSId.2, $ClientId, ~RunId.2,
+                                                 <'SignResponse',
+                                                  sign(<payload.1, ReceiverId>, ~SignKey.4)
+                                                 >
+                                         )[+] ▶₁ #vr.88 )
+                                    case ChanIn_KMS
+                                    by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                      <'SignRequest', $LtkARN.1,
+                                                       'g'^~y, $ClientId>
+                                              )[+] ▶₂ #vr.85 )
+                                  qed
+                                next
+                                  case Agent_SendSecureSessionRequest_case_1
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.81 )
+                                next
+                                  case Agent_SendSecureSessionRequest_case_2
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.82 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                 <'SignRequest', $LtkARN,
+                                                  'g'^~y, $ClientId>
+                                         )[+] ▶₂ #vr.85 )
+                                    case ChanIn_KMS
+                                    solve( Commit( 'Client', 'Agent',
+                                                   <AgentId2, ClientId2,
+                                                    kdf1('g'^(~x*~y)),
+                                                    kdf2('g'^(~x*~y))>
+                                           ) @ #i2 )
+                                      case Client_RecvHandshakeComplete
+                                      solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                        $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                        'g'^x.1, SigX, ReaderId.1, ~y.1,
+                                                        SigY
+                                             ) ▶₀ #i2 )
+                                        case Client_SendSecureSessionResponse
+                                        solve( splitEqs(16) )
+                                          case split_case_1
+                                          by contradiction /* from formulas */
+                                        next
+                                          case split_case_2
+                                          solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.33 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.33 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.34 )
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                 <'SignRequest', $LtkARN,
+                                                  'g'^~y, $ClientId>
+                                         )[+] ▶₂ #vr.86 )
+                                    case ChanIn_KMS
+                                    solve( Commit( 'Client', 'Agent',
+                                                   <AgentId2, ClientId2,
+                                                    kdf1('g'^(~x*~y)),
+                                                    kdf2('g'^(~x*~y))>
+                                           ) @ #i2 )
+                                      case Client_RecvHandshakeComplete
+                                      solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                        $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                        'g'^x.1, SigX, ReaderId.1, ~y.1,
+                                                        SigY
+                                             ) ▶₀ #i2 )
+                                        case Client_SendSecureSessionResponse
+                                        solve( splitEqs(16) )
+                                          case split_case_1
+                                          by contradiction /* from formulas */
+                                        next
+                                          case split_case_2
+                                          solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.33 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.33 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.34 )
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case c_sign
+                                  solve( !KU( ~SignKey.2 ) @ #vk.23 )
+                                    case Reveal_KmsSignKey
+                                    by contradiction /* from formulas */
+                                  qed
+                                qed
+                              next
+                                case split_case_2
+                                solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.16 )
+                                  case Agent_SendSecureSessionRequest
+                                  by solve( !KU( ~y ) @ #vk.23 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  by solve( !KU( ~x ) @ #vk.23 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  by solve( !KU( ~x ) @ #vk.23 )
+                                next
+                                  case c_exp
+                                  by solve( !KU( ~x ) @ #vk.24 )
+                                qed
+                              qed
+                            qed
+                          qed
+                        qed
+                      qed
+                    qed
+                  next
+                    case Agent_SendHandshakeComplete_case_2
+                    solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                   <'SignResponse',
+                                    sign(<payload.1, ReceiverId>, ~SignKey.2)>
+                           )[+] ▶₁ #vr.59 )
+                      case ChanIn_KMS
+                      solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                     <'SignRequest', $LtkARN.1, payload.2, ReceiverId.1
+                                     >
+                             )[+] ▶₂ #vr.55 )
+                        case ChanIn_KMS_case_1
+                        solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                       <'SignRequest', $LtkARN, payload.1, ReceiverId>
+                               )[+] ▶₂ #vr.69 )
+                          case ChanIn_KMS
+                          by contradiction /* cyclic */
+                        qed
+                      next
+                        case ChanIn_KMS_case_2
+                        solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                       <'SignRequest', $LtkARN, payload.1, ReceiverId>
+                               )[+] ▶₂ #vr.69 )
+                          case ChanIn_KMS
+                          solve( In_KMS( $KMSId.2, $AgentId.1, ~RunId.2,
+                                         'VerifyResponse'
+                                 )[+] ▶₁ #vr.50 )
+                            case ChanIn_KMS
+                            solve( In_KMS( $AgentId.1, $KMSId.2, ~RunId.2,
+                                           <'VerifyRequest', $LtkARN.1, payload.1,
+                                            sign(<payload.1, $KeyOwnerId>, ~SignKey.4),
+                                            $KeyOwnerId>
+                                   )[+] ▶₂ #vr.80 )
+                              case ChanIn_KMS
+                              solve( splitEqs(8) )
+                                case split_case_1
+                                solve( !KU( sign(<'g'^~y, $ClientId>, ~SignKey.2)
+                                       ) @ #vk.18 )
+                                  case Agent_SendEncryptedSessionKey
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.86 )
+                                next
+                                  case Agent_SendSecureSessionRequest_case_1
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.82 )
+                                next
+                                  case Agent_SendSecureSessionRequest_case_2
+                                  by solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                    <'SignRequest', $LtkARN,
+                                                     'g'^~y, $ClientId>
+                                            )[+] ▶₂ #vr.83 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                 <'SignRequest', $LtkARN,
+                                                  'g'^~y, $ClientId>
+                                         )[+] ▶₂ #vr.86 )
+                                    case ChanIn_KMS
+                                    solve( Commit( 'Client', 'Agent',
+                                                   <AgentId2, ClientId2,
+                                                    kdf1('g'^(~x*~y)),
+                                                    kdf2('g'^(~x*~y))>
+                                           ) @ #i2 )
+                                      case Client_RecvHandshakeComplete
+                                      solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                        $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                        'g'^x.1, SigX, ReaderId.1, ~y.1,
+                                                        SigY
+                                             ) ▶₀ #i2 )
+                                        case Client_SendSecureSessionResponse
+                                        solve( splitEqs(16) )
+                                          case split_case_1
+                                          by contradiction /* from formulas */
+                                        next
+                                          case split_case_2
+                                          solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.33 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.33 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.34 )
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  solve( In_KMS( $ClientId, $KMSId.2, ~RunId.2,
+                                                 <'SignRequest', $LtkARN,
+                                                  'g'^~y, $ClientId>
+                                         )[+] ▶₂ #vr.87 )
+                                    case ChanIn_KMS
+                                    solve( Commit( 'Client', 'Agent',
+                                                   <AgentId2, ClientId2,
+                                                    kdf1('g'^(~x*~y)),
+                                                    kdf2('g'^(~x*~y))>
+                                           ) @ #i2 )
+                                      case Client_RecvHandshakeComplete
+                                      solve( Client_S6( ~RunId.1, $ClientId, $KMSId.1, $AgentId.1,
+                                                        $ClientLtKeyId.1, AgentLtKeyId.1,
+                                                        'g'^x.1, SigX, ReaderId.1, ~y.1,
+                                                        SigY
+                                             ) ▶₀ #i2 )
+                                        case Client_SendSecureSessionResponse
+                                        solve( splitEqs(16) )
+                                          case split_case_1
+                                          by contradiction /* from formulas */
+                                        next
+                                          case split_case_2
+                                          solve( !KU( 'g'^(~x*~y*inv(~y.1)) ) @ #vk.26 )
+                                            case Agent_SendSecureSessionRequest
+                                            by solve( !KU( ~y ) @ #vk.33 )
+                                          next
+                                            case Client_SendSecureSessionResponse
+                                            by solve( !KU( ~x ) @ #vk.33 )
+                                          next
+                                            case c_exp
+                                            by solve( !KU( ~x ) @ #vk.34 )
+                                          qed
+                                        qed
+                                      qed
+                                    qed
+                                  qed
+                                next
+                                  case c_sign
+                                  solve( !KU( ~SignKey.2 ) @ #vk.23 )
+                                    case Reveal_KmsSignKey
+                                    by contradiction /* from formulas */
+                                  qed
+                                qed
+                              next
+                                case split_case_2
+                                solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.16 )
+                                  case Agent_SendSecureSessionRequest
+                                  by solve( !KU( ~y ) @ #vk.23 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_1
+                                  by solve( !KU( ~x ) @ #vk.23 )
+                                next
+                                  case Client_SendSecureSessionResponse_case_2
+                                  by solve( !KU( ~x ) @ #vk.23 )
+                                next
+                                  case c_exp
+                                  by solve( !KU( ~x ) @ #vk.24 )
+                                qed
+                              qed
+                            qed
+                          qed
+                        qed
+                      qed
+                    qed
+                  next
+                    case c_senc
+                    solve( !KU( kdf1('g'^(~x*~y)) ) @ #vk.13 )
+                      case Agent_SendEncryptedSessionKey
+                      solve( splitEqs(7) )
+                        case split_case_1
+                        solve( !KU( ~ltk ) @ #vk.16 )
+                          case Reveal_ltk
+                          by contradiction /* from formulas */
+                        qed
+                      next
+                        case split_case_2
+                        solve( !KU( 'g'^(~x*~y*inv(~x.1)) ) @ #vk.20 )
+                          case Agent_SendSecureSessionRequest
+                          by solve( !KU( ~y ) @ #vk.27 )
+                        next
+                          case Client_SendSecureSessionResponse_case_1
+                          by solve( !KU( ~x ) @ #vk.27 )
+                        next
+                          case Client_SendSecureSessionResponse_case_2
+                          by solve( !KU( ~x ) @ #vk.27 )
+                        next
+                          case c_exp
+                          by solve( !KU( ~x ) @ #vk.28 )
+                        qed
+                      qed
+                    next
+                      case c_kdf1
+                      solve( !KU( 'g'^(~x*~y) ) @ #vk.16 )
+                        case Agent_SendSecureSessionRequest
+                        by solve( !KU( ~y ) @ #vk.17 )
+                      next
+                        case Client_SendSecureSessionResponse_case_1
+                        by solve( !KU( ~x ) @ #vk.17 )
+                      next
+                        case Client_SendSecureSessionResponse_case_2
+                        by solve( !KU( ~x ) @ #vk.17 )
+                      next
+                        case c_exp
+                        by solve( !KU( ~x ) @ #vk.19 )
+                      qed
+                    qed
+                  qed
+                qed
+              qed
+            next
+              case Client_SendSecureSessionResponse_case_1
+              by solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                                <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                                >
+                        )[+] ▶₂ #vr.37 )
+            next
+              case Client_SendSecureSessionResponse_case_2
+              by solve( In_KMS( $ClientId, $KMSId.1, ~RunId.1,
+                                <'SignRequest', $LtkARN, <X, ReaderId>, $ClientId
+                                >
+                        )[+] ▶₂ #vr.38 )
+            next
+              case c_sign
+              solve( !KU( ~SignKey ) @ #vk.14 )
+                case Reveal_KmsSignKey
+                by contradiction /* from formulas */
+              qed
+            qed
+          next
+            case case_2
+            by contradiction /* from formulas */
+          next
+            case case_3
+            by contradiction /* from formulas */
+          qed
+        qed
+      qed
+    qed
+  qed
+qed
+// #endregion
+// End lemmas
+
+end
diff --git a/test.go b/test.go
new file mode 100644
index 000000000..5c682ec4a
--- /dev/null
+++ b/test.go
@@ -0,0 +1,211 @@
+package test
+
+//@ import "bytes"
+//@ import "github.com/aws/amazon-ssm-agent/agent/iospecs/abs"
+//@ import by "github.com/aws/amazon-ssm-agent/agent/iospecs/bytes"
+//@ import tm "github.com/aws/amazon-ssm-agent/agent/iospecs/term"
+//@ import "github.com/aws/amazon-ssm-agent/agent/iospecs/pub"
+
+type ActionType string
+type ActionStatus int
+type RawMessage []byte
+
+const SecureSession ActionType = "SecureSession"
+const Success ActionStatus = 1
+
+// The result of processing the action by the plugin
+type ProcessedClientAction struct {
+	ActionType   ActionType   `json:"ActionType"`
+	ActionStatus ActionStatus `json:"ActionStatus"`
+	ActionResult RawMessage   `json:"ActionResult"`
+	Error        string       `json:"Error"`
+}
+
+/*@
+pred (processedClientAction *ProcessedClientAction) Mem() {
+	acc(processedClientAction) &&
+	acc(bytes.SliceMem(processedClientAction.ActionResult))
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Type() ActionType {
+	return unfolding acc(processedClientAction.Mem(), _) in processedClientAction.ActionType
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Status() ActionStatus {
+	return unfolding acc(processedClientAction.Mem(), _) in processedClientAction.ActionStatus
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Adt() ProcessedClientActionAdt {
+	return Action{processedClientAction.Type(), processedClientAction.Status()}
+}
+
+ghost
+decreases
+requires acc(processedClientAction.Mem(), _)
+pure func (processedClientAction *ProcessedClientAction) Abs() by.Bytes {
+	return unfolding acc(processedClientAction.Mem(), _) in
+		abs.Abs(processedClientAction.ActionResult)
+}
+// pair(exp(pubTerm(const_g_pub()), z), pair(SigY, pair(ClientLtKeyId, hash(exp(exp(pubTerm(const_g_pub()), z), x)))))))
+@*/
+
+// Handshake Response sent by the plugin in response to the handshake request
+type HandshakeResponsePayload struct {
+	ClientVersion          string                  `json:"ClientVersion"`
+	ProcessedClientActions []ProcessedClientAction `json:"ProcessedClientActions"`
+	Errors                 []string                `json:"Errors"`
+}
+
+/*@
+pred (handshakeResponsePayload *HandshakeResponsePayload) Mem() {
+	acc(handshakeResponsePayload) &&
+	(forall i int :: { handshakeResponsePayload.ProcessedClientActions[i] } 0 <= i && i < len(handshakeResponsePayload.ProcessedClientActions) ==> handshakeResponsePayload.ProcessedClientActions[i].Mem()) &&
+	acc(handshakeResponsePayload.Errors)
+}
+
+// ghost
+// requires acc(handshakeResponsePayload.Mem(), _)
+// requires handshakeResponsePayload.ContainsSecureSession(i)
+// pure func (handshakeResponsePayload *HandshakeResponsePayload) Abs(i int) by.Bytes {
+// 	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+// 			by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), handshakeResponsePayload.ProcessedClientActions[i].Abs())
+// }
+
+ghost
+requires acc(handshakeResponsePayload.Mem(), _)
+pure func (handshakeResponsePayload *HandshakeResponsePayload) Abs() by.Bytes {
+// 	return handshakeResponsePayload.ContainsSecureSession() ?
+// 		(unfolding acc(handshakeResponsePayload.Mem(), _) in
+// 			by.tupleB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), )):
+// 		handshakeResponsePayload.UnknownAbs()
+	return handshakeResponsePayload.ContainsSecureSession() ?
+		(unfolding acc(handshakeResponsePayload.Mem(), _) in by.pairB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), handshakeResponsePayload.ProcessedClientActions[getSecureSessionIndex(handshakeResponsePayload.ProcessedClientActions, 0)].Abs())) :
+		handshakeResponsePayload.UnknownAbs()
+// 		by.tupleB(by.gamma(tm.pubTerm(pub.const_SecureSessionResponse_pub())), )
+// 		pair(pubTerm(const_SecureSessionResponse_pub()), pair(exp(pubTerm(const_g_pub()), z), pair(SigY, pair(ClientLtKeyId, hash(exp(exp(pubTerm(const_g_pub()), z), x)))))))
+}
+
+// used to represent an unknown byte-level representation for a given handshake response payload
+ghost
+decreases
+requires acc(handshakeResponsePayload.Mem(), _)
+pure func (handshakeResponsePayload *HandshakeResponsePayload) UnknownAbs() by.Bytes
+
+ghost
+decreases
+requires acc(handshakeResponsePayload.Mem(), _)
+pure func (handshakeResponsePayload *HandshakeResponsePayload) SecureSessionAtIndex(i int) bool {
+	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+		0 <= i && i < len(handshakeResponsePayload.ProcessedClientActions) &&
+			handshakeResponsePayload.ProcessedClientActions[i].Type() == SecureSession &&
+			handshakeResponsePayload.ProcessedClientActions[i].Status() == Success
+}
+
+ghost
+decreases
+requires acc(handshakeResponsePayload.Mem(), _)
+pure func (handshakeResponsePayload *HandshakeResponsePayload) ContainsSecureSession() bool {
+// 	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+// 		exists i int :: 0 <= i && i < len(handshakeResponsePayload.ProcessedClientActions) &&
+// 			handshakeResponsePayload.ProcessedClientActions[i].Type() == SecureSession &&
+// 			handshakeResponsePayload.ProcessedClientActions[i].Status() == Success
+	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+		containsSecureSession(handshakeResponsePayload.ProcessedClientActions, 0)
+}
+
+ghost
+decreases
+requires acc(handshakeResponsePayload.Mem(), _)
+requires handshakeResponsePayload.ContainsSecureSession()
+pure func (handshakeResponsePayload *HandshakeResponsePayload) GetSecureSessionIndex() int {
+	// return 0 <= i && i < len(handshakeResponsePayload.ProcessedClientActions) &&
+	// 		handshakeResponsePayload.ProcessedClientActions[i].Type() == SecureSession &&
+	// 		handshakeResponsePayload.ProcessedClientActions[i].Status() == Success
+	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+		getSecureSessionIndex(handshakeResponsePayload.ProcessedClientActions, 0)
+}
+
+// ghost
+// requires acc(handshakeResponsePayload, _)
+// requires 0 <= startIdx && startIdx <= len(handshakeResponsePayload.ProcessedClientActions)
+// requires forall i int :: { handshakeResponsePayload.ProcessedClientActions[i] } startIdx <= i && i < len(handshakeResponsePayload.ProcessedClientActions) ==> acc(handshakeResponsePayload.ProcessedClientActions[i].Mem(), _)
+// decreases len(handshakeResponsePayload.ProcessedClientActions) - startIdx
+// pure func (handshakeResponsePayload *HandshakeResponsePayload) containsSecureSession(startIdx int) bool {
+// 	// return exists i int :: startIdx <= i && i < len(handshakeResponsePayload.ProcessedClientActions) &&
+// 	// 		handshakeResponsePayload.ProcessedClientActions[i].Type() == SecureSession &&
+// 	// 		handshakeResponsePayload.ProcessedClientActions[i].Status() == Success
+// 	return startIdx == len(handshakeResponsePayload.ProcessedClientActions) ? false :
+// 		(handshakeResponsePayload.ProcessedClientActions[startIdx].Type() == SecureSession &&
+// 		handshakeResponsePayload.ProcessedClientActions[startIdx].Status() == Success ?
+// 			true : handshakeResponsePayload.containsSecureSession(startIdx + 1))
+// }
+
+ghost
+requires 0 <= startIdx && startIdx <= len(actions)
+requires forall i int :: { actions[i] } startIdx <= i && i < len(actions) ==> acc(actions[i].Mem(), _)
+decreases len(actions) - startIdx
+pure func containsSecureSession(actions []ProcessedClientAction, startIdx int) bool {
+	// return exists i int :: startIdx <= i && i < len(actions) &&
+	// 		actions[i].Type() == SecureSession &&
+	// 		actions[i].Status() == Success
+	return startIdx == len(actions) ? false :
+		(actions[startIdx].Type() == SecureSession &&
+		actions[startIdx].Status() == Success ?
+			true : containsSecureSession(actions, startIdx + 1))
+}
+
+// ghost
+// requires acc(handshakeResponsePayload, _)
+// requires 0 <= startIdx && startIdx <= len(handshakeResponsePayload.ProcessedClientActions)
+// requires forall i int :: { handshakeResponsePayload.ProcessedClientActions[i] } startIdx <= i && i < len(handshakeResponsePayload.ProcessedClientActions) ==> acc(handshakeResponsePayload.ProcessedClientActions[i].Mem(), _)
+// requires handshakeResponsePayload.containsSecureSession(startIdx)
+// ensures  startIdx <= res && res < len(handshakeResponsePayload.ProcessedClientActions)
+// ensures  handshakeResponsePayload.ProcessedClientActions[res].Type() == SecureSession
+// ensures  handshakeResponsePayload.ProcessedClientActions[res].Status() == Success
+// decreases len(handshakeResponsePayload.ProcessedClientActions) - startIdx
+// pure func (handshakeResponsePayload *HandshakeResponsePayload) getSecureSessionIndex(startIdx int) (res int) {
+// 	return handshakeResponsePayload.ProcessedClientActions[startIdx].Type() == SecureSession &&
+// 		handshakeResponsePayload.ProcessedClientActions[startIdx].Status() == Success ?
+// 			startIdx : handshakeResponsePayload.getSecureSessionIndex(startIdx + 1)
+// }
+
+ghost
+requires 0 <= startIdx && startIdx <= len(actions)
+requires forall i int :: { actions[i] } startIdx <= i && i < len(actions) ==> acc(actions[i].Mem(), _)
+requires containsSecureSession(actions, startIdx)
+ensures  startIdx <= res && res < len(actions)
+ensures  actions[res].Type() == SecureSession
+ensures  actions[res].Status() == Success
+decreases len(actions) - startIdx
+pure func getSecureSessionIndex(actions []ProcessedClientAction, startIdx int) (res int) {
+	return actions[startIdx].Type() == SecureSession &&
+		actions[startIdx].Status() == Success ?
+			startIdx : getSecureSessionIndex(actions, startIdx + 1)
+}
+
+type ProcessedClientActionAdt adt {
+	Action {
+		ActionType ActionType
+		ActionStatus ActionStatus
+	}
+}
+
+ghost
+requires acc(handshakeResponsePayload.Mem(), _)
+requires 0 <= startIdx && startIdx <= unfolding acc(handshakeResponsePayload.Mem(), _) in len(handshakeResponsePayload.ProcessedClientActions)
+decreases unfolding acc(handshakeResponsePayload.Mem(), _) in len(handshakeResponsePayload.ProcessedClientActions) - startIdx
+pure func (handshakeResponsePayload *HandshakeResponsePayload) Adt(startIdx int) (res seq[ProcessedClientActionAdt]) {
+	return unfolding acc(handshakeResponsePayload.Mem(), _) in
+		len(handshakeResponsePayload.ProcessedClientActions) - startIdx == 0 ? seq[ProcessedClientActionAdt]{} :
+			seq[ProcessedClientActionAdt]{ handshakeResponsePayload.ProcessedClientActions[startIdx].Adt() } ++ handshakeResponsePayload.Adt(startIdx + 1)
+}
+@*/
diff --git a/test.vpr b/test.vpr
new file mode 100644
index 000000000..5b587aea9
--- /dev/null
+++ b/test.vpr
@@ -0,0 +1,7 @@
+field f: Int
+
+method foo(x: Ref)
+requires acc(x.f) --* old[lhs](x.f) == 42
+{
+
+}
diff --git a/vendor/golang.org/x/crypto/hkdf/hkdf.go b/vendor/golang.org/x/crypto/hkdf/hkdf.go
new file mode 100644
index 000000000..dda3f143b
--- /dev/null
+++ b/vendor/golang.org/x/crypto/hkdf/hkdf.go
@@ -0,0 +1,93 @@
+// Copyright 2014 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package hkdf implements the HMAC-based Extract-and-Expand Key Derivation
+// Function (HKDF) as defined in RFC 5869.
+//
+// HKDF is a cryptographic key derivation function (KDF) with the goal of
+// expanding limited input keying material into one or more cryptographically
+// strong secret keys.
+package hkdf // import "golang.org/x/crypto/hkdf"
+
+import (
+	"crypto/hmac"
+	"errors"
+	"hash"
+	"io"
+)
+
+// Extract generates a pseudorandom key for use with Expand from an input secret
+// and an optional independent salt.
+//
+// Only use this function if you need to reuse the extracted key with multiple
+// Expand invocations and different context values. Most common scenarios,
+// including the generation of multiple keys, should use New instead.
+func Extract(hash func() hash.Hash, secret, salt []byte) []byte {
+	if salt == nil {
+		salt = make([]byte, hash().Size())
+	}
+	extractor := hmac.New(hash, salt)
+	extractor.Write(secret)
+	return extractor.Sum(nil)
+}
+
+type hkdf struct {
+	expander hash.Hash
+	size     int
+
+	info    []byte
+	counter byte
+
+	prev []byte
+	buf  []byte
+}
+
+func (f *hkdf) Read(p []byte) (int, error) {
+	// Check whether enough data can be generated
+	need := len(p)
+	remains := len(f.buf) + int(255-f.counter+1)*f.size
+	if remains < need {
+		return 0, errors.New("hkdf: entropy limit reached")
+	}
+	// Read any leftover from the buffer
+	n := copy(p, f.buf)
+	p = p[n:]
+
+	// Fill the rest of the buffer
+	for len(p) > 0 {
+		f.expander.Reset()
+		f.expander.Write(f.prev)
+		f.expander.Write(f.info)
+		f.expander.Write([]byte{f.counter})
+		f.prev = f.expander.Sum(f.prev[:0])
+		f.counter++
+
+		// Copy the new batch into p
+		f.buf = f.prev
+		n = copy(p, f.buf)
+		p = p[n:]
+	}
+	// Save leftovers for next run
+	f.buf = f.buf[n:]
+
+	return need, nil
+}
+
+// Expand returns a Reader, from which keys can be read, using the given
+// pseudorandom key and optional context info, skipping the extraction step.
+//
+// The pseudorandomKey should have been generated by Extract, or be a uniformly
+// random or pseudorandom cryptographically strong key. See RFC 5869, Section
+// 3.3. Most common scenarios will want to use New instead.
+func Expand(hash func() hash.Hash, pseudorandomKey, info []byte) io.Reader {
+	expander := hmac.New(hash, pseudorandomKey)
+	return &hkdf{expander, expander.Size(), info, 1, nil, nil}
+}
+
+// New returns a Reader, from which keys can be read, using the given hash,
+// secret, salt and context info. Salt and info can be nil.
+func New(hash func() hash.Hash, secret, salt, info []byte) io.Reader {
+	prk := Extract(hash, secret, salt)
+	return Expand(hash, prk, info)
+}
diff --git a/vendor/modules.txt b/vendor/modules.txt
index 39e9a6ae2..bb8eb2062 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -212,6 +212,8 @@ github.com/pborman/ansi
 github.com/pmezard/go-difflib/difflib
 # github.com/sergi/go-diff v1.1.0
 github.com/sergi/go-diff/diffmatchpatch
+# github.com/smartystreets/goconvey v1.7.2
+## explicit
 # github.com/stretchr/objx v0.1.1
 github.com/stretchr/objx
 # github.com/stretchr/testify v1.7.0
@@ -247,6 +249,7 @@ golang.org/x/crypto/curve25519
 golang.org/x/crypto/curve25519/internal/field
 golang.org/x/crypto/ed25519
 golang.org/x/crypto/ed25519/internal/edwards25519
+golang.org/x/crypto/hkdf
 golang.org/x/crypto/internal/subtle
 golang.org/x/crypto/openpgp
 golang.org/x/crypto/openpgp/armor
